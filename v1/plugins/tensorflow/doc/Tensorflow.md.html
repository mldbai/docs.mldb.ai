<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8' />
<title>MLDB Documentation</title>
<script src='/resources/js/mathjax_TeX-AMS-MML_HTMLorMML.js'></script>
<link rel='stylesheet' href='/resources/css/prism.css'>
<link rel='stylesheet' href='/resources/css/doc.css'>
<script src='/resources/js/jquery-1.11.2.min.js'></script>
<script src='/resources/js/prism.js'></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  if(window.location.origin == 'http://mldb.ai')
  { ga('create', 'UA-16909325-9', 'auto'); }
  else
  { ga('create', 'UA-16909325-10', {'cookieDomain': 'none'}); }
  ga('send', 'pageview');
</script>
</head>
<body style='margin-left: 50px; max-width: 1000px'>
<h1>Tensorflow documentation</h1>

<p>MLDB incorporates the Tensorflow operation graph library in order to allow
for deep learning and gradient descent operations to be used.</p>

<p>Most tensorflow functions are available in MLDB queries and expressions with a 
<code>tf_</code> prefix. MLDB embeddings will be implicitly converted to tensorflow tensors 
of the same dimensions and closest matching type, and vice versa. In case of inconsistent 
type in a MLDB embedding, it will be converted to a 64-bit floating point tensor.</p>

<p><ul><li><a href=#Abort>TensorFlow <code>Abort</code></a></li><li><a href=#Abs>TensorFlow <code>Abs</code></a></li><li><a href=#Acos>TensorFlow <code>Acos</code></a></li><li><a href=#Add>TensorFlow <code>Add</code></a></li><li><a href=#AddN>TensorFlow <code>AddN</code></a></li><li><a href=#AdjustContrast>TensorFlow <code>AdjustContrast</code></a></li><li><a href=#AdjustContrastv2>TensorFlow <code>AdjustContrastv2</code></a></li><li><a href=#All>TensorFlow <code>All</code></a></li><li><a href=#AllCandidateSampler>TensorFlow <code>AllCandidateSampler</code></a></li><li><a href=#Any>TensorFlow <code>Any</code></a></li><li><a href=#ApplyAdadelta>TensorFlow <code>ApplyAdadelta</code></a></li><li><a href=#ApplyAdagrad>TensorFlow <code>ApplyAdagrad</code></a></li><li><a href=#ApplyAdam>TensorFlow <code>ApplyAdam</code></a></li><li><a href=#ApplyFtrl>TensorFlow <code>ApplyFtrl</code></a></li><li><a href=#ApplyGradientDescent>TensorFlow <code>ApplyGradientDescent</code></a></li><li><a href=#ApplyMomentum>TensorFlow <code>ApplyMomentum</code></a></li><li><a href=#ApplyProximalAdagrad>TensorFlow <code>ApplyProximalAdagrad</code></a></li><li><a href=#ApplyProximalGradientDescent>TensorFlow <code>ApplyProximalGradientDescent</code></a></li><li><a href=#ApplyRMSProp>TensorFlow <code>ApplyRMSProp</code></a></li><li><a href=#ArgMax>TensorFlow <code>ArgMax</code></a></li><li><a href=#ArgMin>TensorFlow <code>ArgMin</code></a></li><li><a href=#AsString>TensorFlow <code>AsString</code></a></li><li><a href=#Asin>TensorFlow <code>Asin</code></a></li><li><a href=#Assert>TensorFlow <code>Assert</code></a></li><li><a href=#Assign>TensorFlow <code>Assign</code></a></li><li><a href=#AssignAdd>TensorFlow <code>AssignAdd</code></a></li><li><a href=#AssignSub>TensorFlow <code>AssignSub</code></a></li><li><a href=#Atan>TensorFlow <code>Atan</code></a></li><li><a href=#AudioSummary>TensorFlow <code>AudioSummary</code></a></li><li><a href=#AvgPool>TensorFlow <code>AvgPool</code></a></li><li><a href=#AvgPool3D>TensorFlow <code>AvgPool3D</code></a></li><li><a href=#AvgPool3DGrad>TensorFlow <code>AvgPool3DGrad</code></a></li><li><a href=#AvgPoolGrad>TensorFlow <code>AvgPoolGrad</code></a></li><li><a href=#Barrier>TensorFlow <code>Barrier</code></a></li><li><a href=#BarrierClose>TensorFlow <code>BarrierClose</code></a></li><li><a href=#BarrierIncompleteSize>TensorFlow <code>BarrierIncompleteSize</code></a></li><li><a href=#BarrierInsertMany>TensorFlow <code>BarrierInsertMany</code></a></li><li><a href=#BarrierReadySize>TensorFlow <code>BarrierReadySize</code></a></li><li><a href=#BarrierTakeMany>TensorFlow <code>BarrierTakeMany</code></a></li><li><a href=#BatchCholesky>TensorFlow <code>BatchCholesky</code></a></li><li><a href=#BatchCholeskyGrad>TensorFlow <code>BatchCholeskyGrad</code></a></li><li><a href=#BatchFFT>TensorFlow <code>BatchFFT</code></a></li><li><a href=#BatchFFT2D>TensorFlow <code>BatchFFT2D</code></a></li><li><a href=#BatchFFT3D>TensorFlow <code>BatchFFT3D</code></a></li><li><a href=#BatchIFFT>TensorFlow <code>BatchIFFT</code></a></li><li><a href=#BatchIFFT2D>TensorFlow <code>BatchIFFT2D</code></a></li><li><a href=#BatchIFFT3D>TensorFlow <code>BatchIFFT3D</code></a></li><li><a href=#BatchMatMul>TensorFlow <code>BatchMatMul</code></a></li><li><a href=#BatchMatrixBandPart>TensorFlow <code>BatchMatrixBandPart</code></a></li><li><a href=#BatchMatrixDeterminant>TensorFlow <code>BatchMatrixDeterminant</code></a></li><li><a href=#BatchMatrixDiag>TensorFlow <code>BatchMatrixDiag</code></a></li><li><a href=#BatchMatrixDiagPart>TensorFlow <code>BatchMatrixDiagPart</code></a></li><li><a href=#BatchMatrixInverse>TensorFlow <code>BatchMatrixInverse</code></a></li><li><a href=#BatchMatrixSetDiag>TensorFlow <code>BatchMatrixSetDiag</code></a></li><li><a href=#BatchMatrixSolve>TensorFlow <code>BatchMatrixSolve</code></a></li><li><a href=#BatchMatrixSolveLs>TensorFlow <code>BatchMatrixSolveLs</code></a></li><li><a href=#BatchMatrixTriangularSolve>TensorFlow <code>BatchMatrixTriangularSolve</code></a></li><li><a href=#BatchNormWithGlobalNormalization>TensorFlow <code>BatchNormWithGlobalNormalization</code></a></li><li><a href=#BatchNormWithGlobalNormalizationGrad>TensorFlow <code>BatchNormWithGlobalNormalizationGrad</code></a></li><li><a href=#BatchSelfAdjointEig>TensorFlow <code>BatchSelfAdjointEig</code></a></li><li><a href=#BatchSelfAdjointEigV2>TensorFlow <code>BatchSelfAdjointEigV2</code></a></li><li><a href=#BatchSvd>TensorFlow <code>BatchSvd</code></a></li><li><a href=#BatchToSpace>TensorFlow <code>BatchToSpace</code></a></li><li><a href=#BiasAdd>TensorFlow <code>BiasAdd</code></a></li><li><a href=#BiasAddGrad>TensorFlow <code>BiasAddGrad</code></a></li><li><a href=#BiasAddV1>TensorFlow <code>BiasAddV1</code></a></li><li><a href=#Bitcast>TensorFlow <code>Bitcast</code></a></li><li><a href=#BroadcastGradientArgs>TensorFlow <code>BroadcastGradientArgs</code></a></li><li><a href=#CTCBeamSearchDecoder>TensorFlow <code>CTCBeamSearchDecoder</code></a></li><li><a href=#CTCGreedyDecoder>TensorFlow <code>CTCGreedyDecoder</code></a></li><li><a href=#CTCLoss>TensorFlow <code>CTCLoss</code></a></li><li><a href=#Cast>TensorFlow <code>Cast</code></a></li><li><a href=#Ceil>TensorFlow <code>Ceil</code></a></li><li><a href=#CheckNumerics>TensorFlow <code>CheckNumerics</code></a></li><li><a href=#Cholesky>TensorFlow <code>Cholesky</code></a></li><li><a href=#CholeskyGrad>TensorFlow <code>CholeskyGrad</code></a></li><li><a href=#Complex>TensorFlow <code>Complex</code></a></li><li><a href=#ComplexAbs>TensorFlow <code>ComplexAbs</code></a></li><li><a href=#ComputeAccidentalHits>TensorFlow <code>ComputeAccidentalHits</code></a></li><li><a href=#Concat>TensorFlow <code>Concat</code></a></li><li><a href=#ConcatOffset>TensorFlow <code>ConcatOffset</code></a></li><li><a href=#Conj>TensorFlow <code>Conj</code></a></li><li><a href=#Const>TensorFlow <code>Const</code></a></li><li><a href=#ControlTrigger>TensorFlow <code>ControlTrigger</code></a></li><li><a href=#Conv2D>TensorFlow <code>Conv2D</code></a></li><li><a href=#Conv2DBackpropFilter>TensorFlow <code>Conv2DBackpropFilter</code></a></li><li><a href=#Conv2DBackpropInput>TensorFlow <code>Conv2DBackpropInput</code></a></li><li><a href=#Conv3D>TensorFlow <code>Conv3D</code></a></li><li><a href=#Conv3DBackpropFilter>TensorFlow <code>Conv3DBackpropFilter</code></a></li><li><a href=#Conv3DBackpropFilterV2>TensorFlow <code>Conv3DBackpropFilterV2</code></a></li><li><a href=#Conv3DBackpropInput>TensorFlow <code>Conv3DBackpropInput</code></a></li><li><a href=#Conv3DBackpropInputV2>TensorFlow <code>Conv3DBackpropInputV2</code></a></li><li><a href=#Copy>TensorFlow <code>Copy</code></a></li><li><a href=#CopyHost>TensorFlow <code>CopyHost</code></a></li><li><a href=#Cos>TensorFlow <code>Cos</code></a></li><li><a href=#CountUpTo>TensorFlow <code>CountUpTo</code></a></li><li><a href=#CropAndResize>TensorFlow <code>CropAndResize</code></a></li><li><a href=#CropAndResizeGradBoxes>TensorFlow <code>CropAndResizeGradBoxes</code></a></li><li><a href=#CropAndResizeGradImage>TensorFlow <code>CropAndResizeGradImage</code></a></li><li><a href=#Cross>TensorFlow <code>Cross</code></a></li><li><a href=#Cumprod>TensorFlow <code>Cumprod</code></a></li><li><a href=#Cumsum>TensorFlow <code>Cumsum</code></a></li><li><a href=#DebugIdentity>TensorFlow <code>DebugIdentity</code></a></li><li><a href=#DebugNanCount>TensorFlow <code>DebugNanCount</code></a></li><li><a href=#DecodeCSV>TensorFlow <code>DecodeCSV</code></a></li><li><a href=#DecodeGif>TensorFlow <code>DecodeGif</code></a></li><li><a href=#DecodeJSONExample>TensorFlow <code>DecodeJSONExample</code></a></li><li><a href=#DecodeJpeg>TensorFlow <code>DecodeJpeg</code></a></li><li><a href=#DecodePng>TensorFlow <code>DecodePng</code></a></li><li><a href=#DecodeRaw>TensorFlow <code>DecodeRaw</code></a></li><li><a href=#DeleteSessionTensor>TensorFlow <code>DeleteSessionTensor</code></a></li><li><a href=#DepthToSpace>TensorFlow <code>DepthToSpace</code></a></li><li><a href=#DepthwiseConv2dNative>TensorFlow <code>DepthwiseConv2dNative</code></a></li><li><a href=#DepthwiseConv2dNativeBackpropFilter>TensorFlow <code>DepthwiseConv2dNativeBackpropFilter</code></a></li><li><a href=#DepthwiseConv2dNativeBackpropInput>TensorFlow <code>DepthwiseConv2dNativeBackpropInput</code></a></li><li><a href=#DeserializeManySparse>TensorFlow <code>DeserializeManySparse</code></a></li><li><a href=#DestroyTemporaryVariable>TensorFlow <code>DestroyTemporaryVariable</code></a></li><li><a href=#Diag>TensorFlow <code>Diag</code></a></li><li><a href=#DiagPart>TensorFlow <code>DiagPart</code></a></li><li><a href=#Digamma>TensorFlow <code>Digamma</code></a></li><li><a href=#Dilation2D>TensorFlow <code>Dilation2D</code></a></li><li><a href=#Dilation2DBackpropFilter>TensorFlow <code>Dilation2DBackpropFilter</code></a></li><li><a href=#Dilation2DBackpropInput>TensorFlow <code>Dilation2DBackpropInput</code></a></li><li><a href=#Div>TensorFlow <code>Div</code></a></li><li><a href=#DrawBoundingBoxes>TensorFlow <code>DrawBoundingBoxes</code></a></li><li><a href=#DynamicPartition>TensorFlow <code>DynamicPartition</code></a></li><li><a href=#DynamicStitch>TensorFlow <code>DynamicStitch</code></a></li><li><a href=#EditDistance>TensorFlow <code>EditDistance</code></a></li><li><a href=#Elu>TensorFlow <code>Elu</code></a></li><li><a href=#EluGrad>TensorFlow <code>EluGrad</code></a></li><li><a href=#EncodeJpeg>TensorFlow <code>EncodeJpeg</code></a></li><li><a href=#EncodePng>TensorFlow <code>EncodePng</code></a></li><li><a href=#Enter>TensorFlow <code>Enter</code></a></li><li><a href=#Equal>TensorFlow <code>Equal</code></a></li><li><a href=#Erf>TensorFlow <code>Erf</code></a></li><li><a href=#Erfc>TensorFlow <code>Erfc</code></a></li><li><a href=#Exit>TensorFlow <code>Exit</code></a></li><li><a href=#Exp>TensorFlow <code>Exp</code></a></li><li><a href=#ExpandDims>TensorFlow <code>ExpandDims</code></a></li><li><a href=#ExtractGlimpse>TensorFlow <code>ExtractGlimpse</code></a></li><li><a href=#ExtractImagePatches>TensorFlow <code>ExtractImagePatches</code></a></li><li><a href=#FFT>TensorFlow <code>FFT</code></a></li><li><a href=#FFT2D>TensorFlow <code>FFT2D</code></a></li><li><a href=#FFT3D>TensorFlow <code>FFT3D</code></a></li><li><a href=#FIFOQueue>TensorFlow <code>FIFOQueue</code></a></li><li><a href=#Fill>TensorFlow <code>Fill</code></a></li><li><a href=#FixedLengthRecordReader>TensorFlow <code>FixedLengthRecordReader</code></a></li><li><a href=#FixedUnigramCandidateSampler>TensorFlow <code>FixedUnigramCandidateSampler</code></a></li><li><a href=#Floor>TensorFlow <code>Floor</code></a></li><li><a href=#Gather>TensorFlow <code>Gather</code></a></li><li><a href=#GatherNd>TensorFlow <code>GatherNd</code></a></li><li><a href=#GetSessionHandle>TensorFlow <code>GetSessionHandle</code></a></li><li><a href=#GetSessionTensor>TensorFlow <code>GetSessionTensor</code></a></li><li><a href=#Greater>TensorFlow <code>Greater</code></a></li><li><a href=#GreaterEqual>TensorFlow <code>GreaterEqual</code></a></li><li><a href=#HSVToRGB>TensorFlow <code>HSVToRGB</code></a></li><li><a href=#HashTable>TensorFlow <code>HashTable</code></a></li><li><a href=#HistogramSummary>TensorFlow <code>HistogramSummary</code></a></li><li><a href=#IFFT>TensorFlow <code>IFFT</code></a></li><li><a href=#IFFT2D>TensorFlow <code>IFFT2D</code></a></li><li><a href=#IFFT3D>TensorFlow <code>IFFT3D</code></a></li><li><a href=#Identity>TensorFlow <code>Identity</code></a></li><li><a href=#IdentityReader>TensorFlow <code>IdentityReader</code></a></li><li><a href=#Igamma>TensorFlow <code>Igamma</code></a></li><li><a href=#Igammac>TensorFlow <code>Igammac</code></a></li><li><a href=#Imag>TensorFlow <code>Imag</code></a></li><li><a href=#ImageSummary>TensorFlow <code>ImageSummary</code></a></li><li><a href=#ImmutableConst>TensorFlow <code>ImmutableConst</code></a></li><li><a href=#InTopK>TensorFlow <code>InTopK</code></a></li><li><a href=#InitializeTable>TensorFlow <code>InitializeTable</code></a></li><li><a href=#InitializeTableFromTextFile>TensorFlow <code>InitializeTableFromTextFile</code></a></li><li><a href=#Inv>TensorFlow <code>Inv</code></a></li><li><a href=#InvertPermutation>TensorFlow <code>InvertPermutation</code></a></li><li><a href=#IsFinite>TensorFlow <code>IsFinite</code></a></li><li><a href=#IsInf>TensorFlow <code>IsInf</code></a></li><li><a href=#IsNan>TensorFlow <code>IsNan</code></a></li><li><a href=#IsVariableInitialized>TensorFlow <code>IsVariableInitialized</code></a></li><li><a href=#L2Loss>TensorFlow <code>L2Loss</code></a></li><li><a href=#LRN>TensorFlow <code>LRN</code></a></li><li><a href=#LRNGrad>TensorFlow <code>LRNGrad</code></a></li><li><a href=#LearnedUnigramCandidateSampler>TensorFlow <code>LearnedUnigramCandidateSampler</code></a></li><li><a href=#Less>TensorFlow <code>Less</code></a></li><li><a href=#LessEqual>TensorFlow <code>LessEqual</code></a></li><li><a href=#Lgamma>TensorFlow <code>Lgamma</code></a></li><li><a href=#LinSpace>TensorFlow <code>LinSpace</code></a></li><li><a href=#ListDiff>TensorFlow <code>ListDiff</code></a></li><li><a href=#Log>TensorFlow <code>Log</code></a></li><li><a href=#LogSoftmax>TensorFlow <code>LogSoftmax</code></a></li><li><a href=#LogUniformCandidateSampler>TensorFlow <code>LogUniformCandidateSampler</code></a></li><li><a href=#LogicalAnd>TensorFlow <code>LogicalAnd</code></a></li><li><a href=#LogicalNot>TensorFlow <code>LogicalNot</code></a></li><li><a href=#LogicalOr>TensorFlow <code>LogicalOr</code></a></li><li><a href=#LookupTableExport>TensorFlow <code>LookupTableExport</code></a></li><li><a href=#LookupTableFind>TensorFlow <code>LookupTableFind</code></a></li><li><a href=#LookupTableInsert>TensorFlow <code>LookupTableInsert</code></a></li><li><a href=#LookupTableSize>TensorFlow <code>LookupTableSize</code></a></li><li><a href=#LoopCond>TensorFlow <code>LoopCond</code></a></li><li><a href=#MatMul>TensorFlow <code>MatMul</code></a></li><li><a href=#MatchingFiles>TensorFlow <code>MatchingFiles</code></a></li><li><a href=#MatrixDeterminant>TensorFlow <code>MatrixDeterminant</code></a></li><li><a href=#MatrixInverse>TensorFlow <code>MatrixInverse</code></a></li><li><a href=#MatrixSolve>TensorFlow <code>MatrixSolve</code></a></li><li><a href=#MatrixSolveLs>TensorFlow <code>MatrixSolveLs</code></a></li><li><a href=#MatrixTriangularSolve>TensorFlow <code>MatrixTriangularSolve</code></a></li><li><a href=#Max>TensorFlow <code>Max</code></a></li><li><a href=#MaxPool>TensorFlow <code>MaxPool</code></a></li><li><a href=#MaxPool3D>TensorFlow <code>MaxPool3D</code></a></li><li><a href=#MaxPool3DGrad>TensorFlow <code>MaxPool3DGrad</code></a></li><li><a href=#MaxPoolGrad>TensorFlow <code>MaxPoolGrad</code></a></li><li><a href=#MaxPoolGradWithArgmax>TensorFlow <code>MaxPoolGradWithArgmax</code></a></li><li><a href=#MaxPoolWithArgmax>TensorFlow <code>MaxPoolWithArgmax</code></a></li><li><a href=#Maximum>TensorFlow <code>Maximum</code></a></li><li><a href=#Mean>TensorFlow <code>Mean</code></a></li><li><a href=#Merge>TensorFlow <code>Merge</code></a></li><li><a href=#MergeSummary>TensorFlow <code>MergeSummary</code></a></li><li><a href=#Min>TensorFlow <code>Min</code></a></li><li><a href=#Minimum>TensorFlow <code>Minimum</code></a></li><li><a href=#MirrorPad>TensorFlow <code>MirrorPad</code></a></li><li><a href=#MirrorPadGrad>TensorFlow <code>MirrorPadGrad</code></a></li><li><a href=#Mod>TensorFlow <code>Mod</code></a></li><li><a href=#Mul>TensorFlow <code>Mul</code></a></li><li><a href=#Multinomial>TensorFlow <code>Multinomial</code></a></li><li><a href=#MutableHashTable>TensorFlow <code>MutableHashTable</code></a></li><li><a href=#MutableHashTableOfTensors>TensorFlow <code>MutableHashTableOfTensors</code></a></li><li><a href=#Neg>TensorFlow <code>Neg</code></a></li><li><a href=#NextIteration>TensorFlow <code>NextIteration</code></a></li><li><a href=#NoOp>TensorFlow <code>NoOp</code></a></li><li><a href=#NonMaxSuppression>TensorFlow <code>NonMaxSuppression</code></a></li><li><a href=#NotEqual>TensorFlow <code>NotEqual</code></a></li><li><a href=#OneHot>TensorFlow <code>OneHot</code></a></li><li><a href=#Pack>TensorFlow <code>Pack</code></a></li><li><a href=#Pad>TensorFlow <code>Pad</code></a></li><li><a href=#PaddingFIFOQueue>TensorFlow <code>PaddingFIFOQueue</code></a></li><li><a href=#ParameterizedTruncatedNormal>TensorFlow <code>ParameterizedTruncatedNormal</code></a></li><li><a href=#ParseExample>TensorFlow <code>ParseExample</code></a></li><li><a href=#ParseSingleSequenceExample>TensorFlow <code>ParseSingleSequenceExample</code></a></li><li><a href=#Placeholder>TensorFlow <code>Placeholder</code></a></li><li><a href=#PlaceholderWithDefault>TensorFlow <code>PlaceholderWithDefault</code></a></li><li><a href=#Polygamma>TensorFlow <code>Polygamma</code></a></li><li><a href=#Pow>TensorFlow <code>Pow</code></a></li><li><a href=#Print>TensorFlow <code>Print</code></a></li><li><a href=#PriorityQueue>TensorFlow <code>PriorityQueue</code></a></li><li><a href=#Prod>TensorFlow <code>Prod</code></a></li><li><a href=#PyFunc>TensorFlow <code>PyFunc</code></a></li><li><a href=#PyFuncStateless>TensorFlow <code>PyFuncStateless</code></a></li><li><a href=#QuantizeAndDequantize>TensorFlow <code>QuantizeAndDequantize</code></a></li><li><a href=#QueueClose>TensorFlow <code>QueueClose</code></a></li><li><a href=#QueueDequeue>TensorFlow <code>QueueDequeue</code></a></li><li><a href=#QueueDequeueMany>TensorFlow <code>QueueDequeueMany</code></a></li><li><a href=#QueueDequeueUpTo>TensorFlow <code>QueueDequeueUpTo</code></a></li><li><a href=#QueueEnqueue>TensorFlow <code>QueueEnqueue</code></a></li><li><a href=#QueueEnqueueMany>TensorFlow <code>QueueEnqueueMany</code></a></li><li><a href=#QueueSize>TensorFlow <code>QueueSize</code></a></li><li><a href=#RGBToHSV>TensorFlow <code>RGBToHSV</code></a></li><li><a href=#RandomCrop>TensorFlow <code>RandomCrop</code></a></li><li><a href=#RandomGamma>TensorFlow <code>RandomGamma</code></a></li><li><a href=#RandomShuffle>TensorFlow <code>RandomShuffle</code></a></li><li><a href=#RandomShuffleQueue>TensorFlow <code>RandomShuffleQueue</code></a></li><li><a href=#RandomStandardNormal>TensorFlow <code>RandomStandardNormal</code></a></li><li><a href=#RandomUniform>TensorFlow <code>RandomUniform</code></a></li><li><a href=#RandomUniformInt>TensorFlow <code>RandomUniformInt</code></a></li><li><a href=#Range>TensorFlow <code>Range</code></a></li><li><a href=#Rank>TensorFlow <code>Rank</code></a></li><li><a href=#ReadFile>TensorFlow <code>ReadFile</code></a></li><li><a href=#ReaderNumRecordsProduced>TensorFlow <code>ReaderNumRecordsProduced</code></a></li><li><a href=#ReaderNumWorkUnitsCompleted>TensorFlow <code>ReaderNumWorkUnitsCompleted</code></a></li><li><a href=#ReaderRead>TensorFlow <code>ReaderRead</code></a></li><li><a href=#ReaderReadUpTo>TensorFlow <code>ReaderReadUpTo</code></a></li><li><a href=#ReaderReset>TensorFlow <code>ReaderReset</code></a></li><li><a href=#ReaderRestoreState>TensorFlow <code>ReaderRestoreState</code></a></li><li><a href=#ReaderSerializeState>TensorFlow <code>ReaderSerializeState</code></a></li><li><a href=#Real>TensorFlow <code>Real</code></a></li><li><a href=#ReduceJoin>TensorFlow <code>ReduceJoin</code></a></li><li><a href=#RefEnter>TensorFlow <code>RefEnter</code></a></li><li><a href=#RefExit>TensorFlow <code>RefExit</code></a></li><li><a href=#RefIdentity>TensorFlow <code>RefIdentity</code></a></li><li><a href=#RefMerge>TensorFlow <code>RefMerge</code></a></li><li><a href=#RefNextIteration>TensorFlow <code>RefNextIteration</code></a></li><li><a href=#RefSelect>TensorFlow <code>RefSelect</code></a></li><li><a href=#RefSwitch>TensorFlow <code>RefSwitch</code></a></li><li><a href=#Relu>TensorFlow <code>Relu</code></a></li><li><a href=#Relu6>TensorFlow <code>Relu6</code></a></li><li><a href=#Relu6Grad>TensorFlow <code>Relu6Grad</code></a></li><li><a href=#ReluGrad>TensorFlow <code>ReluGrad</code></a></li><li><a href=#Reshape>TensorFlow <code>Reshape</code></a></li><li><a href=#ResizeArea>TensorFlow <code>ResizeArea</code></a></li><li><a href=#ResizeBicubic>TensorFlow <code>ResizeBicubic</code></a></li><li><a href=#ResizeBilinear>TensorFlow <code>ResizeBilinear</code></a></li><li><a href=#ResizeBilinearGrad>TensorFlow <code>ResizeBilinearGrad</code></a></li><li><a href=#ResizeNearestNeighbor>TensorFlow <code>ResizeNearestNeighbor</code></a></li><li><a href=#ResizeNearestNeighborGrad>TensorFlow <code>ResizeNearestNeighborGrad</code></a></li><li><a href=#Restore>TensorFlow <code>Restore</code></a></li><li><a href=#RestoreSlice>TensorFlow <code>RestoreSlice</code></a></li><li><a href=#Reverse>TensorFlow <code>Reverse</code></a></li><li><a href=#ReverseSequence>TensorFlow <code>ReverseSequence</code></a></li><li><a href=#Rsqrt>TensorFlow <code>Rsqrt</code></a></li><li><a href=#SampleDistortedBoundingBox>TensorFlow <code>SampleDistortedBoundingBox</code></a></li><li><a href=#Save>TensorFlow <code>Save</code></a></li><li><a href=#SaveSlices>TensorFlow <code>SaveSlices</code></a></li><li><a href=#ScalarSummary>TensorFlow <code>ScalarSummary</code></a></li><li><a href=#ScatterAdd>TensorFlow <code>ScatterAdd</code></a></li><li><a href=#ScatterSub>TensorFlow <code>ScatterSub</code></a></li><li><a href=#ScatterUpdate>TensorFlow <code>ScatterUpdate</code></a></li><li><a href=#SegmentMax>TensorFlow <code>SegmentMax</code></a></li><li><a href=#SegmentMean>TensorFlow <code>SegmentMean</code></a></li><li><a href=#SegmentMin>TensorFlow <code>SegmentMin</code></a></li><li><a href=#SegmentProd>TensorFlow <code>SegmentProd</code></a></li><li><a href=#SegmentSum>TensorFlow <code>SegmentSum</code></a></li><li><a href=#Select>TensorFlow <code>Select</code></a></li><li><a href=#SelfAdjointEig>TensorFlow <code>SelfAdjointEig</code></a></li><li><a href=#SelfAdjointEigV2>TensorFlow <code>SelfAdjointEigV2</code></a></li><li><a href=#SerializeManySparse>TensorFlow <code>SerializeManySparse</code></a></li><li><a href=#SerializeSparse>TensorFlow <code>SerializeSparse</code></a></li><li><a href=#Shape>TensorFlow <code>Shape</code></a></li><li><a href=#ShapeN>TensorFlow <code>ShapeN</code></a></li><li><a href=#ShardedFilename>TensorFlow <code>ShardedFilename</code></a></li><li><a href=#ShardedFilespec>TensorFlow <code>ShardedFilespec</code></a></li><li><a href=#Sigmoid>TensorFlow <code>Sigmoid</code></a></li><li><a href=#SigmoidGrad>TensorFlow <code>SigmoidGrad</code></a></li><li><a href=#Sign>TensorFlow <code>Sign</code></a></li><li><a href=#Sin>TensorFlow <code>Sin</code></a></li><li><a href=#Size>TensorFlow <code>Size</code></a></li><li><a href=#Slice>TensorFlow <code>Slice</code></a></li><li><a href=#Softmax>TensorFlow <code>Softmax</code></a></li><li><a href=#SoftmaxCrossEntropyWithLogits>TensorFlow <code>SoftmaxCrossEntropyWithLogits</code></a></li><li><a href=#Softplus>TensorFlow <code>Softplus</code></a></li><li><a href=#SoftplusGrad>TensorFlow <code>SoftplusGrad</code></a></li><li><a href=#Softsign>TensorFlow <code>Softsign</code></a></li><li><a href=#SoftsignGrad>TensorFlow <code>SoftsignGrad</code></a></li><li><a href=#SpaceToBatch>TensorFlow <code>SpaceToBatch</code></a></li><li><a href=#SpaceToDepth>TensorFlow <code>SpaceToDepth</code></a></li><li><a href=#SparseAdd>TensorFlow <code>SparseAdd</code></a></li><li><a href=#SparseAddGrad>TensorFlow <code>SparseAddGrad</code></a></li><li><a href=#SparseApplyAdadelta>TensorFlow <code>SparseApplyAdadelta</code></a></li><li><a href=#SparseApplyAdagrad>TensorFlow <code>SparseApplyAdagrad</code></a></li><li><a href=#SparseApplyFtrl>TensorFlow <code>SparseApplyFtrl</code></a></li><li><a href=#SparseApplyMomentum>TensorFlow <code>SparseApplyMomentum</code></a></li><li><a href=#SparseApplyProximalAdagrad>TensorFlow <code>SparseApplyProximalAdagrad</code></a></li><li><a href=#SparseApplyProximalGradientDescent>TensorFlow <code>SparseApplyProximalGradientDescent</code></a></li><li><a href=#SparseApplyRMSProp>TensorFlow <code>SparseApplyRMSProp</code></a></li><li><a href=#SparseConcat>TensorFlow <code>SparseConcat</code></a></li><li><a href=#SparseDenseCwiseAdd>TensorFlow <code>SparseDenseCwiseAdd</code></a></li><li><a href=#SparseDenseCwiseDiv>TensorFlow <code>SparseDenseCwiseDiv</code></a></li><li><a href=#SparseDenseCwiseMul>TensorFlow <code>SparseDenseCwiseMul</code></a></li><li><a href=#SparseMatMul>TensorFlow <code>SparseMatMul</code></a></li><li><a href=#SparseReduceSum>TensorFlow <code>SparseReduceSum</code></a></li><li><a href=#SparseReorder>TensorFlow <code>SparseReorder</code></a></li><li><a href=#SparseReshape>TensorFlow <code>SparseReshape</code></a></li><li><a href=#SparseSegmentMean>TensorFlow <code>SparseSegmentMean</code></a></li><li><a href=#SparseSegmentMeanGrad>TensorFlow <code>SparseSegmentMeanGrad</code></a></li><li><a href=#SparseSegmentSqrtN>TensorFlow <code>SparseSegmentSqrtN</code></a></li><li><a href=#SparseSegmentSqrtNGrad>TensorFlow <code>SparseSegmentSqrtNGrad</code></a></li><li><a href=#SparseSegmentSum>TensorFlow <code>SparseSegmentSum</code></a></li><li><a href=#SparseSoftmax>TensorFlow <code>SparseSoftmax</code></a></li><li><a href=#SparseSoftmaxCrossEntropyWithLogits>TensorFlow <code>SparseSoftmaxCrossEntropyWithLogits</code></a></li><li><a href=#SparseSparseMaximum>TensorFlow <code>SparseSparseMaximum</code></a></li><li><a href=#SparseSparseMinimum>TensorFlow <code>SparseSparseMinimum</code></a></li><li><a href=#SparseSplit>TensorFlow <code>SparseSplit</code></a></li><li><a href=#SparseTensorDenseAdd>TensorFlow <code>SparseTensorDenseAdd</code></a></li><li><a href=#SparseTensorDenseMatMul>TensorFlow <code>SparseTensorDenseMatMul</code></a></li><li><a href=#SparseToDense>TensorFlow <code>SparseToDense</code></a></li><li><a href=#Split>TensorFlow <code>Split</code></a></li><li><a href=#Sqrt>TensorFlow <code>Sqrt</code></a></li><li><a href=#Square>TensorFlow <code>Square</code></a></li><li><a href=#SquaredDifference>TensorFlow <code>SquaredDifference</code></a></li><li><a href=#Squeeze>TensorFlow <code>Squeeze</code></a></li><li><a href=#Stack>TensorFlow <code>Stack</code></a></li><li><a href=#StackClose>TensorFlow <code>StackClose</code></a></li><li><a href=#StackPop>TensorFlow <code>StackPop</code></a></li><li><a href=#StackPush>TensorFlow <code>StackPush</code></a></li><li><a href=#StopGradient>TensorFlow <code>StopGradient</code></a></li><li><a href=#StridedSlice>TensorFlow <code>StridedSlice</code></a></li><li><a href=#StridedSliceGrad>TensorFlow <code>StridedSliceGrad</code></a></li><li><a href=#StringJoin>TensorFlow <code>StringJoin</code></a></li><li><a href=#StringToHashBucket>TensorFlow <code>StringToHashBucket</code></a></li><li><a href=#StringToHashBucketFast>TensorFlow <code>StringToHashBucketFast</code></a></li><li><a href=#StringToHashBucketStrong>TensorFlow <code>StringToHashBucketStrong</code></a></li><li><a href=#StringToNumber>TensorFlow <code>StringToNumber</code></a></li><li><a href=#Sub>TensorFlow <code>Sub</code></a></li><li><a href=#Sum>TensorFlow <code>Sum</code></a></li><li><a href=#Svd>TensorFlow <code>Svd</code></a></li><li><a href=#Switch>TensorFlow <code>Switch</code></a></li><li><a href=#SymbolicGradient>TensorFlow <code>SymbolicGradient</code></a></li><li><a href=#TFRecordReader>TensorFlow <code>TFRecordReader</code></a></li><li><a href=#Tan>TensorFlow <code>Tan</code></a></li><li><a href=#Tanh>TensorFlow <code>Tanh</code></a></li><li><a href=#TanhGrad>TensorFlow <code>TanhGrad</code></a></li><li><a href=#TemporaryVariable>TensorFlow <code>TemporaryVariable</code></a></li><li><a href=#TensorArray>TensorFlow <code>TensorArray</code></a></li><li><a href=#TensorArrayClose>TensorFlow <code>TensorArrayClose</code></a></li><li><a href=#TensorArrayConcat>TensorFlow <code>TensorArrayConcat</code></a></li><li><a href=#TensorArrayGrad>TensorFlow <code>TensorArrayGrad</code></a></li><li><a href=#TensorArrayPack>TensorFlow <code>TensorArrayPack</code></a></li><li><a href=#TensorArrayRead>TensorFlow <code>TensorArrayRead</code></a></li><li><a href=#TensorArraySize>TensorFlow <code>TensorArraySize</code></a></li><li><a href=#TensorArraySplit>TensorFlow <code>TensorArraySplit</code></a></li><li><a href=#TensorArrayUnpack>TensorFlow <code>TensorArrayUnpack</code></a></li><li><a href=#TensorArrayWrite>TensorFlow <code>TensorArrayWrite</code></a></li><li><a href=#TensorSummary>TensorFlow <code>TensorSummary</code></a></li><li><a href=#TextLineReader>TensorFlow <code>TextLineReader</code></a></li><li><a href=#ThreadUnsafeUnigramCandidateSampler>TensorFlow <code>ThreadUnsafeUnigramCandidateSampler</code></a></li><li><a href=#ThrowAway1>TensorFlow <code>ThrowAway1</code></a></li><li><a href=#ThrowAway2>TensorFlow <code>ThrowAway2</code></a></li><li><a href=#ThrowAway3>TensorFlow <code>ThrowAway3</code></a></li><li><a href=#ThrowAway4>TensorFlow <code>ThrowAway4</code></a></li><li><a href=#ThrowAway5>TensorFlow <code>ThrowAway5</code></a></li><li><a href=#Tile>TensorFlow <code>Tile</code></a></li><li><a href=#TileGrad>TensorFlow <code>TileGrad</code></a></li><li><a href=#TopK>TensorFlow <code>TopK</code></a></li><li><a href=#TopKV2>TensorFlow <code>TopKV2</code></a></li><li><a href=#Transpose>TensorFlow <code>Transpose</code></a></li><li><a href=#TruncatedNormal>TensorFlow <code>TruncatedNormal</code></a></li><li><a href=#UniformCandidateSampler>TensorFlow <code>UniformCandidateSampler</code></a></li><li><a href=#Unique>TensorFlow <code>Unique</code></a></li><li><a href=#UniqueWithCounts>TensorFlow <code>UniqueWithCounts</code></a></li><li><a href=#Unpack>TensorFlow <code>Unpack</code></a></li><li><a href=#UnsortedSegmentSum>TensorFlow <code>UnsortedSegmentSum</code></a></li><li><a href=#Variable>TensorFlow <code>Variable</code></a></li><li><a href=#Where>TensorFlow <code>Where</code></a></li><li><a href=#WholeFileReader>TensorFlow <code>WholeFileReader</code></a></li><li><a href=#ZerosLike>TensorFlow <code>ZerosLike</code></a></li><li><a href=#Zeta>TensorFlow <code>Zeta</code></a></li><li><a href=#_Arg>TensorFlow <code>_Arg</code></a></li><li><a href=#_ArrayToList>TensorFlow <code>_ArrayToList</code></a></li><li><a href=#_HostCast>TensorFlow <code>_HostCast</code></a></li><li><a href=#_HostRecv>TensorFlow <code>_HostRecv</code></a></li><li><a href=#_HostSend>TensorFlow <code>_HostSend</code></a></li><li><a href=#_ListToArray>TensorFlow <code>_ListToArray</code></a></li><li><a href=#_Recv>TensorFlow <code>_Recv</code></a></li><li><a href=#_Retval>TensorFlow <code>_Retval</code></a></li><li><a href=#_Send>TensorFlow <code>_Send</code></a></li></ul><a name="Abort"></a><h2>TensorFlow <code>Abort</code> Operation</h2><h3>Description</h3><p>Returns nothing but an exception.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>error_msg</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>A string which is the message associated with the exception.</p>
</td></tr></table><a name="Abs"></a><h2>TensorFlow <code>Abs</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>x</code>, this operation returns a tensor containing the absolute
value of each element in <code>x</code>. For example, if x is an input element and y is
an output element, this operation computes \(y = |x|\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Acos"></a><h2>TensorFlow <code>Acos</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Add"></a><h2>TensorFlow <code>Add</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Add</code> supports broadcasting. <code>AddN</code> does not. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_STRING</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="AddN"></a><h2>TensorFlow <code>AddN</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>Must all be the same size and shape.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sum</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="AdjustContrast"></a><h2>TensorFlow <code>AdjustContrast</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>contrast_factor</code></td><td>DT_FLOAT</td><td></td><td></td></tr><tr><td><code>min_value</code></td><td>DT_FLOAT</td><td></td><td></td></tr><tr><td><code>max_value</code></td><td>DT_FLOAT</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_FLOAT</td><td></td><td></td></tr></table><a name="AdjustContrastv2"></a><h2>TensorFlow <code>AdjustContrastv2</code> Operation</h2><h3>Description</h3><p><code>images</code> is a tensor of at least 3 dimensions.  The last 3 dimensions are
interpreted as <code>[height, width, channels]</code>.  The other dimensions only
represent a collection of images, such as <code>[batch, height, width, channels].</code></p>

<p>Contrast is adjusted independently for each channel of each image.</p>

<p>For each channel, the Op first computes the mean of the image pixels in the
channel and then adjusts each component of each pixel to
<code>(x - mean) * contrast_factor + mean</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td>DT_FLOAT</td><td></td><td><p>Images to adjust.  At least 3-D.</p>
</td></tr><tr><td><code>contrast_factor</code></td><td>DT_FLOAT</td><td></td><td><p>A float multiplier for adjusting contrast.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_FLOAT</td><td></td><td><p>The contrast-adjusted image or images.</p>
</td></tr></table><a name="All"></a><h2>TensorFlow <code>All</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_BOOL</td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_BOOL</td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="AllCandidateSampler"></a><h2>TensorFlow <code>AllCandidateSampler</code> Operation</h2><h3>Description</h3><p>See explanations of candidate sampling and the data formats at
go/candidate-sampling.</p>

<p>For each batch, this op picks a single set of sampled candidate labels.</p>

<p>The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>num_sampled</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of candidates to produce per batch.</p>
</td></tr><tr><td>unique</td><td>bool</td><td></td><td></td><td><p>If unique is true, we sample with rejection, so that all sampled
candidates in a batch are unique. This requires some approximation to
estimate the post-rejection sampling probabilities.</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>A batch<em>size * num</em>true matrix, in which each row contains the
IDs of the num<em>true target</em>classes in the corresponding original label.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>A vector of length num_sampled, in which each element is
the ID of a sampled candidate.</p>
</td></tr><tr><td><code>true_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A batch<em>size * num</em>true matrix, representing
the number of times each candidate is expected to occur in a batch
of sampled candidates. If unique=true, then this is a probability.</p>
</td></tr><tr><td><code>sampled_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of length num_sampled, for each sampled
candidate representing the number of times the candidate is expected
to occur in a batch of sampled candidates.  If unique=true, then this is a
probability.</p>
</td></tr></table><a name="Any"></a><h2>TensorFlow <code>Any</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_BOOL</td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_BOOL</td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="ApplyAdadelta"></a><h2>TensorFlow <code>ApplyAdadelta</code> Operation</h2><h3>Description</h3><p>accum = rho() * accum + (1 - rho()) * grad.square();
update = (update<em>accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;
update</em>accum = rho() * update_accum + (1 - rho()) * update.square();
var -= update;</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, updating of the var, accum and update_accum tensors will be protected by
a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum_update</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>rho</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Decay factor. Must be a scalar.</p>
</td></tr><tr><td><code>epsilon</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Constant factor. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyAdagrad"></a><h2>TensorFlow <code>ApplyAdagrad</code> Operation</h2><h3>Description</h3><p>accum += grad * grad
var -= lr * grad * (1 / sqrt(accum))</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var and accum tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyAdam"></a><h2>TensorFlow <code>ApplyAdam</code> Operation</h2><h3>Description</h3><p>lr<em>t &lt;- learning</em>rate * sqrt(1 - beta2^t) / (1 - beta1^t)
m<em>t &lt;- beta1 * m</em>{t-1} + (1 - beta1) * g<em>t
v</em>t &lt;- beta2 * v<em>{t-1} + (1 - beta2) * g</em>t * g<em>t
variable &lt;- variable - lr</em>t * m<em>t / (sqrt(v</em>t) + epsilon)</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var, m, and v tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>m</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>beta1_power</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Must be a scalar.</p>
</td></tr><tr><td><code>beta2_power</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Must be a scalar.</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>beta1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Momentum factor. Must be a scalar.</p>
</td></tr><tr><td><code>beta2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Momentum factor. Must be a scalar.</p>
</td></tr><tr><td><code>epsilon</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Ridge term. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyFtrl"></a><h2>TensorFlow <code>ApplyFtrl</code> Operation</h2><h3>Description</h3><p>accum<em>new = accum + grad * grad
linear += grad + (accum</em>new^(-lr<em>power) - accum^(-lr</em>power)) / lr * var
quadratic = 1.0 / (accum<em>new^(lr</em>power) * lr) + 2 * l2
var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
accum = accum_new</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var and accum tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>linear</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>l1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L1 regulariation. Must be a scalar.</p>
</td></tr><tr><td><code>l2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L2 regulariation. Must be a scalar.</p>
</td></tr><tr><td><code>lr_power</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyGradientDescent"></a><h2>TensorFlow <code>ApplyGradientDescent</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, the subtraction will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>alpha</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>delta</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The change.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyMomentum"></a><h2>TensorFlow <code>ApplyMomentum</code> Operation</h2><h3>Description</h3><p>want to use Nesterov momentum.</p>

<p>accum = accum * momentum + grad
var -= lr * accum</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var and accum tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr><tr><td>use_nesterov</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, the tensor passed to compute grad will be
var - lr * momentum * accum, so in the end, the var you get is actually
var - lr * momentum * accum.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>momentum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Momentum. Must be a scalar.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyProximalAdagrad"></a><h2>TensorFlow <code>ApplyProximalAdagrad</code> Operation</h2><h3>Description</h3><p>accum += grad * grad
prox<em>v = var - lr * grad * (1 / sqrt(accum))
var = sign(prox</em>v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, updating of the var and accum tensors will be protected by
a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>l1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L1 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>l2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L2 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyProximalGradientDescent"></a><h2>TensorFlow <code>ApplyProximalGradientDescent</code> Operation</h2><h3>Description</h3><p>prox<em>v = var - alpha * delta
var = sign(prox</em>v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, the subtraction will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>alpha</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>l1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L1 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>l2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L2 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>delta</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The change.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ApplyRMSProp"></a><h2>TensorFlow <code>ApplyRMSProp</code> Operation</h2><h3>Description</h3><p>Note that in dense implement of this algorithm, ms and mom will
update even if the grad is zero, but in this sparse implement, ms
and mom will not update in iterations the grad is zero.</p>

<p>mean<em>square = decay * mean</em>square + (1-decay) * gradient ** 2
Delta = learning<em>rate * gradient / sqrt(mean</em>square + epsilon)</p>

<p>ms &lt;- rho * ms<em>{t-1} + (1-rho) * grad * grad
mom &lt;- momentum * mom</em>{t-1} + lr * grad / sqrt(ms + epsilon)
var &lt;- var - mom</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var, m, and v tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>ms</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>mom</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>rho</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Decay rate. Must be a scalar.</p>
</td></tr><tr><td><code>momentum</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>epsilon</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Ridge term. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="ArgMax"></a><h2>TensorFlow <code>ArgMax</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>dimension</code></td><td>DT_INT32</td><td></td><td><p>int32, 0 &lt;= dimension &lt; rank(input).  Describes which dimension
of the input Tensor to reduce across. For vectors, use dimension = 0.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="ArgMin"></a><h2>TensorFlow <code>ArgMin</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>dimension</code></td><td>DT_INT32</td><td></td><td><p>int32, 0 &lt;= dimension &lt; rank(input).  Describes which dimension
of the input Tensor to reduce across. For vectors, use dimension = 0.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="AsString"></a><h2>TensorFlow <code>AsString</code> Operation</h2><h3>Description</h3><p>types and boolean.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_BOOL</code></li><li><code>DT_INT8</code></li></ul></td><td></td></tr><tr><td>precision</td><td>int</td><td>i: -1
</td><td></td><td><p>The post-decimal precision to use for floating point numbers.
Only used if precision &gt; -1.</p>
</td></tr><tr><td>scientific</td><td>bool</td><td>b: false
</td><td></td><td><p>Use scientific notation for floating point numbers.</p>
</td></tr><tr><td>shortest</td><td>bool</td><td>b: false
</td><td></td><td><p>Use shortest representation (either scientific or standard) for
floating point numbers.</p>
</td></tr><tr><td>width</td><td>int</td><td>i: -1
</td><td></td><td><p>Pad pre-decimal numbers to this width.
Applies to both floating point and integer numbers.
Only used if width &gt; -1.</p>
</td></tr><tr><td>fill</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>The value to pad if width &gt; -1.  If empty, pads with spaces.
Another typical value is &#39;0&#39;.  String cannot be longer than 1 character.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="Asin"></a><h2>TensorFlow <code>Asin</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Assert"></a><h2>TensorFlow <code>Assert</code> Operation</h2><h3>Description</h3><p>If <code>condition</code> evaluates to false, print the list of tensors in <code>data</code>.
<code>summarize</code> determines how many entries of the tensors to print.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>summarize</td><td>int</td><td>i: 3
</td><td></td><td><p>Print this many entries of each tensor.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>condition</code></td><td>DT_BOOL</td><td></td><td><p>The condition to evaluate.</p>
</td></tr><tr><td><code>data</code></td><td><b>type list: </b><code>T</code></td><td></td><td><p>The tensors to print out when condition is false.</p>
</td></tr></table><a name="Assign"></a><h2>TensorFlow <code>Assign</code> Operation</h2><h3>Description</h3><p>This operation outputs &quot;ref&quot; after the assignment is done.
This makes it easier to chain operations that need to use the reset value.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>validate_shape</td><td>bool</td><td>b: true
</td><td></td><td><p>If true, the operation will validate that the shape
of &#39;value&#39; matches the shape of the Tensor being assigned to.  If false,
&#39;ref&#39; will take on the shape of &#39;value&#39;.</p>
</td></tr><tr><td>use_locking</td><td>bool</td><td>b: true
</td><td></td><td><p>If True, the assignment will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a <code>Variable</code> node. May be uninitialized.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The value to be assigned to the variable.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= Same as &quot;ref&quot;.  Returned as a convenience for operations that want
to use the new value after the variable has been reset.</p>
</td></tr></table><a name="AssignAdd"></a><h2>TensorFlow <code>AssignAdd</code> Operation</h2><h3>Description</h3><p>This operation outputs &quot;ref&quot; after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, the addition will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a <code>Variable</code> node.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The value to be added to the variable.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= Same as &quot;ref&quot;.  Returned as a convenience for operations that want
to use the new value after the variable has been updated.</p>
</td></tr></table><a name="AssignSub"></a><h2>TensorFlow <code>AssignSub</code> Operation</h2><h3>Description</h3><p>This operation outputs &quot;ref&quot; after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, the subtraction will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a <code>Variable</code> node.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The value to be subtracted to the variable.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= Same as &quot;ref&quot;.  Returned as a convenience for operations that want
to use the new value after the variable has been updated.</p>
</td></tr></table><a name="Atan"></a><h2>TensorFlow <code>Atan</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="AudioSummary"></a><h2>TensorFlow <code>AudioSummary</code> Operation</h2><h3>Description</h3><p>The summary has up to <code>max_outputs</code> summary values containing audio. The
audio is built from <code>tensor</code> which must be 3-D with shape <code>[batch_size,
frames, channels]</code> or 2-D with shape <code>[batch_size, frames]</code>. The values are
assumed to be in the range of <code>[-1.0, 1.0]</code> with a sample rate of <code>sample_rate</code>.</p>

<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
build the <code>tag</code> of the summary values:</p>

<ul>
<li> If <code>max_outputs</code> is 1, the summary value tag is &#39;<em>tag</em>/audio&#39;.</li>
<li> If <code>max_outputs</code> is greater than 1, the summary value tags are
generated sequentially as &#39;<em>tag</em>/audio/0&#39;, &#39;<em>tag</em>/audio/1&#39;, etc.</li>
</ul>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>sample_rate</td><td>float</td><td></td><td></td><td><p>The sample rate of the signal in hertz.</p>
</td></tr><tr><td>max_outputs</td><td>int</td><td>i: 3
</td><td><b>Minimum: </b>1</td><td><p>Max number of batch elements to generate audio for.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tag</code></td><td>DT_STRING</td><td></td><td><p>Scalar. Used to build the <code>tag</code> attribute of the summary values.</p>
</td></tr><tr><td><code>tensor</code></td><td>DT_FLOAT</td><td></td><td><p>2-D of shape <code>[batch_size, frames]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>summary</code></td><td>DT_STRING</td><td></td><td><p>Scalar. Serialized <code>Summary</code> protocol buffer.</p>
</td></tr></table><a name="AvgPool"></a><h2>TensorFlow <code>AvgPool</code> Operation</h2><h3>Description</h3><p>Each entry in <code>output</code> is the mean of the corresponding size <code>ksize</code>
window in <code>value</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the sliding window for each dimension of <code>value</code>.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of <code>value</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The average pooled output tensor.</p>
</td></tr></table><a name="AvgPool3D"></a><h2>TensorFlow <code>AvgPool3D</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The size of the window for each dimension of
the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The average pooled output tensor.</p>
</td></tr></table><a name="AvgPool3DGrad"></a><h2>TensorFlow <code>AvgPool3DGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The size of the window for each dimension of
the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>orig_input_shape</code></td><td>DT_INT32</td><td></td><td><p>The original input dimensions.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The backprop for input.</p>
</td></tr></table><a name="AvgPoolGrad"></a><h2>TensorFlow <code>AvgPoolGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the sliding window for each dimension of the input.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of the input.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>orig_input_shape</code></td><td>DT_INT32</td><td></td><td><p>1-D.  Shape of the original input to <code>avg_pool</code>.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t.
the output of <code>avg_pool</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D.  Gradients w.r.t. the input of <code>avg_pool</code>.</p>
</td></tr></table><a name="Barrier"></a><h2>TensorFlow <code>Barrier</code> Operation</h2><h3>Description</h3><p>A barrier represents a key-value map, where each key is a string, and
each value is a tuple of tensors.</p>

<p>At runtime, the barrier contains &#39;complete&#39; and &#39;incomplete&#39;
elements. A complete element has defined tensors for all components of
its value tuple, and may be accessed using BarrierTakeMany. An
incomplete element has some undefined components in its value tuple,
and may be updated using BarrierInsertMany.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a value.</p>
</td></tr><tr><td>shapes</td><td>list(shape)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>The shape of each component in a value. Each shape must be 1 in the
first dimension. The length of this attr must be the same as the length of
component_types.</p>
</td></tr><tr><td>capacity</td><td>int</td><td>i: -1
</td><td></td><td><p>The capacity of the barrier.  The default capacity is MAX_INT32,
which is the largest capacity of the underlying queue.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this barrier is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this barrier will be shared under the given name
across multiple sessions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the barrier.</p>
</td></tr></table><a name="BarrierClose"></a><h2>TensorFlow <code>BarrierClose</code> Operation</h2><h3>Description</h3><p>This operation signals that no more new elements will be inserted in the
given barrier. Subsequent InsertMany that try to introduce a new key will fail.
Subsequent InsertMany operations that just add missing components to already
existing elements will continue to succeed. Subsequent TakeMany operations will
continue to succeed if sufficient completed elements remain in the barrier.
Subsequent TakeMany operations that would block will fail immediately.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>cancel_pending_enqueues</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, all pending enqueue requests that are
blocked on the barrier&#39;s queue will be cancelled. InsertMany will fail, even
if no new key is introduced.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a barrier.</p>
</td></tr></table><a name="BarrierIncompleteSize"></a><h2>TensorFlow <code>BarrierIncompleteSize</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a barrier.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>The number of incomplete elements (i.e. those with some of their value
components not set) in the barrier.</p>
</td></tr></table><a name="BarrierInsertMany"></a><h2>TensorFlow <code>BarrierInsertMany</code> Operation</h2><h3>Description</h3><p>If a key is not found in the barrier, this operation will create a new
incomplete element. If a key is found in the barrier, and the element
already has a value at component<em>index, this operation will fail with
INVALID</em>ARGUMENT, and leave the barrier in an undefined state.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>component_index</td><td>int</td><td></td><td></td><td><p>The component of the barrier elements that is being assigned.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a barrier.</p>
</td></tr><tr><td><code>keys</code></td><td>DT_STRING</td><td></td><td><p>A one-dimensional tensor of keys, with length n.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>An any-dimensional tensor of values, which are associated with the
respective keys. The 0th dimension must have length n.</p>
</td></tr></table><a name="BarrierReadySize"></a><h2>TensorFlow <code>BarrierReadySize</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a barrier.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>The number of complete elements (i.e. those with all of their value
components set) in the barrier.</p>
</td></tr></table><a name="BarrierTakeMany"></a><h2>TensorFlow <code>BarrierTakeMany</code> Operation</h2><h3>Description</h3><p>This operation concatenates completed-element component tensors along
the 0th dimension to make a single component tensor.</p>

<p>Elements come out of the barrier when they are complete, and in the order
in which they were placed into the barrier.  The indices output provides
information about the batch in which each element was originally inserted
into the barrier.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a value.</p>
</td></tr><tr><td>allow_small_batch</td><td>bool</td><td>b: false
</td><td></td><td><p>Allow to return less than num_elements items if barrier is
already closed.</p>
</td></tr><tr><td>wait_for_incomplete</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>timeout_ms</td><td>int</td><td>i: -1
</td><td></td><td><p>If the queue is empty, this operation will block for up to
timeout_ms milliseconds.
Note: This option is not supported yet.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a barrier.</p>
</td></tr><tr><td><code>num_elements</code></td><td>DT_INT32</td><td></td><td><p>A single-element tensor containing the number of elements to
take.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>indices</code></td><td>DT_INT64</td><td></td><td><p>A one-dimensional tensor of indices, with length num<em>elems.
These indices refer to the batch in which the values were placed into the
barrier (starting with MIN</em>LONG and increasing with each BarrierInsertMany).</p>
</td></tr><tr><td><code>keys</code></td><td>DT_STRING</td><td></td><td><p>A one-dimensional tensor of keys, with length num_elements.</p>
</td></tr><tr><td><code>values</code></td><td><b>type list: </b><code>component_types</code></td><td></td><td><p>One any-dimensional tensor per component in a barrier element. All
values have length num_elements in the 0th dimension.</p>
</td></tr></table><a name="BatchCholesky"></a><h2>TensorFlow <code>BatchCholesky</code> Operation</h2><h3>Description</h3><p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices, with the same constraints as the single matrix Cholesky
decomposition above. The output is a tensor of the same shape as the input
containing the Cholesky decompositions for all input submatrices <code>[..., :, :]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr></table><a name="BatchCholeskyGrad"></a><h2>TensorFlow <code>BatchCholeskyGrad</code> Operation</h2><h3>Description</h3><p>For an explanation see &quot;Differentiation of the Cholesky algorithm&quot; by
Iain Murray http://arxiv.org/abs/1602.07527.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>l</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output of batch Cholesky algorithm l = batch_cholesky(A). Shape is <code>[..., M, M]</code>.
Algorithm depends only on lower triangular part of the innermost matrices of
this tensor.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>df/dl where f is some scalar function. Shape is <code>[..., M, M]</code>.
Algorithm depends only on lower triangular part of the innermost matrices of
this tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Symmetrized version of df/dA . Shape is <code>[..., M, M]</code></p>
</td></tr></table><a name="BatchFFT"></a><h2>TensorFlow <code>BatchFFT</code> Operation</h2><h3>Description</h3><p>dimension of <code>input</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most
dimension of <code>input</code> is replaced with its 1D Fourier Transform.</p>
</td></tr></table><a name="BatchFFT2D"></a><h2>TensorFlow <code>BatchFFT2D</code> Operation</h2><h3>Description</h3><p>2 dimensions of <code>input</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most 2
dimensions of <code>input</code> are replaced with their 2D Fourier Transform.</p>
</td></tr></table><a name="BatchFFT3D"></a><h2>TensorFlow <code>BatchFFT3D</code> Operation</h2><h3>Description</h3><p>dimensions of <code>input</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
dimensions of <code>input</code> are replaced with their 3D Fourier Transform.</p>
</td></tr></table><a name="BatchIFFT"></a><h2>TensorFlow <code>BatchIFFT</code> Operation</h2><h3>Description</h3><p>dimension of <code>input</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most
dimension of <code>input</code> is replaced with its inverse 1D Fourier Transform.</p>
</td></tr></table><a name="BatchIFFT2D"></a><h2>TensorFlow <code>BatchIFFT2D</code> Operation</h2><h3>Description</h3><p>2 dimensions of <code>input</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most 2
dimensions of <code>input</code> are replaced with their inverse 2D Fourier Transform.</p>
</td></tr></table><a name="BatchIFFT3D"></a><h2>TensorFlow <code>BatchIFFT3D</code> Operation</h2><h3>Description</h3><p>3 dimensions of <code>input</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 tensor of the same shape as <code>input</code>. The inner-most 3
dimensions of <code>input</code> are replaced with their inverse 3D Fourier Transform.</p>
</td></tr></table><a name="BatchMatMul"></a><h2>TensorFlow <code>BatchMatMul</code> Operation</h2><h3>Description</h3><p>Multiplies all slices of <code>Tensor</code> <code>x</code> and <code>y</code> (each slice can be
viewed as an element of a batch), and arranges the individual results
in a single output tensor of the same batch size. Each of the
individual slices can optionally be adjointed (to adjoint a matrix
means to transpose and conjugate it) before multiplication by setting
the <code>adj_x</code> or <code>adj_y</code> flag to <code>True</code>, which are by default <code>False</code>.</p>

<p>The input tensors <code>x</code> and <code>y</code> are 3-D or higher with shape <code>[..., r_x, c_x]</code>
and <code>[..., r_y, c_y]</code>.</p>

<p>The output tensor is 3-D or higher with shape <code>[..., r_o, c_o]</code>, where:</p>

<pre><code>r_o = c_x if adj_x else r_x
c_o = r_y if adj_y else c_y
</code></pre>

<p>It is computed as:</p>

<pre><code>output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr><tr><td>adj_x</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, adjoint the slices of <code>x</code>. Defaults to <code>False</code>.</p>
</td></tr><tr><td>adj_y</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, adjoint the slices of <code>y</code>. Defaults to <code>False</code>.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D or higher with shape <code>[..., r_x, c_x]</code>.</p>
</td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D or higher with shape <code>[..., r_y, c_y]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D or higher with shape <code>[..., r_o, c_o]</code></p>
</td></tr></table><a name="BatchMatrixBandPart"></a><h2>TensorFlow <code>BatchMatrixBandPart</code> Operation</h2><h3>Description</h3><p>to zero.</p>

<p>The <code>band</code> part is computed as follows:
Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., M, N]</code>, then the output is a
tensor with the same shape where</p>

<p><code>band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]</code>.</p>

<p>The indicator function &#39;in<em>band(m, n)<code>is one if
</code>(num</em>lower &lt; 0 || (m-n) &lt;= num<em>lower)) &amp;&amp;
(num</em>upper &lt; 0 || (n-m) &lt;= num_upper)`, and zero otherwise.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># if &#39;input&#39; is [[ 0,  1,  2, 3]
                 [-1,  0,  1, 2]
                 [-2, -1,  0, 1]
                 [-3, -2, -1, 0]],

tf.batch_matrix_band_part(input, 1, -1) ==&gt; [[ 0,  1,  2, 3]
                                             [-1,  0,  1, 2]
                                             [ 0, -1,  0, 1]
                                             [ 0,  0, -1, 0]],

tf.batch_matrix_band_part(input, 2, 1) ==&gt; [[ 0,  1,  0, 0]
                                            [-1,  0,  1, 0]
                                            [-2, -1,  0, 1]
                                            [ 0, -2, -1, 0]]
</code></pre>

<p>Useful special cases:</p>

<pre><code class="language-prettyprint"> tf.batch_matrix_band_part(input, 0, -1) ==&gt; Upper triangular part.
 tf.batch_matrix_band_part(input, -1, 0) ==&gt; Lower triangular part.
 tf.batch_matrix_band_part(input, 0, 0) ==&gt; Diagonal.
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k</code> tensor.</p>
</td></tr><tr><td><code>num_lower</code></td><td>DT_INT64</td><td></td><td><p>0-D tensor. Number of subdiagonals to keep. If negative, keep entire
lower triangle.</p>
</td></tr><tr><td><code>num_upper</code></td><td>DT_INT64</td><td></td><td><p>0-D tensor. Number of superdiagonals to keep. If negative, keep
entire upper triangle.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>band</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k</code> tensor of the same shape as input. The extracted banded tensor.</p>
</td></tr></table><a name="BatchMatrixDeterminant"></a><h2>TensorFlow <code>BatchMatrixDeterminant</code> Operation</h2><h3>Description</h3><p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. The output is a tensor containing the determinants
for all input submatrices <code>[..., :, :]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[...]</code>.</p>
</td></tr></table><a name="BatchMatrixDiag"></a><h2>TensorFlow <code>BatchMatrixDiag</code> Operation</h2><h3>Description</h3><p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
everything else padded with zeros. The diagonal is computed as follows:</p>

<p>Assume <code>diagonal</code> has <code>k</code> dimensions <code>[I, J, K, ..., N]</code>, then the output is a
tensor of rank <code>k+1</code> with dimensions [I, J, K, ..., N, N]` where:</p>

<p><code>output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;diagonal&#39; is [[1, 2, 3, 4], [5, 6, 7, 8]]

and diagonal.shape = (2, 4)

tf.batch_matrix_diag(diagonal) ==&gt; [[[1, 0, 0, 0]
                                     [0, 2, 0, 0]
                                     [0, 0, 3, 0]
                                     [0, 0, 0, 4]],
                                    [[5, 0, 0, 0]
                                     [0, 6, 0, 0]
                                     [0, 0, 7, 0]
                                     [0, 0, 0, 8]]]

which has shape (2, 4, 4)
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>diagonal</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k</code>, where <code>k &gt;= 1</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k+1</code>, with <code>output.shape = diagonal.shape + [diagonal.shape[-1]]</code>.</p>
</td></tr></table><a name="BatchMatrixDiagPart"></a><h2>TensorFlow <code>BatchMatrixDiagPart</code> Operation</h2><h3>Description</h3><p>This operation returns a tensor with the <code>diagonal</code> part
of the batched <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>

<p>Assume <code>input</code> has <code>k</code> dimensions <code>[I, J, K, ..., N, N]</code>, then the output is a
tensor of rank <code>k - 1</code> with dimensions <code>[I, J, K, ..., N]</code> where:</p>

<p><code>diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]</code>.</p>

<p>The input must be at least a matrix.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;input&#39; is [[[1, 0, 0, 0]
               [0, 2, 0, 0]
               [0, 0, 3, 0]
               [0, 0, 0, 4]],
              [[5, 0, 0, 0]
               [0, 6, 0, 0]
               [0, 0, 7, 0]
               [0, 0, 0, 8]]]

and input.shape = (2, 4, 4)

tf.batch_matrix_diag_part(input) ==&gt; [[1, 2, 3, 4], [5, 6, 7, 8]]

which has shape (2, 4)
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k</code> tensor where <code>k &gt;= 2</code> and the last two dimensions are equal.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>diagonal</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The extracted diagonal(s) having shape
<code>diagonal.shape = input.shape[:-1]</code>.</p>
</td></tr></table><a name="BatchMatrixInverse"></a><h2>TensorFlow <code>BatchMatrixInverse</code> Operation</h2><h3>Description</h3><p>(conjugate transposes).</p>

<p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. The output is a tensor of the same shape as the input
containing the inverse for all input submatrices <code>[..., :, :]</code>.</p>

<p>The op uses LU decomposition with partial pivoting to compute the inverses.</p>

<p>If a matrix is not invertible there is no guarantee what the op does. It
may detect the condition and raise an exception or it may simply return a
garbage result.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>adjoint</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr></table><a name="BatchMatrixSetDiag"></a><h2>TensorFlow <code>BatchMatrixSetDiag</code> Operation</h2><h3>Description</h3><p>Given <code>input</code> and <code>diagonal</code>, this operation returns a tensor with the
same shape and values as <code>input</code>, except for the diagonals of the innermost
matrices.  These will be overwritten by the values in <code>diagonal</code>.
The batched matrices must be square.</p>

<p>The output is computed as follows:</p>

<p>Assume <code>input</code> has <code>k+1</code> dimensions <code>[I, J, K, ..., N, N]</code> and <code>diagonal</code> has
<code>k</code> dimensions <code>[I, J, K, ..., N]</code>.  Then the output is a
tensor of rank <code>k+1</code> with dimensions [I, J, K, ..., N, N]` where:</p>

<ul>
<li><code>output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]</code> for <code>m == n</code>.</li>
<li><code>output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]</code> for <code>m != n</code>.</li>
</ul>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k+1</code>, where <code>k &gt;= 1</code>.</p>
</td></tr><tr><td><code>diagonal</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k</code>, where <code>k &gt;= 1</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank <code>k+1</code>, with <code>output.shape = input.shape</code>.</p>
</td></tr></table><a name="BatchMatrixSolve"></a><h2>TensorFlow <code>BatchMatrixSolve</code> Operation</h2><h3>Description</h3><p>Matrix is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices. Rhs is a tensor of shape
<code>[..., M, K]</code>. The output is a tensor shape <code>[..., M, K]</code>.  If <code>adjoint</code> is <code>False</code> then each output
matrix satisfies <code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]</code>.
If <code>adjoint</code> is <code>True</code> then each output
matrix satisfies <code>adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>adjoint</td><td>bool</td><td>b: false
</td><td></td><td><p>Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
adjoint.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>matrix</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr><tr><td><code>rhs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, K]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, K]</code>.</p>
</td></tr></table><a name="BatchMatrixSolveLs"></a><h2>TensorFlow <code>BatchMatrixSolveLs</code> Operation</h2><h3>Description</h3><p><code>matrix</code> is a tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
form matrices of size <code>[M, N]</code>. Rhs is a tensor of shape <code>[..., M, K]</code>.
The output is a tensor shape <code>[..., N, K]</code> where each output matrix solves
each of the equations matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]
in the least squares sense.</p>

<p>Below we will use the following notation for each pair of
matrix and right-hand sides in the batch:</p>

<p><code>matrix</code>=\(A \in \Re^{m \times n}\),
<code>rhs</code>=\(B  \in \Re^{m \times k}\),
<code>output</code>=\(X  \in \Re^{n \times k}\),
<code>l2_regularizer</code>=\(\lambda\).</p>

<p>If <code>fast</code> is <code>True</code>, then the solution is computed by solving the normal
equations using Cholesky decomposition. Specifically, if \(m \ge n\) then
\(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares
problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||A Z - B||_F^2 +
\lambda ||Z||_F^2\). If \(m \lt n\) then <code>output</code> is computed as
\(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the
minimum-norm solution to the under-determined linear system, i.e.
\(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||Z||_F^2 \), subject to
\(A Z = B\). Notice that the fast path is only numerically stable when
\(A\) is numerically full rank and has a condition number
\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach}}}\) or\(\lambda\) is
sufficiently large.</p>

<p>If <code>fast</code> is <code>False</code> an algorithm based on the numerically robust complete
orthogonal decomposition is used. This computes the minimum-norm
least-squares solution, even when \(A\) is rank deficient. This path is
typically 6-7 times slower than the fast path. If <code>fast</code> is <code>False</code> then
<code>l2_regularizer</code> is ignored.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr><tr><td>fast</td><td>bool</td><td>b: true
</td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>matrix</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, N]</code>.</p>
</td></tr><tr><td><code>rhs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, K]</code>.</p>
</td></tr><tr><td><code>l2_regularizer</code></td><td>DT_DOUBLE</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., N, K]</code>.</p>
</td></tr></table><a name="BatchMatrixTriangularSolve"></a><h2>TensorFlow <code>BatchMatrixTriangularSolve</code> Operation</h2><h3>Description</h3><p>backsubstitution.</p>

<p><code>matrix</code> is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions form
square matrices. If <code>lower</code> is <code>True</code> then the strictly upper triangular part
of each inner-most matrix is assumed to be zero and not accessed.
If <code>lower</code> is False then the strictly lower triangular part of each inner-most
matrix is assumed to be zero and not accessed.
<code>rhs</code> is a tensor of shape [..., M, K]`.</p>

<p>The output is a tensor of shape <code>[..., M, K]</code>. If <code>adjoint</code> is <code>True</code> then the
innermost matrices in output<code>satisfy matrix equations
</code>matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]<code>.
If</code>adjoint<code>is</code>False<code>then the strictly then the  innermost matrices in
</code>output<code>satisfy matrix equations
</code>adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>lower</td><td>bool</td><td>b: true
</td><td></td><td><p>Boolean indicating whether the innermost matrices in <code>matrix</code> are
lower or upper triangular.</p>
</td></tr><tr><td>adjoint</td><td>bool</td><td>b: false
</td><td></td><td><p>Boolean indicating whether to solve with <code>matrix</code> or its (block-wise)
adjoint.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>matrix</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr><tr><td><code>rhs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, K]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, K]</code>.</p>
</td></tr></table><a name="BatchNormWithGlobalNormalization"></a><h2>TensorFlow <code>BatchNormWithGlobalNormalization</code> Operation</h2><h3>Description</h3><p>This op is deprecated. Prefer <code>tf.nn.batch_normalization</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>variance_epsilon</td><td>float</td><td></td><td></td><td><p>A small float number to avoid dividing by 0.</p>
</td></tr><tr><td>scale_after_normalization</td><td>bool</td><td></td><td></td><td><p>A bool indicating whether the resulted tensor
needs to be multiplied with gamma.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>t</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 4D input Tensor.</p>
</td></tr><tr><td><code>m</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D mean Tensor with size matching the last dimension of t.
This is the first output from tf.nn.moments,
or a saved moving average thereof.</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D variance Tensor with size matching the last dimension of t.
This is the second output from tf.nn.moments,
or a saved moving average thereof.</p>
</td></tr><tr><td><code>beta</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D beta Tensor with size matching the last dimension of t.
An offset to be added to the normalized tensor.</p>
</td></tr><tr><td><code>gamma</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D gamma Tensor with size matching the last dimension of t.
If &quot;scale<em>after</em>normalization&quot; is true, this tensor will be multiplied
with the normalized tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>result</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="BatchNormWithGlobalNormalizationGrad"></a><h2>TensorFlow <code>BatchNormWithGlobalNormalizationGrad</code> Operation</h2><h3>Description</h3><p>This op is deprecated. See <code>tf.nn.batch_normalization</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>variance_epsilon</td><td>float</td><td></td><td></td><td><p>A small float number to avoid dividing by 0.</p>
</td></tr><tr><td>scale_after_normalization</td><td>bool</td><td></td><td></td><td><p>A bool indicating whether the resulted tensor
needs to be multiplied with gamma.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>t</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 4D input Tensor.</p>
</td></tr><tr><td><code>m</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D mean Tensor with size matching the last dimension of t.
This is the first output from tf.nn.moments,
or a saved moving average thereof.</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D variance Tensor with size matching the last dimension of t.
This is the second output from tf.nn.moments,
or a saved moving average thereof.</p>
</td></tr><tr><td><code>gamma</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 1D gamma Tensor with size matching the last dimension of t.
If &quot;scale<em>after</em>normalization&quot; is true, this Tensor will be multiplied
with the normalized Tensor.</p>
</td></tr><tr><td><code>backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4D backprop Tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>dx</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4D backprop tensor for input.</p>
</td></tr><tr><td><code>dm</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1D backprop tensor for mean.</p>
</td></tr><tr><td><code>dv</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1D backprop tensor for variance.</p>
</td></tr><tr><td><code>db</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1D backprop tensor for beta.</p>
</td></tr><tr><td><code>dg</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1D backprop tensor for gamma.</p>
</td></tr></table><a name="BatchSelfAdjointEig"></a><h2>TensorFlow <code>BatchSelfAdjointEig</code> Operation</h2><h3>Description</h3><p>The input is a tensor of shape <code>[..., M, M]</code> whose inner-most 2 dimensions
form square matrices, with the same constraints as the single matrix
SelfAdjointEig.</p>

<p>The result is a [..., M+1, M] matrix with [..., 0,:] containing the
eigenvalues, and subsequent [...,1:, :] containing the eigenvectors.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[..., M+1, M]</code>.</p>
</td></tr></table><a name="BatchSelfAdjointEigV2"></a><h2>TensorFlow <code>BatchSelfAdjointEigV2</code> Operation</h2><h3>Description</h3><p>Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in
<code>input</code> such that <code>input[..., :, :] = v[..., :, :] * diag(e[..., :])</code>.</p>

<pre><code class="language-prettyprint"># a is a tensor.
# e is a tensor of eigenvalues.
# v is a tensor of eigenvectors.
e, v = batch_self_adjoint_eig(a)
e = batch_self_adjoint_eig(a, compute_v=False)
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>compute_v</td><td>bool</td><td>b: true
</td><td></td><td><p>If <code>True</code> then eigenvectors will be computed and returned in <code>v</code>.
Otherwise, only the eigenvalues will be computed.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>Tensor</code> input of shape <code>[N, N]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>e</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Eigenvalues. Shape is <code>[N]</code>.</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Eigenvectors. Shape is <code>[N, N]</code>.</p>
</td></tr></table><a name="BatchSvd"></a><h2>TensorFlow <code>BatchSvd</code> Operation</h2><h3>Description</h3><p>Computes the SVD of each inner matrix in <code>input</code> such that
<code>input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])</code></p>

<pre><code class="language-prettyprint"># a is a tensor containing a batch of matrices.
# s is a tensor of singular values for each matrix.
# u is the tensor containing of left singular vectors for each matrix.
# v is the tensor containing of right singular vectors for each matrix.
s, u, v = batch_svd(a)
s, _, _ = batch_svd(a, compute_uv=False)
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>compute_uv</td><td>bool</td><td>b: true
</td><td></td><td><p>If true, left and right singular vectors will be
computed and returned in <code>u</code> and <code>v</code>, respectively.
If false, <code>u</code> and <code>v</code> are not set and should never referenced.</p>
</td></tr><tr><td>full_matrices</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, compute full-sized <code>u</code> and <code>v</code>. If false
(the default), compute only the leading <code>P</code> singular vectors.
Ignored if <code>compute_uv</code> is <code>False</code>.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor of shape <code>[..., M, N]</code> whose inner-most 2 dimensions
form matrices of size <code>[M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and <code>N</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>s</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Singular values. Shape is <code>[..., P]</code>.</p>
</td></tr><tr><td><code>u</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is
<code>[..., M, M]</code>; if <code>full_matrices</code> is <code>True</code> then shape is
<code>[..., M, P]</code>. Undefined if <code>compute_uv</code> is <code>False</code>.</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is
<code>[..., N, N]</code>. If <code>full_matrices</code> is <code>True</code> then shape is <code>[..., N, P]</code>.
Undefined if <code>compute_uv</code> is false.</p>
</td></tr></table><a name="BatchToSpace"></a><h2>TensorFlow <code>BatchToSpace</code> Operation</h2><h3>Description</h3><p>Rearranges (permutes) data from batch into blocks of spatial data, followed by
cropping. This is the reverse transformation of SpaceToBatch. More specifically,
this op outputs a copy of the input tensor where values from the <code>batch</code>
dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions,
followed by cropping along the <code>height</code> and <code>width</code> dimensions.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>block_size</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D tensor with shape
<code>[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
  depth]</code>. Note that the batch size of the input tensor must be divisible by
<code>block_size * block_size</code>.</p>
</td></tr><tr><td><code>crops</code></td><td>DT_INT32</td><td></td><td><p>2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
how many elements to crop from the intermediate result across the spatial
dimensions as follows:</p>

<pre><code>crops = [[crop_top, crop_bottom], [crop_left, crop_right]]
</code></pre>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, depth]</code>, where:</p>

<pre><code>  height = height_pad - crop_top - crop_bottom
  width = width_pad - crop_left - crop_right
</code></pre>

<p>The attr <code>block_size</code> must be greater than one. It indicates the block size.</p>

<p>Some examples:</p>

<p>(1) For the following input of shape <code>[4, 1, 1, 1]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
</code></pre>

<p>The output tensor has shape <code>[1, 2, 2, 1]</code> and value:</p>

<pre><code class="language-prettyprint">x = [[[[1], [2]], [[3], [4]]]]
</code></pre>

<p>(2) For the following input of shape <code>[4, 1, 1, 3]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
</code></pre>

<p>The output tensor has shape <code>[1, 2, 2, 3]</code> and value:</p>

<pre><code class="language-prettyprint">x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
</code></pre>

<p>(3) For the following input of shape <code>[4, 2, 2, 1]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
</code></pre>

<p>The output tensor has shape <code>[1, 4, 4, 1]</code> and value:</p>

<pre><code class="language-prettyprint">x = [[[1],   [2],  [3],  [4]],
     [[5],   [6],  [7],  [8]],
     [[9],  [10], [11],  [12]],
     [[13], [14], [15],  [16]]]
</code></pre>

<p>(4) For the following input of shape <code>[8, 1, 2, 1]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
</code></pre>

<p>The output tensor has shape <code>[2, 2, 4, 1]</code> and value:</p>

<pre><code class="language-prettyprint">x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
</code></pre>
</td></tr></table><a name="BiasAdd"></a><h2>TensorFlow <code>BiasAdd</code> Operation</h2><h3>Description</h3><p>This is a special case of <code>tf.add</code> where <code>bias</code> is restricted to be 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the bias tensor will be added to the last dimension
of the value tensor.
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in<em>channels, in</em>height, in<em>width].
The tensor will be added to &quot;in</em>channels&quot;, the third-to-the-last
    dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Any number of dimensions.</p>
</td></tr><tr><td><code>bias</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D with size the last dimension of <code>value</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Broadcasted sum of <code>value</code> and <code>bias</code>.</p>
</td></tr></table><a name="BiasAddGrad"></a><h2>TensorFlow <code>BiasAddGrad</code> Operation</h2><h3>Description</h3><p>It accumulates all the values from out_backprop into the feature dimension.
For NHWC data format, the feature dimension is the last. For NCHW data format,
the feature dimension is the third-to-last.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the bias tensor will be added to the last dimension
of the value tensor.
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in<em>channels, in</em>height, in<em>width].
The tensor will be added to &quot;in</em>channels&quot;, the third-to-the-last
    dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Any number of dimensions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D with size the feature dimension of <code>out_backprop</code>.</p>
</td></tr></table><a name="BiasAddV1"></a><h2>TensorFlow <code>BiasAddV1</code> Operation</h2><h3>Description</h3><p>This is a deprecated version of BiasAdd and will be soon removed.</p>

<p>This is a special case of <code>tf.add</code> where <code>bias</code> is restricted to be 1-D.
Broadcasting is supported, so <code>value</code> may have any number of dimensions.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Any number of dimensions.</p>
</td></tr><tr><td><code>bias</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D with size the last dimension of <code>value</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Broadcasted sum of <code>value</code> and <code>bias</code>.</p>
</td></tr></table><a name="Bitcast"></a><h2>TensorFlow <code>Bitcast</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>input</code>, this operation returns a tensor that has the same buffer
data as <code>input</code> with datatype <code>type</code>.</p>

<p>If the input datatype <code>T</code> is larger than the output datatype <code>type</code> then the
shape changes from [...] to [..., sizeof(<code>T</code>)/sizeof(<code>type</code>)].</p>

<p>If <code>T</code> is smaller than <code>type</code>, the operator requires that the rightmost
dimension be equal to sizeof(<code>type</code>)/sizeof(<code>T</code>). The shape then goes from
[..., sizeof(<code>type</code>)/sizeof(<code>T</code>)] to [...].</p>

<p><em>NOTE</em>: Bitcast is implemented as a low-level cast, so machines with different
endian orderings will give different results.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>type</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>type</code></td><td></td><td></td></tr></table><a name="BroadcastGradientArgs"></a><h2>TensorFlow <code>BroadcastGradientArgs</code> Operation</h2><h3>Description</h3><p>This is typically used by gradient computations for a broadcasting operation.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>s0</code></td><td>DT_INT32</td><td></td><td></td></tr><tr><td><code>s1</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>r0</code></td><td>DT_INT32</td><td></td><td></td></tr><tr><td><code>r1</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="CTCBeamSearchDecoder"></a><h2>TensorFlow <code>CTCBeamSearchDecoder</code> Operation</h2><h3>Description</h3><p>A note about the attribute merge<em>repeated: For the beam search decoder,
this means that if consecutive entries in a beam are the same, only
the first of these is emitted.  That is, when the top path is &quot;A B B B B&quot;,
&quot;A B&quot; is returned if merge</em>repeated = True but &quot;A B B B B&quot; is
returned if merge_repeated = False.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>beam_width</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>A scalar &gt;= 0 (beam search beam width).</p>
</td></tr><tr><td>top_paths</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>A scalar &gt;= 0, &lt;= beam_width (controls output size).</p>
</td></tr><tr><td>merge_repeated</td><td>bool</td><td>b: true
</td><td></td><td><p>If true, merge repeated classes in output.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td>DT_FLOAT</td><td></td><td><p>3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.</p>
</td></tr><tr><td><code>sequence_length</code></td><td>DT_INT32</td><td></td><td><p>A vector containing sequence lengths, size <code>(batch)</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>decoded_indices</code></td><td>DT_INT64</td><td><b>number: </b><code><p>top_paths</p>
</code></td><td><p>A list (length: top_paths) of indices matrices.  Matrix j,
size <code>(total_decoded_outputs[j] x 2)</code>, has indices of a
<code>SparseTensor&lt;int64, 2&gt;</code>.  The rows store: [batch, time].</p>
</td></tr><tr><td><code>decoded_values</code></td><td>DT_INT64</td><td><b>number: </b><code><p>top_paths</p>
</code></td><td><p>A list (length: top_paths) of values vectors.  Vector j,
size <code>(length total_decoded_outputs[j])</code>, has the values of a
<code>SparseTensor&lt;int64, 2&gt;</code>.  The vector stores the decoded classes for beam j.</p>
</td></tr><tr><td><code>decoded_shape</code></td><td>DT_INT64</td><td><b>number: </b><code><p>top_paths</p>
</code></td><td><p>A list (length: top_paths) of shape vector.  Vector j,
size <code>(2)</code>, stores the shape of the decoded <code>SparseTensor[j]</code>.
Its values are: <code>[batch_size, max_decoded_length[j]]</code>.</p>
</td></tr><tr><td><code>log_probability</code></td><td>DT_FLOAT</td><td></td><td><p>A matrix, shaped: <code>(batch_size x top_paths)</code>.  The
sequence log-probabilities.</p>
</td></tr></table><a name="CTCGreedyDecoder"></a><h2>TensorFlow <code>CTCGreedyDecoder</code> Operation</h2><h3>Description</h3><p>A note about the attribute merge<em>repeated: if enabled, when
consecutive logits&#39; maximum indices are the same, only the first of
these is emitted.  Labeling the blank &#39;*&#39;, the sequence &quot;A B B * B B&quot;
becomes &quot;A B&quot; if merge</em>repeated = True and &quot;A B B B B&quot; if
merge_repeated = False.</p>

<p>Regardless of the value of merge_repeated, if the maximum index of a given
time and batch corresponds to the blank, index <code>(num_classes - 1)</code>, no new
element is emitted.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>merge_repeated</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, merge repeated classes in output.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td>DT_FLOAT</td><td></td><td><p>3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.</p>
</td></tr><tr><td><code>sequence_length</code></td><td>DT_INT32</td><td></td><td><p>A vector containing sequence lengths, size <code>(batch_size)</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>decoded_indices</code></td><td>DT_INT64</td><td></td><td><p>Indices matrix, size <code>(total_decoded_outputs x 2)</code>,
of a <code>SparseTensor&lt;int64, 2&gt;</code>.  The rows store: [batch, time].</p>
</td></tr><tr><td><code>decoded_values</code></td><td>DT_INT64</td><td></td><td><p>Values vector, size: <code>(total_decoded_outputs)</code>,
of a <code>SparseTensor&lt;int64, 2&gt;</code>.  The vector stores the decoded classes.</p>
</td></tr><tr><td><code>decoded_shape</code></td><td>DT_INT64</td><td></td><td><p>Shape vector, size <code>(2)</code>, of the decoded SparseTensor.
Values are: <code>[batch_size, max_decoded_length]</code>.</p>
</td></tr><tr><td><code>log_probability</code></td><td>DT_FLOAT</td><td></td><td><p>Matrix, size <code>(batch_size x 1)</code>, containing sequence
log-probabilities.</p>
</td></tr></table><a name="CTCLoss"></a><h2>TensorFlow <code>CTCLoss</code> Operation</h2><h3>Description</h3><p>the gradient.  This class performs the softmax operation for you, so inputs
should be e.g. linear projections of outputs by an LSTM.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>preprocess_collapse_repeated</td><td>bool</td><td>b: false
</td><td></td><td><p>Scalar, if true then repeated labels are
collapsed prior to the CTC calculation.</p>
</td></tr><tr><td>ctc_merge_repeated</td><td>bool</td><td>b: true
</td><td></td><td><p>Scalar.  If set to false, <em>during</em> CTC calculation
repeated non-blank labels will not be merged and are interpreted as
individual labels.  This is a simplified version of CTC.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td>DT_FLOAT</td><td></td><td><p>3-D, shape: <code>(max_time x batch_size x num_classes)</code>, the logits.</p>
</td></tr><tr><td><code>labels_indices</code></td><td>DT_INT64</td><td></td><td><p>The indices of a <code>SparseTensor&lt;int32, 2&gt;</code>.
<code>labels_indices(i, :) == [b, t]</code> means <code>labels_values(i)</code> stores the id for
<code>(batch b, time t)</code>.</p>
</td></tr><tr><td><code>labels_values</code></td><td>DT_INT32</td><td></td><td><p>The values (labels) associated with the given batch and time.</p>
</td></tr><tr><td><code>sequence_length</code></td><td>DT_INT32</td><td></td><td><p>A vector containing sequence lengths (batch).</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>loss</code></td><td>DT_FLOAT</td><td></td><td><p>A vector (batch) containing log-probabilities.</p>
</td></tr><tr><td><code>gradient</code></td><td>DT_FLOAT</td><td></td><td><p>The gradient of <code>loss</code>.  3-D, shape:
<code>(max_time x batch_size x num_classes)</code>.</p>
</td></tr></table><a name="Cast"></a><h2>TensorFlow <code>Cast</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>SrcT</td><td>type</td><td></td><td></td><td></td></tr><tr><td>DstT</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>SrcT</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>DstT</code></td><td></td><td></td></tr></table><a name="Ceil"></a><h2>TensorFlow <code>Ceil</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="CheckNumerics"></a><h2>TensorFlow <code>CheckNumerics</code> Operation</h2><h3>Description</h3><p>When run, reports an <code>InvalidArgument</code> error if <code>tensor</code> has any values
that are not a number (NaN) or infinity (Inf). Otherwise, passes <code>tensor</code> as-is.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>message</td><td>string</td><td></td><td></td><td><p>Prefix of the error message.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Cholesky"></a><h2>TensorFlow <code>Cholesky</code> Operation</h2><h3>Description</h3><p>The input has to be symmetric and positive definite. Only the lower-triangular
part of the input will be used for this operation. The upper-triangular part
will not be read.</p>

<p>The result is the lower-triangular matrix of the Cholesky decomposition of the
input, <code>L</code>, so that <code>input = L L^*</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>.</p>
</td></tr></table><a name="CholeskyGrad"></a><h2>TensorFlow <code>CholeskyGrad</code> Operation</h2><h3>Description</h3><p>For an explanation see &quot;Differentiation of the Cholesky algorithm&quot; by
Iain Murray http://arxiv.org/abs/1602.07527.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>l</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output of Cholesky algorithm l = chol(A). Shape is <code>[M, M]</code>.
Algorithm depends only on lower triangular part of this matrix.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>df/dl where f is some scalar function. Shape is <code>[M, M]</code>.
Algorithm depends only on lower triangular part of this matrix.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Symmetrized version of df/dA . Shape is <code>[M, M]</code>.</p>
</td></tr></table><a name="Complex"></a><h2>TensorFlow <code>Complex</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>real</code> representing the real part of a complex number, and a
tensor <code>imag</code> representing the imaginary part of a complex number, this
operation returns complex numbers elementwise of the form \(a + bj\), where
<em>a</em> represents the <code>real</code> part and <em>b</em> represents the <code>imag</code> part.</p>

<p>The input tensors <code>real</code> and <code>imag</code> must have the same shape.</p>

<p>For example:</p>

<pre><code># tensor &#39;real&#39; is [2.25, 3.25]
# tensor `imag` is [4.75, 5.75]
tf.complex(real, imag) ==&gt; [[2.25 + 4.75j], [3.25 + 5.75j]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>Tout</td><td>type</td><td>type: DT_COMPLEX64
</td><td><b>One of: </b><ul><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>real</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>imag</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td></td></tr></table><a name="ComplexAbs"></a><h2>TensorFlow <code>ComplexAbs</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>x</code> of complex numbers, this operation returns a tensor of type
<code>float</code> or <code>double</code> that is the absolute value of each element in <code>x</code>. All
elements in <code>x</code> must be complex numbers of the form \(a + bj\). The absolute
value is computed as \( \sqrt{a^2 + b^2}\).</p>

<p>For example:</p>

<pre><code># tensor &#39;x&#39; is [[-2.25 + 4.75j], [-3.25 + 5.75j]]
tf.complex_abs(x) ==&gt; [5.25594902, 6.60492229]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_COMPLEX64
</td><td><b>One of: </b><ul><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr><tr><td>Tout</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td></td></tr></table><a name="ComputeAccidentalHits"></a><h2>TensorFlow <code>ComputeAccidentalHits</code> Operation</h2><h3>Description</h3><p>When doing log-odds NCE, the result of this op should be passed through a
SparseToDense op, then added to the logits of the sampled candidates. This has
the effect of &#39;removing&#39; the sampled labels that match the true labels by
making the classifier sure that they are sampled labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td></td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>The true_classes output of UnpackSparseLabels.</p>
</td></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>The sampled_candidates output of CandidateSampler.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>A vector of indices corresponding to rows of true_candidates.</p>
</td></tr><tr><td><code>ids</code></td><td>DT_INT64</td><td></td><td><p>A vector of IDs of positions in sampled<em>candidates that match a true</em>label
for the row with the corresponding index in indices.</p>
</td></tr><tr><td><code>weights</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of the same length as indices and ids, in which each element
is -FLOAT_MAX.</p>
</td></tr></table><a name="Concat"></a><h2>TensorFlow <code>Concat</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>concat_dim</code></td><td>DT_INT32</td><td></td><td><p>0-D.  The dimension along which to concatenate.  Must be in the
range [0, rank(values)).</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>The <code>N</code> Tensors to concatenate. Their ranks and types must match,
and their sizes must match in all dimensions except <code>concat_dim</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A <code>Tensor</code> with the concatenation of values stacked along the
<code>concat_dim</code> dimension.  This tensor&#39;s shape matches that of <code>values</code> except
in <code>concat_dim</code> where it has the sum of the sizes.</p>
</td></tr></table><a name="ConcatOffset"></a><h2>TensorFlow <code>ConcatOffset</code> Operation</h2><h3>Description</h3><p>For example:</p>

<pre><code class="language-prettyprint"># &#39;x&#39; is [2, 2, 7]
# &#39;y&#39; is [2, 3, 7]
# &#39;z&#39; is [2, 5, 7]
concat_offset(2, [x, y, z]) =&gt; [0, 0, 0], [0, 2, 0], [0, 5, 0]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>concat_dim</code></td><td>DT_INT32</td><td></td><td><p>The dimension along which to concatenate.</p>
</td></tr><tr><td><code>shape</code></td><td>DT_INT32</td><td><b>number: </b><code><p>N</p>
</code></td><td><p>The <code>N</code> int32 vectors representing shape of tensors being concatenated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>offset</code></td><td>DT_INT32</td><td><b>number: </b><code><p>N</p>
</code></td><td><p>The <code>N</code> int32 vectors representing the starting offset
        of input tensors within the concatenated output.</p>

<p>This is typically used by gradient computations for a concat operation.</p>
</td></tr></table><a name="Conj"></a><h2>TensorFlow <code>Conj</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
complex numbers that are the complex conjugate of each element in <code>input</code>. The
complex numbers in <code>input</code> must be of the form \(a + bj\), where <em>a</em> is the
real part and <em>b</em> is the imaginary part.</p>

<p>The complex conjugate returned by this operation is of the form \(a - bj\).</p>

<p>For example:</p>

<pre><code># tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.conj(input) ==&gt; [-2.25 - 4.75j, 3.25 - 5.75j]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_COMPLEX64
</td><td><b>One of: </b><ul><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Const"></a><h2>TensorFlow <code>Const</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>value</td><td>tensor</td><td></td><td></td><td><p>Attr <code>value</code> is the tensor to return.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td></td></tr></table><a name="ControlTrigger"></a><h2>TensorFlow <code>ControlTrigger</code> Operation</h2><h3>Description</h3><p>Only useful as a placeholder for control edges.</p>
<a name="Conv2D"></a><h2>TensorFlow <code>Conv2D</code> Operation</h2><h3>Description</h3><p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>, this op
performs the following:</p>

<ol>
<li>Flattens the filter to a 2-D matrix with shape
<code>[filter_height * filter_width * in_channels, output_channels]</code>.</li>
<li>Extracts image patches from the input tensor to form a <em>virtual</em>
tensor of shape <code>[batch, out_height, out_width,
filter_height * filter_width * in_channels]</code>.</li>
<li>For each patch, right-multiplies the filter matrix and the image patch
vector.</li>
</ol>

<p>In detail, with the default NHWC format,</p>

<pre><code>output[b, i, j, k] =
    sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *
                    filter[di, dj, q, k]
</code></pre>

<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td></td><td><p>1-D of length 4.  The stride of the sliding window for each dimension
of <code>input</code>. Must be in the same order as the dimension specified with format.</p>
</td></tr><tr><td>use_cudnn_on_gpu</td><td>bool</td><td>b: true
</td><td></td><td></td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Conv2DBackpropFilter"></a><h2>TensorFlow <code>Conv2DBackpropFilter</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td></td><td><p>The stride of the sliding window for each dimension of the input
of the convolution. Must be in the same order as the dimension specified with
format.</p>
</td></tr><tr><td>use_cudnn_on_gpu</td><td>bool</td><td>b: true
</td><td></td><td></td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</p>
</td></tr><tr><td><code>filter_sizes</code></td><td>DT_INT32</td><td></td><td><p>An integer vector representing the tensor shape of <code>filter</code>,
where <code>filter</code> is a 4-D
<code>[filter_height, filter_width, in_channels, out_channels]</code> tensor.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
Gradients w.r.t. the output of the convolution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
the <code>filter</code> input of the convolution.</p>
</td></tr></table><a name="Conv2DBackpropInput"></a><h2>TensorFlow <code>Conv2DBackpropInput</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td></td><td><p>The stride of the sliding window for each dimension of the input
of the convolution. Must be in the same order as the dimension specified with
format.</p>
</td></tr><tr><td>use_cudnn_on_gpu</td><td>bool</td><td>b: true
</td><td></td><td></td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_sizes</code></td><td>DT_INT32</td><td></td><td><p>An integer vector representing the shape of <code>input</code>,
where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
Gradients w.r.t. the output of the convolution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
w.r.t. the input of the convolution.</p>
</td></tr></table><a name="Conv3D"></a><h2>TensorFlow <code>Conv3D</code> Operation</h2><h3>Description</h3><p>In signal processing, cross-correlation is a measure of similarity of
two waveforms as a function of a time-lag applied to one of them. This
is also known as a sliding dot product or sliding inner-product.</p>

<p>Our Conv3D implements a form of cross-correlation.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[batch, in_depth, in_height, in_width, in_channels]</code>.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[filter_depth, filter_height, filter_width, in_channels,
out_channels]</code>. <code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Conv3DBackpropFilter"></a><h2>TensorFlow <code>Conv3DBackpropFilter</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[batch, depth, rows, cols, in_channels]</code>.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
<code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
out_channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Conv3DBackpropFilterV2"></a><h2>TensorFlow <code>Conv3DBackpropFilterV2</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[batch, depth, rows, cols, in_channels]</code>.</p>
</td></tr><tr><td><code>filter_sizes</code></td><td>DT_INT32</td><td></td><td><p>An integer vector representing the tensor shape of <code>filter</code>,
where <code>filter</code> is a 5-D
<code>[filter_depth, filter_height, filter_width, in_channels, out_channels]</code>
tensor.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
out_channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Conv3DBackpropInput"></a><h2>TensorFlow <code>Conv3DBackpropInput</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[batch, depth, rows, cols, in_channels]</code>.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
<code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
out_channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Conv3DBackpropInputV2"></a><h2>TensorFlow <code>Conv3DBackpropInputV2</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_sizes</code></td><td>DT_INT32</td><td></td><td><p>An integer vector representing the tensor shape of <code>input</code>,
where <code>input</code> is a 5-D
<code>[batch, depth, rows, cols, in_channels]</code> tensor.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[depth, rows, cols, in_channels, out_channels]</code>.
<code>in_channels</code> must match between <code>input</code> and <code>filter</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Backprop signal of shape <code>[batch, out_depth, out_rows, out_cols,
out_channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Copy"></a><h2>TensorFlow <code>Copy</code> Operation</h2><h3>Description</h3><p>Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the
device on which the tensor is allocated.</p>

<p>Unlike the CopyHost Op, this op does not have HostMemory constraint on its
input or output.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>The name of the input tensor.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Input tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output tensor, deep-copied from input.</p>
</td></tr></table><a name="CopyHost"></a><h2>TensorFlow <code>CopyHost</code> Operation</h2><h3>Description</h3><p>Performs CPU-to-CPU deep-copying of tensor.</p>

<p>Unlike the Copy Op, this op has HostMemory constraint on its input or output.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>The name of the input tensor.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Input tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output tensor, deep-copied from input.</p>
</td></tr></table><a name="Cos"></a><h2>TensorFlow <code>Cos</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="CountUpTo"></a><h2>TensorFlow <code>CountUpTo</code> Operation</h2><h3>Description</h3><p>This operation outputs &quot;ref&quot; after the update is done.  This makes it
easier to chain operations that need to use the updated value.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>limit</td><td>int</td><td></td><td></td><td><p>If incrementing ref would bring it above limit, instead generates an
&#39;OutOfRange&#39; error.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a scalar <code>Variable</code> node.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A copy of the input before increment. If nothing else modifies the
input, the values produced will all be distinct.</p>
</td></tr></table><a name="CropAndResize"></a><h2>TensorFlow <code>CropAndResize</code> Operation</h2><h3>Description</h3><p>with aspect ratio change) to a common output size specified by <code>crop_size</code>. This
is more general than the <code>crop_to_bounding_box</code> op which extracts a fixed size
slice from the input image and does not allow resizing or aspect ratio change.</p>

<p>Returns a tensor with <code>crops</code> from the input <code>image</code> at positions defined at the
bounding box locations in <code>boxes</code>. The cropped boxes are all resized (with
bilinear interpolation) to a fixed <code>size = [crop_height, crop_width]</code>. The
result is a 4-D tensor <code>[num_boxes, crop_height, crop_width, depth]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>method</td><td>string</td><td>s: &quot;bilinear&quot;
</td><td><b>One of: </b><ul><li><code>bilinear</code></li></ul></td><td><p>A string specifying the interpolation method. Only &#39;bilinear&#39; is
supported for now.</p>
</td></tr><tr><td>extrapolation_value</td><td>float</td><td>f: 0
</td><td></td><td><p>Value used for extrapolation, when applicable.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 4-D tensor of shape <code>[batch, image_height, image_width, depth]</code>.
Both <code>image_height</code> and <code>image_width</code> need to be positive.</p>
</td></tr><tr><td><code>boxes</code></td><td>DT_FLOAT</td><td></td><td><p>A 2-D tensor of shape <code>[num_boxes, 4]</code>. The <code>i</code>-th row of the tensor
specifies the coordinates of a box in the <code>box_ind[i]</code> image and is specified
in normalized coordinates <code>[y1, x1, y2, x2]</code>. A normalized coordinate value of
<code>y</code> is mapped to the image coordinate at <code>y * (image_height - 1)</code>, so as the
<code>[0, 1]</code> interval of normalized image height is mapped to
<code>[0, image_height - 1] in image height coordinates. We do allow y1 &gt; y2, in
which case the sampled crop is an up-down flipped version of the original
image. The width dimension is treated similarly. Normalized coordinates
outside the</code>[0, 1]<code>range are allowed, in which case we use
</code>extrapolation_value` to extrapolate the input image values.</p>
</td></tr><tr><td><code>box_ind</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor of shape <code>[num_boxes]</code> with int32 values in <code>[0, batch)</code>.
The value of <code>box_ind[i]</code> specifies the image that the <code>i</code>-th box refers to.</p>
</td></tr><tr><td><code>crop_size</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor of 2 elements, <code>size = [crop_height, crop_width]</code>. All
cropped image patches are resized to this size. The aspect ratio of the image
content is not preserved. Both <code>crop_height</code> and <code>crop_width</code> need to be
positive.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>crops</code></td><td>DT_FLOAT</td><td></td><td><p>A 4-D tensor of shape <code>[num_boxes, crop_height, crop_width, depth]</code>.</p>
</td></tr></table><a name="CropAndResizeGradBoxes"></a><h2>TensorFlow <code>CropAndResizeGradBoxes</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>method</td><td>string</td><td>s: &quot;bilinear&quot;
</td><td><b>One of: </b><ul><li><code>bilinear</code></li></ul></td><td><p>A string specifying the interpolation method. Only &#39;bilinear&#39; is
supported for now.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grads</code></td><td>DT_FLOAT</td><td></td><td><p>A 4-D tensor of shape <code>[num_boxes, crop_height, crop_width, depth]</code>.</p>
</td></tr><tr><td><code>image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 4-D tensor of shape <code>[batch, image_height, image_width, depth]</code>.
Both <code>image_height</code> and <code>image_width</code> need to be positive.</p>
</td></tr><tr><td><code>boxes</code></td><td>DT_FLOAT</td><td></td><td><p>A 2-D tensor of shape <code>[num_boxes, 4]</code>. The <code>i</code>-th row of the tensor
specifies the coordinates of a box in the <code>box_ind[i]</code> image and is specified
in normalized coordinates <code>[y1, x1, y2, x2]</code>. A normalized coordinate value of
<code>y</code> is mapped to the image coordinate at <code>y * (image_height - 1)</code>, so as the
<code>[0, 1]</code> interval of normalized image height is mapped to
<code>[0, image_height - 1] in image height coordinates. We do allow y1 &gt; y2, in
which case the sampled crop is an up-down flipped version of the original
image. The width dimension is treated similarly. Normalized coordinates
outside the</code>[0, 1]<code>range are allowed, in which case we use
</code>extrapolation_value` to extrapolate the input image values.</p>
</td></tr><tr><td><code>box_ind</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor of shape <code>[num_boxes]</code> with int32 values in <code>[0, batch)</code>.
The value of <code>box_ind[i]</code> specifies the image that the <code>i</code>-th box refers to.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_FLOAT</td><td></td><td><p>A 2-D tensor of shape <code>[num_boxes, 4]</code>.</p>
</td></tr></table><a name="CropAndResizeGradImage"></a><h2>TensorFlow <code>CropAndResizeGradImage</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>method</td><td>string</td><td>s: &quot;bilinear&quot;
</td><td><b>One of: </b><ul><li><code>bilinear</code></li></ul></td><td><p>A string specifying the interpolation method. Only &#39;bilinear&#39; is
supported for now.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grads</code></td><td>DT_FLOAT</td><td></td><td><p>A 4-D tensor of shape <code>[num_boxes, crop_height, crop_width, depth]</code>.</p>
</td></tr><tr><td><code>boxes</code></td><td>DT_FLOAT</td><td></td><td><p>A 2-D tensor of shape <code>[num_boxes, 4]</code>. The <code>i</code>-th row of the tensor
specifies the coordinates of a box in the <code>box_ind[i]</code> image and is specified
in normalized coordinates <code>[y1, x1, y2, x2]</code>. A normalized coordinate value of
<code>y</code> is mapped to the image coordinate at <code>y * (image_height - 1)</code>, so as the
<code>[0, 1]</code> interval of normalized image height is mapped to
<code>[0, image_height - 1] in image height coordinates. We do allow y1 &gt; y2, in
which case the sampled crop is an up-down flipped version of the original
image. The width dimension is treated similarly. Normalized coordinates
outside the</code>[0, 1]<code>range are allowed, in which case we use
</code>extrapolation_value` to extrapolate the input image values.</p>
</td></tr><tr><td><code>box_ind</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor of shape <code>[num_boxes]</code> with int32 values in <code>[0, batch)</code>.
The value of <code>box_ind[i]</code> specifies the image that the <code>i</code>-th box refers to.</p>
</td></tr><tr><td><code>image_size</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor with value <code>[batch, image_height, image_width, depth]</code>
containing the original image size. Both <code>image_height</code> and <code>image_width</code> need
to be positive.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A 4-D tensor of shape <code>[batch, image_height, image_width, depth]</code>.</p>
</td></tr></table><a name="Cross"></a><h2>TensorFlow <code>Cross</code> Operation</h2><h3>Description</h3><p><code>a</code> and <code>b</code> must be the same shape; they can either be simple 3-element vectors,
or any shape where the innermost dimension is 3. In the latter case, each pair
of corresponding 3-element vectors is cross-multiplied independently.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor containing 3-element vectors.</p>
</td></tr><tr><td><code>b</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Another tensor, of same type and shape as <code>a</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>product</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Pairwise cross product of the vectors in <code>a</code> and <code>b</code>.</p>
</td></tr></table><a name="Cumprod"></a><h2>TensorFlow <code>Cumprod</code> Operation</h2><h3>Description</h3><p>By default, this op performs an inclusive cumprod, which means that the first
element of the input is identical to the first element of the output:
<code>prettyprint
tf.cumprod([a, b, c]) ==&gt; [a, a * b, a * b * c]
</code></p>

<p>By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumprod is
performed instead:
<code>prettyprint
tf.cumprod([a, b, c], exclusive=True) ==&gt; [0, a, a * b]
</code></p>

<p>By setting the <code>reverse</code> kwarg to <code>True</code>, the cumprod is performed in the
opposite direction:
<code>prettyprint
tf.cumprod([a, b, c], reverse=True) ==&gt; [a * b * c, b * c, c]
</code>
This is more efficient than using separate <code>tf.reverse</code> ops.</p>

<p>The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:
<code>prettyprint
tf.cumprod([a, b, c], exclusive=True, reverse=True) ==&gt; [b * c, c, 0]
</code></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>exclusive</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>reverse</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>axis</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Cumsum"></a><h2>TensorFlow <code>Cumsum</code> Operation</h2><h3>Description</h3><p>By default, this op performs an inclusive cumsum, which means that the first
element of the input is identical to the first element of the output:
<code>prettyprint
tf.cumsum([a, b, c]) ==&gt; [a, a + b, a + b + c]
</code></p>

<p>By setting the <code>exclusive</code> kwarg to <code>True</code>, an exclusive cumsum is
performed instead:
<code>prettyprint
tf.cumsum([a, b, c], exclusive=True) ==&gt; [0, a, a + b]
</code></p>

<p>By setting the <code>reverse</code> kwarg to <code>True</code>, the cumsum is performed in the
opposite direction:
<code>prettyprint
tf.cumsum([a, b, c], reverse=True) ==&gt; [a + b + c, b + c, c]
</code>
This is more efficient than using separate <code>tf.reverse</code> ops.</p>

<p>The <code>reverse</code> and <code>exclusive</code> kwargs can also be combined:
<code>prettyprint
tf.cumsum([a, b, c], exclusive=True, reverse=True) ==&gt; [b + c, c, 0]
</code></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>exclusive</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>reverse</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>axis</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="DebugIdentity"></a><h2>TensorFlow <code>DebugIdentity</code> Operation</h2><h3>Description</h3><p>Provides an identity mapping of the non-Ref type input tensor for debugging.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>Name of the input tensor.</p>
</td></tr><tr><td>debug_urls</td><td>list(string)</td><td>list {
}
</td><td></td><td><p>List of URLs to debug targets, e.g.,
file:///foo/tfdbg_dump, grpc:://localhost:11011</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Input tensor, non-Reference type.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output tensor that equals the input tensor.</p>
</td></tr></table><a name="DebugNanCount"></a><h2>TensorFlow <code>DebugNanCount</code> Operation</h2><h3>Description</h3><p>Counts number of NaNs in the input tensor, for debugging.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>Name of the input tensor.</p>
</td></tr><tr><td>debug_urls</td><td>list(string)</td><td>list {
}
</td><td></td><td><p>List of URLs to debug targets, e.g.,
file:///foo/tfdbg_dump, grpc:://localhost:11011</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Input tensor, non-Reference type.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td><p>An integer output tensor that is the number of NaNs in the input.</p>
</td></tr></table><a name="DecodeCSV"></a><h2>TensorFlow <code>DecodeCSV</code> Operation</h2><h3>Description</h3><p>RFC 4180 format is expected for the CSV records.
(https://tools.ietf.org/html/rfc4180)
Note that we allow leading and trailing spaces with int or float field.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>OUT_TYPE</td><td>list(type)</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>1</td><td></td></tr><tr><td>field_delim</td><td>string</td><td>s: &quot;,&quot;
</td><td></td><td><p>delimiter to separate fields in a record.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>records</code></td><td>DT_STRING</td><td></td><td><p>Each string is a record/row in the csv and all records should have
the same format.</p>
</td></tr><tr><td><code>record_defaults</code></td><td><b>type list: </b><code>OUT_TYPE</code></td><td></td><td><p>One tensor per column of the input record, with either a
scalar default value for that column or empty if the column is required.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>type list: </b><code>OUT_TYPE</code></td><td></td><td><p>Each tensor will have the same shape as records.</p>
</td></tr></table><a name="DecodeGif"></a><h2>TensorFlow <code>DecodeGif</code> Operation</h2><h3>Description</h3><p>GIF with frame or transparency compression are not supported
convert animated GIF from compressed to uncompressed by:</p>

<p>convert $src.gif -coalesce $dst.gif</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>contents</code></td><td>DT_STRING</td><td></td><td><p>0-D.  The GIF-encoded image.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td>DT_UINT8</td><td></td><td><p>4-D with shape <code>[num_frames, height, width, 3]</code>. RGB order</p>
</td></tr></table><a name="DecodeJSONExample"></a><h2>TensorFlow <code>DecodeJSONExample</code> Operation</h2><h3>Description</h3><p>This op translates a tensor containing Example records, encoded using
the <a href="https://developers.google.com/protocol-buffers/docs/proto3#json" target="_blank">standard JSON
mapping</a>,
into a tensor containing the same records encoded as binary protocol
buffers. The resulting tensor can then be fed to any of the other
Example-parsing ops.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>json_examples</code></td><td>DT_STRING</td><td></td><td><p>Each string is a JSON object serialized according to the JSON
mapping of the Example proto.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>binary_examples</code></td><td>DT_STRING</td><td></td><td><p>Each string is a binary Example protocol buffer corresponding
to the respective element of <code>json_examples</code>.</p>
</td></tr></table><a name="DecodeJpeg"></a><h2>TensorFlow <code>DecodeJpeg</code> Operation</h2><h3>Description</h3><p>The attr <code>channels</code> indicates the desired number of color channels for the
decoded image.</p>

<p>Accepted values are:</p>

<ul>
<li>  0: Use the number of channels in the JPEG-encoded image.</li>
<li>  1: output a grayscale image.</li>
<li>  3: output an RGB image.</li>
</ul>

<p>If needed, the JPEG-encoded image is transformed to match the requested number
of color channels.</p>

<p>The attr <code>ratio</code> allows downscaling the image by an integer factor during
decoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than
downscaling the image later.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>channels</td><td>int</td><td>i: 0
</td><td></td><td><p>Number of color channels for the decoded image.</p>
</td></tr><tr><td>ratio</td><td>int</td><td>i: 1
</td><td></td><td><p>Downscaling ratio.</p>
</td></tr><tr><td>fancy_upscaling</td><td>bool</td><td>b: true
</td><td></td><td><p>If true use a slower but nicer upscaling of the
chroma planes (yuv420/422 only).</p>
</td></tr><tr><td>try_recover_truncated</td><td>bool</td><td>b: false
</td><td></td><td><p>If true try to recover an image from truncated input.</p>
</td></tr><tr><td>acceptable_fraction</td><td>float</td><td>f: 1
</td><td></td><td><p>The minimum required fraction of lines before a truncated
input is accepted.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>contents</code></td><td>DT_STRING</td><td></td><td><p>0-D.  The JPEG-encoded image.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td>DT_UINT8</td><td></td><td><p>3-D with shape <code>[height, width, channels]</code>..</p>
</td></tr></table><a name="DecodePng"></a><h2>TensorFlow <code>DecodePng</code> Operation</h2><h3>Description</h3><p>The attr <code>channels</code> indicates the desired number of color channels for the
decoded image.</p>

<p>Accepted values are:</p>

<ul>
<li>  0: Use the number of channels in the PNG-encoded image.</li>
<li>  1: output a grayscale image.</li>
<li>  3: output an RGB image.</li>
<li>  4: output an RGBA image.</li>
</ul>

<p>If needed, the PNG-encoded image is transformed to match the requested number
of color channels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>channels</td><td>int</td><td>i: 0
</td><td></td><td><p>Number of color channels for the decoded image.</p>
</td></tr><tr><td>dtype</td><td>type</td><td>type: DT_UINT8
</td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>contents</code></td><td>DT_STRING</td><td></td><td><p>0-D.  The PNG-encoded image.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>3-D with shape <code>[height, width, channels]</code>.</p>
</td></tr></table><a name="DecodeRaw"></a><h2>TensorFlow <code>DecodeRaw</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>out_type</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>little_endian</td><td>bool</td><td>b: true
</td><td></td><td><p>Whether the input <code>bytes</code> are in little-endian order.
Ignored for <code>out_type</code> values that are stored in a single byte like
<code>uint8</code>.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>bytes</code></td><td>DT_STRING</td><td></td><td><p>All the elements must have the same length.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>out_type</code></td><td></td><td><p>A Tensor with one more dimension than the input <code>bytes</code>.  The
added dimension will have size equal to the length of the elements
of <code>bytes</code> divided by the number of bytes to represent <code>out_type</code>.</p>
</td></tr></table><a name="DeleteSessionTensor"></a><h2>TensorFlow <code>DeleteSessionTensor</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle for a tensor stored in the session state.</p>
</td></tr></table><a name="DepthToSpace"></a><h2>TensorFlow <code>DepthToSpace</code> Operation</h2><h3>Description</h3><p>Rearranges data from depth into blocks of spatial data.
This is the reverse transformation of SpaceToDepth. More specifically,
this op outputs a copy of the input tensor where values from the <code>depth</code>
dimension are moved in spatial blocks to the <code>height</code> and <code>width</code> dimensions.
The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>

<ul>
<li>Chunks of data of size <code>block_size * block_size</code> from depth are rearranged
into non-overlapping blocks of size <code>block_size x block_size</code></li>
<li>The width the output tensor is <code>input_depth * block_size</code>, whereas the
height is <code>input_height * block_size</code>.</li>
<li>The depth of the input tensor must be divisible by
<code>block_size * block_size</code>.</li>
</ul>

<p>That is, assuming the input is in the shape:
<code>[batch, height, width, depth]</code>,
the shape of the output will be:
<code>[batch, height*block_size, width*block_size, depth/(block_size*block_size)]</code></p>

<p>This operation requires that the input tensor be of rank 4, and that
<code>block_size</code> be &gt;=1 and that <code>block_size * block_size</code> be a divisor of the
input depth.</p>

<p>This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</p>

<p>For example, given this input of shape <code>[1, 1, 1, 4]</code>, and a block size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1, 2, 3, 4]]]]

</code></pre>

<p>This operation will output a tensor of shape <code>[1, 2, 2, 1]</code>:</p>

<pre><code class="language-prettyprint">   [[[[1], [2]],
     [[3], [4]]]]
</code></pre>

<p>Here, the input has a batch of 1 and each batch element has shape <code>[1, 1, 4]</code>,
the corresponding output will have 2x2 elements and will have a depth of
1 channel (1 = <code>4 / (block_size * block_size)</code>).
The output element shape is <code>[2, 2, 1]</code>.</p>

<p>For an input tensor with larger depth, here of shape <code>[1, 1, 1, 12]</code>, e.g.</p>

<pre><code class="language-prettyprint">x = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
</code></pre>

<p>This operation, for block size of 2, will return the following tensor of shape
<code>[1, 2, 2, 3]</code></p>

<pre><code class="language-prettyprint">   [[[[1, 2, 3], [4, 5, 6]],
     [[7, 8, 9], [10, 11, 12]]]]

</code></pre>

<p>Similarly, for the following input of shape <code>[1 2 2 4]</code>, and a block size of 2:</p>

<pre><code class="language-prettyprint">x =  [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]
</code></pre>

<p>the operator will return the following tensor of shape <code>[1 4 4 1]</code>:</p>

<pre><code class="language-prettyprint">x = [[ [1],   [2],  [5],  [6]],
     [ [3],   [4],  [7],  [8]],
     [ [9],  [10], [13],  [14]],
     [ [11], [12], [15],  [16]]]

</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>block_size</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td><p>The size of the spatial block, same as in Space2Depth.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="DepthwiseConv2dNative"></a><h2>TensorFlow <code>DepthwiseConv2dNative</code> Operation</h2><h3>Description</h3><p>Given an input tensor of shape <code>[batch, in_height, in_width, in_channels]</code>
and a filter / kernel tensor of shape
<code>[filter_height, filter_width, in_channels, channel_multiplier]</code>, containing
<code>in_channels</code> convolutional filters of depth 1, <code>depthwise_conv2d</code> applies
a different filter to each input channel (expanding from 1 channel to
<code>channel_multiplier</code> channels for each), then concatenates the results
together. Thus, the output has <code>in_channels * channel_multiplier</code> channels.</p>

<p>for k in 0..in<em>channels-1
  for q in 0..channel</em>multiplier-1
    output[b, i, j, k * channel<em>multiplier + q] =
      sum</em>{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *
                        filter[di, dj, k, q]</p>

<p>Must have <code>strides[0] = strides[3] = 1</code>.  For the most common case of the same
horizontal and vertices strides, <code>strides = [1, stride, stride, 1]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td></td><td><p>1-D of length 4.  The stride of the sliding window for each dimension
of <code>input</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="DepthwiseConv2dNativeBackpropFilter"></a><h2>TensorFlow <code>DepthwiseConv2dNativeBackpropFilter</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td></td><td><p>The stride of the sliding window for each dimension of the input
of the convolution.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.</p>
</td></tr><tr><td><code>filter_sizes</code></td><td>DT_INT32</td><td></td><td><p>An integer vector representing the tensor shape of <code>filter</code>,
where <code>filter</code> is a 4-D
<code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code> tensor.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
Gradients w.r.t. the output of the convolution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape
<code>[filter_height, filter_width, in_channels, out_channels]</code>.  Gradient w.r.t.
the <code>filter</code> input of the convolution.</p>
</td></tr></table><a name="DepthwiseConv2dNativeBackpropInput"></a><h2>TensorFlow <code>DepthwiseConv2dNativeBackpropInput</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td></td><td><p>The stride of the sliding window for each dimension of the input
of the convolution.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_sizes</code></td><td>DT_INT32</td><td></td><td><p>An integer vector representing the shape of <code>input</code>,
where <code>input</code> is a 4-D <code>[batch, height, width, channels]</code> tensor.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape
<code>[filter_height, filter_width, in_channels, depthwise_multiplier]</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, out_channels]</code>.
Gradients w.r.t. the output of the convolution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, in_channels]</code>.  Gradient
w.r.t. the input of the convolution.</p>
</td></tr></table><a name="DeserializeManySparse"></a><h2>TensorFlow <code>DeserializeManySparse</code> Operation</h2><h3>Description</h3><p>The input <code>serialized_sparse</code> must be a string matrix of shape <code>[N x 3]</code> where
<code>N</code> is the minibatch size and the rows correspond to packed outputs of
<code>SerializeSparse</code>.  The ranks of the original <code>SparseTensor</code> objects
must all match.  When the final <code>SparseTensor</code> is created, it has rank one
higher than the ranks of the incoming <code>SparseTensor</code> objects
(they have been concatenated along a new row dimension).</p>

<p>The output <code>SparseTensor</code> object&#39;s shape values for all dimensions but the
first are the max across the input <code>SparseTensor</code> objects&#39; shape values
for the corresponding dimensions.  Its first shape value is <code>N</code>, the minibatch
size.</p>

<p>The input <code>SparseTensor</code> objects&#39; indices are assumed ordered in
standard lexicographic order.  If this is not the case, after this
step run <code>SparseReorder</code> to restore index ordering.</p>

<p>For example, if the serialized input is a <code>[2 x 3]</code> matrix representing two
original <code>SparseTensor</code> objects:</p>

<pre><code>index = [ 0]
        [10]
        [20]
values = [1, 2, 3]
shape = [50]
</code></pre>

<p>and</p>

<pre><code>index = [ 2]
        [10]
values = [4, 5]
shape = [30]
</code></pre>

<p>then the final deserialized <code>SparseTensor</code> will be:</p>

<pre><code>index = [0  0]
        [0 10]
        [0 20]
        [1  2]
        [1 10]
values = [1, 2, 3, 4, 5]
shape = [2 50]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The <code>dtype</code> of the serialized <code>SparseTensor</code> objects.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>serialized_sparse</code></td><td>DT_STRING</td><td></td><td><p>2-D, The <code>N</code> serialized <code>SparseTensor</code> objects.
Must have 3 columns.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sparse_indices</code></td><td>DT_INT64</td><td></td><td></td></tr><tr><td><code>sparse_values</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td></td></tr><tr><td><code>sparse_shape</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="DestroyTemporaryVariable"></a><h2>TensorFlow <code>DestroyTemporaryVariable</code> Operation</h2><h3>Description</h3><p>Sets output to the value of the Tensor pointed to by &#39;ref&#39;, then destroys
the temporary variable called &#39;var_name&#39;.
All other uses of &#39;ref&#39; <em>must</em> have executed before this op.
This is typically achieved by chaining the ref through each assign op, or by
using control dependencies.</p>

<p>Outputs the final value of the tensor pointed to by &#39;ref&#39;.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>var_name</td><td>string</td><td></td><td></td><td><p>Name of the temporary variable, usually the name of the matching
&#39;TemporaryVariable&#39; op.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A reference to the temporary variable tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Diag"></a><h2>TensorFlow <code>Diag</code> Operation</h2><h3>Description</h3><p>Given a <code>diagonal</code>, this operation returns a tensor with the <code>diagonal</code> and
everything else padded with zeros. The diagonal is computed as follows:</p>

<p>Assume <code>diagonal</code> has dimensions [D1,..., Dk], then the output is a tensor of
rank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:</p>

<p><code>output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]</code> and 0 everywhere else.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;diagonal&#39; is [1, 2, 3, 4]
tf.diag(diagonal) ==&gt; [[1, 0, 0, 0]
                       [0, 2, 0, 0]
                       [0, 0, 3, 0]
                       [0, 0, 0, 4]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>diagonal</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank k tensor where k is at most 3.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="DiagPart"></a><h2>TensorFlow <code>DiagPart</code> Operation</h2><h3>Description</h3><p>This operation returns a tensor with the <code>diagonal</code> part
of the <code>input</code>. The <code>diagonal</code> part is computed as follows:</p>

<p>Assume <code>input</code> has dimensions <code>[D1,..., Dk, D1,..., Dk]</code>, then the output is a
tensor of rank <code>k</code> with dimensions <code>[D1,..., Dk]</code> where:</p>

<p><code>diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;input&#39; is [[1, 0, 0, 0]
              [0, 2, 0, 0]
              [0, 0, 3, 0]
              [0, 0, 0, 4]]

tf.diag_part(input) ==&gt; [1, 2, 3, 4]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Rank k tensor where k is 2, 4, or 6.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>diagonal</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The extracted diagonal.</p>
</td></tr></table><a name="Digamma"></a><h2>TensorFlow <code>Digamma</code> Operation</h2><h3>Description</h3><p><code>Gamma(x)</code>), element-wise.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Dilation2D"></a><h2>TensorFlow <code>Dilation2D</code> Operation</h2><h3>Description</h3><p>The <code>input</code> tensor has shape <code>[batch, in_height, in_width, depth]</code> and the
<code>filter</code> tensor has shape <code>[filter_height, filter_width, depth]</code>, i.e., each
input channel is processed independently of the others with its own structuring
function. The <code>output</code> tensor has shape
<code>[batch, out_height, out_width, depth]</code>. The spatial dimensions of the output
tensor depend on the <code>padding</code> algorithm. We currently only support the default
&quot;NHWC&quot; <code>data_format</code>.</p>

<p>In detail, the grayscale morphological 2-D dilation is the max-sum correlation
(for consistency with <code>conv2d</code>, we use unmirrored filters):</p>

<pre><code>output[b, y, x, c] =
   max_{dy, dx} input[b,
                      strides[1] * y + rates[1] * dy,
                      strides[2] * x + rates[2] * dx,
                      c] +
                filter[dy, dx, c]
</code></pre>

<p>Max-pooling is a special case when the filter has size equal to the pooling
kernel size and contains all zeros.</p>

<p>Note on duality: The dilation of <code>input</code> by the <code>filter</code> is equal to the
negation of the erosion of <code>-input</code> by the reflected <code>filter</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of the input
tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</p>
</td></tr><tr><td>rates</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The input stride for atrous morphological dilation. Must be:
<code>[1, rate_height, rate_width, 1]</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
</td></tr></table><a name="Dilation2DBackpropFilter"></a><h2>TensorFlow <code>Dilation2DBackpropFilter</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>1-D of length 4. The stride of the sliding window for each dimension of
the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</p>
</td></tr><tr><td>rates</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>1-D of length 4. The input stride for atrous morphological dilation.
Must be: <code>[1, rate_height, rate_width, 1]</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filter_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td></tr></table><a name="Dilation2DBackpropInput"></a><h2>TensorFlow <code>Dilation2DBackpropInput</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>1-D of length 4. The stride of the sliding window for each dimension of
the input tensor. Must be: <code>[1, stride_height, stride_width, 1]</code>.</p>
</td></tr><tr><td>rates</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>1-D of length 4. The input stride for atrous morphological dilation.
Must be: <code>[1, rate_height, rate_width, 1]</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td></tr><tr><td><code>filter</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D with shape <code>[filter_height, filter_width, depth]</code>.</p>
</td></tr><tr><td><code>out_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, out_height, out_width, depth]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>in_backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, in_height, in_width, depth]</code>.</p>
</td></tr></table><a name="Div"></a><h2>TensorFlow <code>Div</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Div</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="DrawBoundingBoxes"></a><h2>TensorFlow <code>DrawBoundingBoxes</code> Operation</h2><h3>Description</h3><p>Outputs a copy of <code>images</code> but draws on top of the pixels zero or more bounding
boxes specified by the locations in <code>boxes</code>. The coordinates of the each
bounding box in <code>boxes</code> are encoded as <code>[y_min, x_min, y_max, x_max]</code>. The
bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and
height of the underlying image.</p>

<p>For example, if an image is 100 x 200 pixels and the bounding box is
<code>[0.1, 0.5, 0.2, 0.9]</code>, the bottom-left and upper-right coordinates of the
bounding box will be <code>(10, 40)</code> to <code>(50, 180)</code>.</p>

<p>Parts of the bounding box may fall outside the image.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, depth]</code>. A batch of images.</p>
</td></tr><tr><td><code>boxes</code></td><td>DT_FLOAT</td><td></td><td><p>3-D with shape <code>[batch, num_bounding_boxes, 4]</code> containing bounding
boxes.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with the same shape as <code>images</code>. The batch of input images with
bounding boxes drawn on the images.</p>
</td></tr></table><a name="DynamicPartition"></a><h2>TensorFlow <code>DynamicPartition</code> Operation</h2><h3>Description</h3><p>For each index tuple <code>js</code> of size <code>partitions.ndim</code>, the slice <code>data[js, ...]</code>
becomes part of <code>outputs[partitions[js]]</code>.  The slices with <code>partitions[js] = i</code>
are placed in <code>outputs[i]</code> in lexicographic order of <code>js</code>, and the first
dimension of <code>outputs[i]</code> is the number of entries in <code>partitions</code> equal to <code>i</code>.
In detail,</p>

<pre><code>outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]

outputs[i] = pack([data[js, ...] for js if partitions[js] == i])
</code></pre>

<p><code>data.shape</code> must start with <code>partitions.shape</code>.</p>

<p>For example:</p>

<pre><code># Scalar partitions
partitions = 1
num_partitions = 2
data = [10, 20]
outputs[0] = []  # Empty with shape [0, 2]
outputs[1] = [[10, 20]]

# Vector partitions
partitions = [0, 0, 1, 1, 0]
num_partitions = 2
data = [10, 20, 30, 40, 50]
outputs[0] = [10, 20, 50]
outputs[1] = [30, 40]
</code></pre>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicPartition.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_partitions</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The number of partitions to output.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>partitions</code></td><td>DT_INT32</td><td></td><td><p>Any shape.  Indices in the range <code>[0, num_partitions)</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>outputs</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>num_partitions</p>
</code></td><td></td></tr></table><a name="DynamicStitch"></a><h2>TensorFlow <code>DynamicStitch</code> Operation</h2><h3>Description</h3><p>Builds a merged tensor such that</p>

<pre><code>merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]
</code></pre>

<p>For example, if each <code>indices[m]</code> is scalar or vector, we have</p>

<pre><code># Scalar indices
merged[indices[m], ...] = data[m][...]

# Vector indices
merged[indices[m][i], ...] = data[m][i, ...]
</code></pre>

<p>Each <code>data[i].shape</code> must start with the corresponding <code>indices[i].shape</code>,
and the rest of <code>data[i].shape</code> must be constant w.r.t. <code>i</code>.  That is, we
must have <code>data[i].shape = indices[i].shape + constant</code>.  In terms of this
<code>constant</code>, the output shape is</p>

<pre><code>merged.shape = [max(indices)] + constant
</code></pre>

<p>Values are merged in order, so if an index appears in both <code>indices[m][i]</code> and
<code>indices[n][j]</code> for <code>(m,i) &lt; (n,j)</code> the slice <code>data[n][j]</code> will appear in the
merged result.</p>

<p>For example:</p>

<pre><code>indices[0] = 6
indices[1] = [4, 1]
indices[2] = [[5, 2], [0, 3]]
data[0] = [61, 62]
data[1] = [[41, 42], [11, 12]]
data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]
merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],
          [51, 52], [61, 62]]
</code></pre>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/DynamicStitch.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td><b>number: </b><code><p>N</p>
</code></td><td></td></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>merged</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="EditDistance"></a><h2>TensorFlow <code>EditDistance</code> Operation</h2><h3>Description</h3><p>The inputs are variable-length sequences provided by SparseTensors
  (hypothesis<em>indices, hypothesis</em>values, hypothesis<em>shape)
and
  (truth</em>indices, truth<em>values, truth</em>shape).</p>

<p>The inputs are:</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>normalize</td><td>bool</td><td>b: true
</td><td></td><td><p>boolean (if true, edit distances are normalized by length of truth).</p>

<p>The output is:</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>hypothesis_indices</code></td><td>DT_INT64</td><td></td><td><p>The indices of the hypothesis list SparseTensor.
This is an N x R int64 matrix.</p>
</td></tr><tr><td><code>hypothesis_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The values of the hypothesis list SparseTensor.
This is an N-length vector.</p>
</td></tr><tr><td><code>hypothesis_shape</code></td><td>DT_INT64</td><td></td><td><p>The shape of the hypothesis list SparseTensor.
This is an R-length vector.</p>
</td></tr><tr><td><code>truth_indices</code></td><td>DT_INT64</td><td></td><td><p>The indices of the truth list SparseTensor.
This is an M x R int64 matrix.</p>
</td></tr><tr><td><code>truth_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The values of the truth list SparseTensor.
This is an M-length vector.</p>
</td></tr><tr><td><code>truth_shape</code></td><td>DT_INT64</td><td></td><td><p>truth indices, vector.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_FLOAT</td><td></td><td><p>A dense float tensor with rank R - 1.</p>

<p>For the example input:</p>

<pre><code>// hypothesis represents a 2x1 matrix with variable-length values:
//   (0,0) = [&quot;a&quot;]
//   (1,0) = [&quot;b&quot;]
hypothesis_indices = [[0, 0, 0],
                      [1, 0, 0]]
hypothesis_values = [&quot;a&quot;, &quot;b&quot;]
hypothesis_shape = [2, 1, 1]

// truth represents a 2x2 matrix with variable-length values:
//   (0,0) = []
//   (0,1) = [&quot;a&quot;]
//   (1,0) = [&quot;b&quot;, &quot;c&quot;]
//   (1,1) = [&quot;a&quot;]
truth_indices = [[0, 1, 0],
                 [1, 0, 0],
                 [1, 0, 1],
                 [1, 1, 0]]
truth_values = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
truth_shape = [2, 2, 2]
normalize = true
</code></pre>

<p>The output will be:</p>

<pre><code>// output is a 2x2 matrix with edit distances normalized by truth lengths.
output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis
          [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis
</code></pre>
</td></tr></table><a name="Elu"></a><h2>TensorFlow <code>Elu</code> Operation</h2><h3>Description</h3><p>See <a href="http://arxiv.org/abs/1511.07289" target="_blank">Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)
</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>activations</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="EluGrad"></a><h2>TensorFlow <code>EluGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>gradients</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The backpropagated gradients to the corresponding Elu operation.</p>
</td></tr><tr><td><code>outputs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The outputs of the corresponding Elu operation.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>backprops</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradients: <code>gradients * (outputs + 1)</code> if outputs &lt; 0,
<code>gradients</code> otherwise.</p>
</td></tr></table><a name="EncodeJpeg"></a><h2>TensorFlow <code>EncodeJpeg</code> Operation</h2><h3>Description</h3><p><code>image</code> is a 3-D uint8 Tensor of shape <code>[height, width, channels]</code>.</p>

<p>The attr <code>format</code> can be used to override the color format of the encoded
output.  Values can be:</p>

<ul>
<li>  <code>&#39;&#39;</code>: Use a default format based on the number of channels in the image.</li>
<li>  <code>grayscale</code>: Output a grayscale JPEG image.  The <code>channels</code> dimension
of <code>image</code> must be 1.</li>
<li>  <code>rgb</code>: Output an RGB JPEG image. The <code>channels</code> dimension
of <code>image</code> must be 3.</li>
</ul>

<p>If <code>format</code> is not specified or is the empty string, a default format is picked
in function of the number of channels in <code>image</code>:</p>

<ul>
<li>  1: Output a grayscale image.</li>
<li>  3: Output an RGB image.</li>
</ul>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>format</td><td>string</td><td>s: &quot;&quot;
</td><td><b>One of: </b><ul><li><code></code></li><li><code>grayscale</code></li><li><code>rgb</code></li></ul></td><td><p>Per pixel image format.</p>
</td></tr><tr><td>quality</td><td>int</td><td>i: 95
</td><td></td><td><p>Quality of the compression from 0 to 100 (higher is better and slower).</p>
</td></tr><tr><td>progressive</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, create a JPEG that loads progressively (coarse to fine).</p>
</td></tr><tr><td>optimize_size</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, spend CPU/RAM to reduce size with no quality change.</p>
</td></tr><tr><td>chroma_downsampling</td><td>bool</td><td>b: true
</td><td></td><td><p>See http://en.wikipedia.org/wiki/Chroma_subsampling.</p>
</td></tr><tr><td>density_unit</td><td>string</td><td>s: &quot;in&quot;
</td><td><b>One of: </b><ul><li><code>in</code></li><li><code>cm</code></li></ul></td><td><p>Unit used to specify <code>x_density</code> and <code>y_density</code>:
pixels per inch (<code>&#39;in&#39;</code>) or centimeter (<code>&#39;cm&#39;</code>).</p>
</td></tr><tr><td>x_density</td><td>int</td><td>i: 300
</td><td></td><td><p>Horizontal pixels per density unit.</p>
</td></tr><tr><td>y_density</td><td>int</td><td>i: 300
</td><td></td><td><p>Vertical pixels per density unit.</p>
</td></tr><tr><td>xmp_metadata</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If not empty, embed this XMP metadata in the image header.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td>DT_UINT8</td><td></td><td><p>3-D with shape <code>[height, width, channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>contents</code></td><td>DT_STRING</td><td></td><td><p>0-D. JPEG-encoded image.</p>
</td></tr></table><a name="EncodePng"></a><h2>TensorFlow <code>EncodePng</code> Operation</h2><h3>Description</h3><p><code>image</code> is a 3-D uint8 or uint16 Tensor of shape <code>[height, width, channels]</code>
where <code>channels</code> is:</p>

<ul>
<li>  1: for grayscale.</li>
<li>  2: for grayscale + alpha.</li>
<li>  3: for RGB.</li>
<li>  4: for RGBA.</li>
</ul>

<p>The ZLIB compression level, <code>compression</code>, can be -1 for the PNG-encoder
default or a value from 0 to 9.  9 is the highest compression level, generating
the smallest output, but is slower.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>compression</td><td>int</td><td>i: -1
</td><td></td><td><p>Compression level.</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_UINT8
</td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D with shape <code>[height, width, channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>contents</code></td><td>DT_STRING</td><td></td><td><p>0-D. PNG-encoded image.</p>
</td></tr></table><a name="Enter"></a><h2>TensorFlow <code>Enter</code> Operation</h2><h3>Description</h3><p>This op is used together with <code>Exit</code> to create loops in the graph.
The unique <code>frame_name</code> is used by the <code>Executor</code> to identify frames. If
<code>is_constant</code> is true, <code>output</code> is a constant in the child frame; otherwise
it may be changed in the child frame. At most <code>parallel_iterations</code> iterations
are run in parallel in the child frame.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>frame_name</td><td>string</td><td></td><td></td><td><p>The name of the child frame.</p>
</td></tr><tr><td>is_constant</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, the output is constant within the child frame.</p>
</td></tr><tr><td>parallel_iterations</td><td>int</td><td>i: 10
</td><td></td><td><p>The number of iterations allowed to run in parallel.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be made available to the child frame.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as <code>data</code>.</p>
</td></tr></table><a name="Equal"></a><h2>TensorFlow <code>Equal</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Equal</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_STRING</code></li><li><code>DT_BOOL</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="Erf"></a><h2>TensorFlow <code>Erf</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Erfc"></a><h2>TensorFlow <code>Erfc</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Exit"></a><h2>TensorFlow <code>Exit</code> Operation</h2><h3>Description</h3><p>Exit makes its input <code>data</code> available to the parent frame.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be made available to the parent frame.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as <code>data</code>.</p>
</td></tr></table><a name="Exp"></a><h2>TensorFlow <code>Exp</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="ExpandDims"></a><h2>TensorFlow <code>ExpandDims</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>input</code>, this operation inserts a dimension of 1 at the
dimension index <code>dim</code> of <code>input</code>&#39;s shape. The dimension index <code>dim</code> starts at
zero; if you specify a negative number for <code>dim</code> it is counted backward from
the end.</p>

<p>This operation is useful if you want to add a batch dimension to a single
element. For example, if you have a single image of shape <code>[height, width,
channels]</code>, you can make it a batch of 1 image with <code>expand_dims(image, 0)</code>,
which will make the shape <code>[1, height, width, channels]</code>.</p>

<p>Other examples:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is a tensor of shape [2]
shape(expand_dims(t, 0)) ==&gt; [1, 2]
shape(expand_dims(t, 1)) ==&gt; [2, 1]
shape(expand_dims(t, -1)) ==&gt; [2, 1]

# &#39;t2&#39; is a tensor of shape [2, 3, 5]
shape(expand_dims(t2, 0)) ==&gt; [1, 2, 3, 5]
shape(expand_dims(t2, 2)) ==&gt; [2, 3, 1, 5]
shape(expand_dims(t2, 3)) ==&gt; [2, 3, 5, 1]
</code></pre>

<p>This operation requires that:</p>

<p><code>-1-input.dims() &lt;= dim &lt;= input.dims()</code></p>

<p>This operation is related to <code>squeeze()</code>, which removes dimensions of
size 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>dim</code></td><td>DT_INT32</td><td></td><td><p>0-D (scalar). Specifies the dimension index at which to
expand the shape of <code>input</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Contains the same data as <code>input</code>, but its shape has an additional
dimension of size 1 added.</p>
</td></tr></table><a name="ExtractGlimpse"></a><h2>TensorFlow <code>ExtractGlimpse</code> Operation</h2><h3>Description</h3><p>Returns a set of windows called glimpses extracted at location
<code>offsets</code> from the input tensor. If the windows only partially
overlaps the inputs, the non overlapping areas will be filled with
random noise.</p>

<p>The result is a 4-D tensor of shape <code>[batch_size, glimpse_height,
glimpse_width, channels]</code>. The channels and batch dimensions are the
same as that of the input tensor. The height and width of the output
windows are specified in the <code>size</code> parameter.</p>

<p>The argument <code>normalized</code> and <code>centered</code> controls how the windows are built:</p>

<ul>
<li>If the coordinates are normalized but not centered, 0.0 and 1.0
correspond to the minimum and maximum of each height and width
dimension.</li>
<li>If the coordinates are both normalized and centered, they range from
-1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper
left corner, the lower right corner is located at (1.0, 1.0) and the
center is at (0, 0).</li>
<li>If the coordinates are not normalized they are interpreted as
numbers of pixels.</li>
</ul>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>centered</td><td>bool</td><td>b: true
</td><td></td><td><p>indicates if the offset coordinates are centered relative to
the image, in which case the (0, 0) offset is relative to the center
of the input images. If false, the (0,0) offset corresponds to the
upper left corner of the input images.</p>
</td></tr><tr><td>normalized</td><td>bool</td><td>b: true
</td><td></td><td><p>indicates if the offset coordinates are normalized.</p>
</td></tr><tr><td>uniform_noise</td><td>bool</td><td>b: true
</td><td></td><td><p>indicates if the noise should be generated using a
uniform distribution or a gaussian distribution.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_FLOAT</td><td></td><td><p>A 4-D float tensor of shape <code>[batch_size, height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor of 2 elements containing the size of the glimpses
to extract.  The glimpse height must be specified first, following
by the glimpse width.</p>
</td></tr><tr><td><code>offsets</code></td><td>DT_FLOAT</td><td></td><td><p>A 2-D integer tensor of shape <code>[batch_size, 2]</code> containing
the x, y locations of the center of each window.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>glimpse</code></td><td>DT_FLOAT</td><td></td><td><p>A tensor representing the glimpses <code>[batch_size,
glimpse_height, glimpse_width, channels]</code>.</p>
</td></tr></table><a name="ExtractImagePatches"></a><h2>TensorFlow <code>ExtractImagePatches</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksizes</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the sliding window for each dimension of <code>images</code>.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>1-D of length 4. How far the centers of two consecutive patches are in
the images. Must be: <code>[1, stride_rows, stride_cols, 1]</code>.</p>
</td></tr><tr><td>rates</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>1-D of length 4. Must be: <code>[1, rate_rows, rate_cols, 1]</code>. This is the
input stride, specifying how far two consecutive patch samples are in the
input. Equivalent to extracting patches with
<code>patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1), followed by
subsampling them spatially by a factor of</code>rates`.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>

<p>We specify the size-related attributes as:</p>

<pre><code>  ksizes = [1, ksize_rows, ksize_cols, 1]
  strides = [1, strides_rows, strides_cols, 1]
  rates = [1, rates_rows, rates_cols, 1]
</code></pre>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D Tensor with shape <code>[batch, in_rows, in_cols, depth]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>patches</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D Tensor with shape <code>[batch, out_rows, out_cols, ksize_rows *
ksize_cols * depth]</code> containing image patches with size
<code>ksize_rows x ksize_cols x depth</code> vectorized in the &quot;depth&quot; dimension.</p>
</td></tr></table><a name="FFT"></a><h2>TensorFlow <code>FFT</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 vector.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>The 1D Fourier Transform of <code>input</code>.</p>
</td></tr></table><a name="FFT2D"></a><h2>TensorFlow <code>FFT2D</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 matrix.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>The 2D Fourier Transform of <code>input</code>.</p>
</td></tr></table><a name="FFT3D"></a><h2>TensorFlow <code>FFT3D</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 3-D tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>The 3D Fourier Transform of <code>input</code>.</p>
</td></tr></table><a name="FIFOQueue"></a><h2>TensorFlow <code>FIFOQueue</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a value.</p>
</td></tr><tr><td>shapes</td><td>list(shape)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>The shape of each component in a value. The length of this attr must
be either 0 or the same as the length of component_types. If the length of
this attr is 0, the shapes of queue elements are not constrained, and
only one element may be dequeued at a time.</p>
</td></tr><tr><td>capacity</td><td>int</td><td>i: -1
</td><td></td><td><p>The upper bound on the number of elements in this queue.
Negative numbers mean no limit.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue will be shared under the given name
across multiple sessions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the queue.</p>
</td></tr></table><a name="Fill"></a><h2>TensorFlow <code>Fill</code> Operation</h2><h3>Description</h3><p>This operation creates a tensor of shape <code>dims</code> and fills it with <code>value</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># Output tensor has shape [2, 3].
fill([2, 3], 9) ==&gt; [[9, 9, 9]
                     [9, 9, 9]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>dims</code></td><td>DT_INT32</td><td></td><td><p>1-D. Represents the shape of the output tensor.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>0-D (scalar). Value to fill the returned tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="FixedLengthRecordReader"></a><h2>TensorFlow <code>FixedLengthRecordReader</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>header_bytes</td><td>int</td><td>i: 0
</td><td></td><td></td></tr><tr><td>record_bytes</td><td>int</td><td></td><td></td><td></td></tr><tr><td>footer_bytes</td><td>int</td><td>i: 0
</td><td></td><td></td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is named in the given bucket
with this shared_name. Otherwise, the node name is used instead.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to reference the Reader.</p>
</td></tr></table><a name="FixedUnigramCandidateSampler"></a><h2>TensorFlow <code>FixedUnigramCandidateSampler</code> Operation</h2><h3>Description</h3><p>A unigram sampler could use a fixed unigram distribution read from a
file or passed in as an in-memory array instead of building up the distribution
from data on the fly. There is also an option to skew the distribution by
applying a distortion power to the weights.</p>

<p>The vocabulary file should be in CSV-like format, with the last field
being the weight associated with the word.</p>

<p>For each batch, this op picks a single set of sampled candidate labels.</p>

<p>The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>num_sampled</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of candidates to randomly sample per batch.</p>
</td></tr><tr><td>unique</td><td>bool</td><td></td><td></td><td><p>If unique is true, we sample with rejection, so that all sampled
candidates in a batch are unique. This requires some approximation to
estimate the post-rejection sampling probabilities.</p>
</td></tr><tr><td>range_max</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td></tr><tr><td>vocab_file</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>Each valid line in this file (which should have a CSV-like format)
corresponds to a valid word ID. IDs are in sequential order, starting from
num<em>reserved</em>ids. The last entry in each line is expected to be a value
corresponding to the count or relative probability. Exactly one of vocab_file
and unigrams needs to be passed to this op.</p>
</td></tr><tr><td>distortion</td><td>float</td><td>f: 1
</td><td></td><td><p>The distortion is used to skew the unigram probability distribution.
Each weight is first raised to the distortion&#39;s power before adding to the
internal unigram distribution. As a result, distortion = 1.0 gives regular
unigram sampling (as defined by the vocab file), and distortion = 0.0 gives
a uniform distribution.</p>
</td></tr><tr><td>num_reserved_ids</td><td>int</td><td>i: 0
</td><td></td><td><p>Optionally some reserved IDs can be added in the range [0,
..., num<em>reserved</em>ids) by the users. One use case is that a special unknown
word token is used as ID 0. These IDs will have a sampling probability of 0.</p>
</td></tr><tr><td>num_shards</td><td>int</td><td>i: 1
</td><td><b>Minimum: </b>1</td><td><p>A sampler can be used to sample from a subset of the original range
in order to speed up the whole computation through parallelism. This parameter
(together with &#39;shard&#39;) indicates the number of partitions that are being
used in the overall computation.</p>
</td></tr><tr><td>shard</td><td>int</td><td>i: 0
</td><td><b>Minimum: </b>0</td><td><p>A sampler can be used to sample from a subset of the original range
in order to speed up the whole computation through parallelism. This parameter
(together with &#39;num_shards&#39;) indicates the particular partition number of a
sampler op, when partitioning is being used.</p>
</td></tr><tr><td>unigrams</td><td>list(float)</td><td>list {
}
</td><td></td><td><p>A list of unigram counts or probabilities, one per ID in sequential
order. Exactly one of vocab_file and unigrams should be passed to this op.</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>A batch<em>size * num</em>true matrix, in which each row contains the
IDs of the num<em>true target</em>classes in the corresponding original label.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>A vector of length num_sampled, in which each element is
the ID of a sampled candidate.</p>
</td></tr><tr><td><code>true_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A batch<em>size * num</em>true matrix, representing
the number of times each candidate is expected to occur in a batch
of sampled candidates. If unique=true, then this is a probability.</p>
</td></tr><tr><td><code>sampled_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of length num_sampled, for each sampled
candidate representing the number of times the candidate is expected
to occur in a batch of sampled candidates.  If unique=true, then this is a
probability.</p>
</td></tr></table><a name="Floor"></a><h2>TensorFlow <code>Floor</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Gather"></a><h2>TensorFlow <code>Gather</code> Operation</h2><h3>Description</h3><p><code>indices</code> must be an integer tensor of any dimension (usually 0-D or 1-D).
Produces an output tensor with shape <code>indices.shape + params.shape[1:]</code> where:</p>

<pre><code># Scalar indices
output[:, ..., :] = params[indices, :, ... :]

# Vector indices
output[i, :, ..., :] = params[indices[i], :, ... :]

# Higher rank indices
output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]
</code></pre>

<p>If <code>indices</code> is a permutation and <code>len(indices) == params.shape[0]</code> then
this operation will permute <code>params</code> accordingly.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/Gather.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>validate_indices</td><td>bool</td><td>b: true
</td><td></td><td></td></tr><tr><td>Tparams</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>params</code></td><td><b>attr: </b><code>Tparams</code></td><td></td><td></td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>Tparams</code></td><td></td><td></td></tr></table><a name="GatherNd"></a><h2>TensorFlow <code>GatherNd</code> Operation</h2><h3>Description</h3><p><code>params</code> is a Tensor of rank <code>R</code> and <code>indices</code> is a Tensor of rank <code>M</code>.</p>

<p><code>indices</code> must be integer tensor, containing indices into <code>params</code>.
It must be shape <code>[d_0, ..., d_N, R]</code> where <code>0 &lt; R &lt;= M</code>.</p>

<p>The innermost dimension of <code>indices</code> (with length <code>R</code>) corresponds to
indices into elements (if <code>R = M</code>) or slices (if <code>R &lt; M</code>) along the <code>N</code>th
dimension of <code>params</code>.</p>

<p>Produces an output tensor with shape</p>

<pre><code>[d_0, ..., d_{n-1}, params.shape[R], ..., params.shape[M-1]].
</code></pre>

<p>Some examples below.</p>

<p>Simple indexing into a matrix:</p>

<pre><code>indices = [[0, 0], [1, 1]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [&#39;a&#39;, &#39;d&#39;]
</code></pre>

<p>Slice indexing into a matrix:</p>

<pre><code>indices = [[1], [0]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [[&#39;c&#39;, &#39;d&#39;], [&#39;a&#39;, &#39;b&#39;]]
</code></pre>

<p>Indexing into a 3-tensor:</p>

<pre><code>indices = [[1]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


indices = [[0, 1], [1, 0]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]]


indices = [[0, 0, 1], [1, 0, 1]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [&#39;b0&#39;, &#39;b1&#39;]
</code></pre>

<p>Batched indexing into a matrix:</p>

<pre><code>indices = [[[0, 0]], [[0, 1]]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [[&#39;a&#39;], [&#39;b&#39;]]
</code></pre>

<p>Batched slice indexing into a matrix:</p>

<pre><code>indices = [[[1]], [[0]]]
params = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]
output = [[[&#39;c&#39;, &#39;d&#39;]], [[&#39;a&#39;, &#39;b&#39;]]]
</code></pre>

<p>Batched indexing into a 3-tensor:</p>

<pre><code>indices = [[[1]], [[0]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]],
          [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]]]]


indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[[&#39;c0&#39;, &#39;d0&#39;], [&#39;a1&#39;, &#39;b1&#39;]],
          [[&#39;a0&#39;, &#39;b0&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]


indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]
params = [[[&#39;a0&#39;, &#39;b0&#39;], [&#39;c0&#39;, &#39;d0&#39;]],
          [[&#39;a1&#39;, &#39;b1&#39;], [&#39;c1&#39;, &#39;d1&#39;]]]
output = [[&#39;b0&#39;, &#39;b1&#39;], [&#39;d0&#39;, &#39;c1&#39;]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tparams</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>params</code></td><td><b>attr: </b><code>Tparams</code></td><td></td><td><p><code>M-D</code>.  The tensor from which to gather values.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p><code>(N+1)-D</code>.  Index tensor having shape <code>[d_0, ..., d_N, R]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>Tparams</code></td><td></td><td><p><code>(N+M-R)-D</code>.  Values from <code>params</code> gathered from indices given by
<code>indices</code>.</p>
</td></tr></table><a name="GetSessionHandle"></a><h2>TensorFlow <code>GetSessionHandle</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be stored.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle for the tensor stored in the session state.</p>
</td></tr></table><a name="GetSessionTensor"></a><h2>TensorFlow <code>GetSessionTensor</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of the output value.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle for a tensor stored in the session state.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The tensor for the given handle.</p>
</td></tr></table><a name="Greater"></a><h2>TensorFlow <code>Greater</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Greater</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="GreaterEqual"></a><h2>TensorFlow <code>GreaterEqual</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>GreaterEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="HSVToRGB"></a><h2>TensorFlow <code>HSVToRGB</code> Operation</h2><h3>Description</h3><p>Outputs a tensor of the same shape as the <code>images</code> tensor, containing the RGB
value of the pixels. The output is only well defined if the value in <code>images</code>
are in <code>[0,1]</code>.</p>

<p>See <code>rgb_to_hsv</code> for a description of the HSV encoding.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D or higher rank. HSV data to convert. Last dimension must be size 3.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>images</code> converted to RGB.</p>
</td></tr></table><a name="HashTable"></a><h2>TensorFlow <code>HashTable</code> Operation</h2><h3>Description</h3><p>This op creates a hash table, specifying the type of its keys and values.
Before using the table you will have to initialize it.  After initialization the
table will be immutable.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this table is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this table is shared under the given name across
multiple sessions.</p>
</td></tr><tr><td>key_dtype</td><td>type</td><td></td><td></td><td><p>Type of the table keys.</p>
</td></tr><tr><td>value_dtype</td><td>type</td><td></td><td></td><td><p>Type of the table values.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a table.</p>
</td></tr></table><a name="HistogramSummary"></a><h2>TensorFlow <code>HistogramSummary</code> Operation</h2><h3>Description</h3><p>The generated
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto" target="_blank"><code>Summary</code></a>
has one summary value containing a histogram for <code>values</code>.</p>

<p>This op reports an <code>InvalidArgument</code> error if any value is not finite.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tag</code></td><td>DT_STRING</td><td></td><td><p>Scalar.  Tag to use for the <code>Summary.Value</code>.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Any shape. Values to use to build the histogram.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>summary</code></td><td>DT_STRING</td><td></td><td><p>Scalar. Serialized <code>Summary</code> protocol buffer.</p>
</td></tr></table><a name="IFFT"></a><h2>TensorFlow <code>IFFT</code> Operation</h2><h3>Description</h3><p>Compute the inverse 1-dimensional discrete Fourier Transform.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 vector.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>The inverse 1D Fourier Transform of <code>input</code>.</p>
</td></tr></table><a name="IFFT2D"></a><h2>TensorFlow <code>IFFT2D</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 matrix.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>The inverse 2D Fourier Transform of <code>input</code>.</p>
</td></tr></table><a name="IFFT3D"></a><h2>TensorFlow <code>IFFT3D</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_COMPLEX64</td><td></td><td><p>A complex64 3-D tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_COMPLEX64</td><td></td><td><p>The inverse 3D Fourier Transform of <code>input</code>.</p>
</td></tr></table><a name="Identity"></a><h2>TensorFlow <code>Identity</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="IdentityReader"></a><h2>TensorFlow <code>IdentityReader</code> Operation</h2><h3>Description</h3><p>To use, enqueue strings in a Queue.  ReaderRead will take the front
work string and output (work, work).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is named in the given bucket
with this shared_name. Otherwise, the node name is used instead.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to reference the Reader.</p>
</td></tr></table><a name="Igamma"></a><h2>TensorFlow <code>Igamma</code> Operation</h2><h3>Description</h3><p>The lower regularized incomplete Gamma function is defined as:</p>

<pre><code>P(a, x) = gamma(a, x) / Gamma(x) = 1 - Q(a, x)
</code></pre>

<p>where
<code>
gamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt
</code>
is the lower incomplete Gamma function.</p>

<p>Note, above <code>Q(a, x)</code> (<code>Igammac</code>) is the upper regularized complete
Gamma function.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Igammac"></a><h2>TensorFlow <code>Igammac</code> Operation</h2><h3>Description</h3><p>The upper regularized incomplete Gamma function is defined as:</p>

<pre><code>Q(a, x) = Gamma(a, x) / Gamma(x) = 1 - P(a, x)
</code></pre>

<p>where
<code>
Gamma(a, x) = int_{x}^{\infty} t^{a-1} exp(-t) dt
</code>
is the upper incomplete Gama function.</p>

<p>Note, above <code>P(a, x)</code> (<code>Igamma</code>) is the lower regularized complete
Gamma function.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Imag"></a><h2>TensorFlow <code>Imag</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
type <code>float</code> that is the imaginary part of each element in <code>input</code>. All
elements in <code>input</code> must be complex numbers of the form \(a + bj\), where <em>a</em>
is the real part and <em>b</em> is the imaginary part returned by this operation.</p>

<p>For example:</p>

<pre><code># tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.imag(input) ==&gt; [4.75, 5.75]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_COMPLEX64
</td><td><b>One of: </b><ul><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr><tr><td>Tout</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td></td></tr></table><a name="ImageSummary"></a><h2>TensorFlow <code>ImageSummary</code> Operation</h2><h3>Description</h3><p>The summary has up to <code>max_images</code> summary values containing images. The
images are built from <code>tensor</code> which must be 4-D with shape <code>[batch_size,
height, width, channels]</code> and where <code>channels</code> can be:</p>

<ul>
<li> 1: <code>tensor</code> is interpreted as Grayscale.</li>
<li> 3: <code>tensor</code> is interpreted as RGB.</li>
<li> 4: <code>tensor</code> is interpreted as RGBA.</li>
</ul>

<p>The images have the same number of channels as the input tensor. For float
input, the values are normalized one image at a time to fit in the range
<code>[0, 255]</code>.  <code>uint8</code> values are unchanged.  The op uses two different
normalization algorithms:</p>

<ul>
<li><p>If the input values are all positive, they are rescaled so the largest one
is 255.</p></li>
<li><p>If any input value is negative, the values are shifted so input value 0.0
is at 127.  They are then rescaled so that either the smallest value is 0,
or the largest one is 255.</p></li>
</ul>

<p>The <code>tag</code> argument is a scalar <code>Tensor</code> of type <code>string</code>.  It is used to
build the <code>tag</code> of the summary values:</p>

<ul>
<li> If <code>max_images</code> is 1, the summary value tag is &#39;<em>tag</em>/image&#39;.</li>
<li> If <code>max_images</code> is greater than 1, the summary value tags are
generated sequentially as &#39;<em>tag</em>/image/0&#39;, &#39;<em>tag</em>/image/1&#39;, etc.</li>
</ul>

<p>The <code>bad_color</code> argument is the color to use in the generated images for
non-finite input values.  It is a <code>unit8</code> 1-D tensor of length <code>channels</code>.
Each element must be in the range <code>[0, 255]</code> (It represents the value of a
pixel in the output image).  Non-finite values in the input tensor are
replaced by this tensor in the output image.  The default value is the color
red.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>max_images</td><td>int</td><td>i: 3
</td><td><b>Minimum: </b>1</td><td><p>Max number of batch elements to generate images for.</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>bad_color</td><td>tensor</td><td>tensor {
  dtype: DT_UINT8
  tensor_shape {
    dim {
      size: 4
    }
  }
  int_val: 255
  int_val: 0
  int_val: 0
  int_val: 255
}
</td><td></td><td><p>Color to use for pixels with non-finite values.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tag</code></td><td>DT_STRING</td><td></td><td><p>Scalar. Used to build the <code>tag</code> attribute of the summary values.</p>
</td></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D of shape <code>[batch_size, height, width, channels]</code> where
<code>channels</code> is 1, 3, or 4.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>summary</code></td><td>DT_STRING</td><td></td><td><p>Scalar. Serialized <code>Summary</code> protocol buffer.</p>
</td></tr></table><a name="ImmutableConst"></a><h2>TensorFlow <code>ImmutableConst</code> Operation</h2><h3>Description</h3><p>The current implementation memmaps the tensor from a file.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>Type of the returned tensor.</p>
</td></tr><tr><td>shape</td><td>shape</td><td></td><td></td><td><p>Shape of the returned tensor.</p>
</td></tr><tr><td>memory_region_name</td><td>string</td><td></td><td></td><td><p>Name of readonly memory region used by the tensor, see
NewReadOnlyMemoryRegionFromFile in tensorflow::Env.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td></td></tr></table><a name="InTopK"></a><h2>TensorFlow <code>InTopK</code> Operation</h2><h3>Description</h3><p>This outputs a <code>batch_size</code> bool array, an entry <code>out[i]</code> is <code>true</code> if the
prediction for the target class is among the top <code>k</code> predictions among
all predictions for example <code>i</code>. Note that the behavior of <code>InTopK</code> differs
from the <code>TopK</code> op in its handling of ties; if multiple classes have the
same prediction value and straddle the top-<code>k</code> boundary, all of those
classes are considered to be in the top <code>k</code>.</p>

<p>More formally, let</p>

<p>\(predictions_i\) be the predictions for all classes for example <code>i</code>,
  \(targets_i\) be the target class for example <code>i</code>,
  \(out_i\) be the output for example <code>i</code>,</p>

<p>\[out_i = predictions_{i, targets_i} \in TopKIncludingTies(predictions_i)\]</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>k</td><td>int</td><td></td><td></td><td><p>Number of top elements to look at for computing precision.</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_INT32
</td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>predictions</code></td><td>DT_FLOAT</td><td></td><td><p>A <code>batch_size</code> x <code>classes</code> tensor.</p>
</td></tr><tr><td><code>targets</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A <code>batch_size</code> vector of class ids.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>precision</code></td><td>DT_BOOL</td><td></td><td><p>Computed Precision at <code>k</code> as a <code>bool Tensor</code>.</p>
</td></tr></table><a name="InitializeTable"></a><h2>TensorFlow <code>InitializeTable</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tkey</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tval</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a table which will be initialized.</p>
</td></tr><tr><td><code>keys</code></td><td><b>attr: </b><code>Tkey</code></td><td></td><td><p>Keys of type Tkey.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>Tval</code></td><td></td><td><p>Values of type Tval. Same shape as <code>keys</code>.</p>
</td></tr></table><a name="InitializeTableFromTextFile"></a><h2>TensorFlow <code>InitializeTableFromTextFile</code> Operation</h2><h3>Description</h3><p>It inserts one key-value pair into the table for each line of the file.
The key and value is extracted from the whole line content, elements from the
split line based on <code>delimiter</code> or the line number (starting from zero).
Where to extract the key and value from a line is specified by <code>key_index</code> and
<code>value_index</code>.</p>

<ul>
<li>A value of -1 means use the line number(starting from zero), expects <code>int64</code>.</li>
<li>A value of -2 means use the whole line content, expects <code>string</code>.</li>
<li>A value &gt;= 0 means use the index (starting at zero) of the split line based
on <code>delimiter</code>.</li>
</ul>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>key_index</td><td>int</td><td></td><td><b>Minimum: </b>-2</td><td><p>Column index in a line to get the table <code>key</code> values from.</p>
</td></tr><tr><td>value_index</td><td>int</td><td></td><td><b>Minimum: </b>-2</td><td><p>Column index that represents information of a line to get the table
<code>value</code> values from.</p>
</td></tr><tr><td>vocab_size</td><td>int</td><td>i: -1
</td><td><b>Minimum: </b>-1</td><td><p>Number of elements of the file, use -1 if unknown.</p>
</td></tr><tr><td>delimiter</td><td>string</td><td>s: &quot;\t&quot;
</td><td></td><td><p>Delimiter to separate fields in a line.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a table which will be initialized.</p>
</td></tr><tr><td><code>filename</code></td><td>DT_STRING</td><td></td><td><p>Filename of a vocabulary text file.</p>
</td></tr></table><a name="Inv"></a><h2>TensorFlow <code>Inv</code> Operation</h2><h3>Description</h3><p>I.e., \(y = 1 / x\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="InvertPermutation"></a><h2>TensorFlow <code>InvertPermutation</code> Operation</h2><h3>Description</h3><p>This operation computes the inverse of an index permutation. It takes a 1-D
integer tensor <code>x</code>, which represents the indices of a zero-based array, and
swaps each value with its index position. In other words, for an output tensor
<code>y</code> and an input tensor <code>x</code>, this operation computes the following:</p>

<p><code>y[x[i]] = i for i in [0, 1, ..., len(x) - 1]</code></p>

<p>The values must include 0. There can be no duplicate values or negative values.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># tensor `x` is [3, 4, 0, 2, 1]
invert_permutation(x) ==&gt; [2, 4, 3, 0, 1]
</code></pre>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td>DT_INT32</td><td></td><td><p>1-D.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td>DT_INT32</td><td></td><td><p>1-D.</p>
</td></tr></table><a name="IsFinite"></a><h2>TensorFlow <code>IsFinite</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="IsInf"></a><h2>TensorFlow <code>IsInf</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="IsNan"></a><h2>TensorFlow <code>IsNan</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="IsVariableInitialized"></a><h2>TensorFlow <code>IsVariableInitialized</code> Operation</h2><h3>Description</h3><p>Outputs boolean scalar indicating whether the tensor has been initialized.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of elements in the variable tensor.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>Should be from a <code>Variable</code> node. May be uninitialized.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>is_initialized</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="L2Loss"></a><h2>TensorFlow <code>L2Loss</code> Operation</h2><h3>Description</h3><p>Computes half the L2 norm of a tensor without the <code>sqrt</code>:</p>

<pre><code>output = sum(t ** 2) / 2
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>t</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Typically 2-D, but may have any dimensions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>0-D.</p>
</td></tr></table><a name="LRN"></a><h2>TensorFlow <code>LRN</code> Operation</h2><h3>Description</h3><p>The 4-D <code>input</code> tensor is treated as a 3-D array of 1-D vectors (along the last
dimension), and each vector is normalized independently.  Within a given vector,
each component is divided by the weighted, squared sum of inputs within
<code>depth_radius</code>.  In detail,</p>

<pre><code>sqr_sum[a, b, c, d] =
    sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)
output = input / (bias + alpha * sqr_sum) ** beta
</code></pre>

<p>For details, see <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank">Krizhevsky et al., ImageNet classification with deep
convolutional neural networks (NIPS 2012)</a>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>depth_radius</td><td>int</td><td>i: 5
</td><td></td><td><p>0-D.  Half-width of the 1-D normalization window.</p>
</td></tr><tr><td>bias</td><td>float</td><td>f: 1
</td><td></td><td><p>An offset (usually positive to avoid dividing by 0).</p>
</td></tr><tr><td>alpha</td><td>float</td><td>f: 1
</td><td></td><td><p>A scale factor, usually positive.</p>
</td></tr><tr><td>beta</td><td>float</td><td>f: 0.5
</td><td></td><td><p>An exponent.</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="LRNGrad"></a><h2>TensorFlow <code>LRNGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>depth_radius</td><td>int</td><td>i: 5
</td><td></td><td><p>A depth radius.</p>
</td></tr><tr><td>bias</td><td>float</td><td>f: 1
</td><td></td><td><p>An offset (usually &gt; 0 to avoid dividing by 0).</p>
</td></tr><tr><td>alpha</td><td>float</td><td>f: 1
</td><td></td><td><p>A scale factor, usually positive.</p>
</td></tr><tr><td>beta</td><td>float</td><td>f: 0.5
</td><td></td><td><p>An exponent.</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_grads</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>input_image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>output_image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradients for LRN.</p>
</td></tr></table><a name="LearnedUnigramCandidateSampler"></a><h2>TensorFlow <code>LearnedUnigramCandidateSampler</code> Operation</h2><h3>Description</h3><p>See explanations of candidate sampling and the data formats at
go/candidate-sampling.</p>

<p>For each batch, this op picks a single set of sampled candidate labels.</p>

<p>The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>num_sampled</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of candidates to randomly sample per batch.</p>
</td></tr><tr><td>unique</td><td>bool</td><td></td><td></td><td><p>If unique is true, we sample with rejection, so that all sampled
candidates in a batch are unique. This requires some approximation to
estimate the post-rejection sampling probabilities.</p>
</td></tr><tr><td>range_max</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>A batch<em>size * num</em>true matrix, in which each row contains the
IDs of the num<em>true target</em>classes in the corresponding original label.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>A vector of length num_sampled, in which each element is
the ID of a sampled candidate.</p>
</td></tr><tr><td><code>true_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A batch<em>size * num</em>true matrix, representing
the number of times each candidate is expected to occur in a batch
of sampled candidates. If unique=true, then this is a probability.</p>
</td></tr><tr><td><code>sampled_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of length num_sampled, for each sampled
candidate representing the number of times the candidate is expected
to occur in a batch of sampled candidates.  If unique=true, then this is a
probability.</p>
</td></tr></table><a name="Less"></a><h2>TensorFlow <code>Less</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Less</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="LessEqual"></a><h2>TensorFlow <code>LessEqual</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>LessEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="Lgamma"></a><h2>TensorFlow <code>Lgamma</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="LinSpace"></a><h2>TensorFlow <code>LinSpace</code> Operation</h2><h3>Description</h3><p>A sequence of <code>num</code> evenly-spaced values are generated beginning at <code>start</code>.
If <code>num &gt; 1</code>, the values in the sequence increase by <code>stop - start / num - 1</code>,
so that the last one is exactly <code>stop</code>.</p>

<p>For example:</p>

<pre><code>tf.linspace(10.0, 12.0, 3, name=&quot;linspace&quot;) =&gt; [ 10.0  11.0  12.0]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>start</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>First entry in the range.</p>
</td></tr><tr><td><code>stop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Last entry in the range.</p>
</td></tr><tr><td><code>num</code></td><td>DT_INT32</td><td></td><td><p>Number of values to generate.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D. The generated values.</p>
</td></tr></table><a name="ListDiff"></a><h2>TensorFlow <code>ListDiff</code> Operation</h2><h3>Description</h3><p>Given a list <code>x</code> and a list <code>y</code>, this operation returns a list <code>out</code> that
represents all values that are in <code>x</code> but not in <code>y</code>. The returned list <code>out</code>
is sorted in the same order that the numbers appear in <code>x</code> (duplicates are
preserved). This operation also returns a list <code>idx</code> that represents the
position of each <code>out</code> element in <code>x</code>. In other words:</p>

<p><code>out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]</code></p>

<p>For example, given this input:</p>

<pre><code class="language-prettyprint">x = [1, 2, 3, 4, 5, 6]
y = [1, 3, 5]
</code></pre>

<p>This operation would return:</p>

<pre><code class="language-prettyprint">out ==&gt; [2, 4, 6]
idx ==&gt; [1, 3, 5]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D. Values to keep.</p>
</td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D. Values to remove.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D. Values present in <code>x</code> but not in <code>y</code>.</p>
</td></tr><tr><td><code>idx</code></td><td>DT_INT32</td><td></td><td><p>1-D. Positions of <code>x</code> values preserved in <code>out</code>.</p>
</td></tr></table><a name="Log"></a><h2>TensorFlow <code>Log</code> Operation</h2><h3>Description</h3><p>I.e., \(y = \log_e x\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="LogSoftmax"></a><h2>TensorFlow <code>LogSoftmax</code> Operation</h2><h3>Description</h3><p>For each batch <code>i</code> and class <code>j</code> we have</p>

<pre><code>logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>logits</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>2-D with shape <code>[batch_size, num_classes]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>logsoftmax</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same shape as <code>logits</code>.</p>
</td></tr></table><a name="LogUniformCandidateSampler"></a><h2>TensorFlow <code>LogUniformCandidateSampler</code> Operation</h2><h3>Description</h3><p>See explanations of candidate sampling and the data formats at
go/candidate-sampling.</p>

<p>For each batch, this op picks a single set of sampled candidate labels.</p>

<p>The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>num_sampled</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of candidates to randomly sample per batch.</p>
</td></tr><tr><td>unique</td><td>bool</td><td></td><td></td><td><p>If unique is true, we sample with rejection, so that all sampled
candidates in a batch are unique. This requires some approximation to
estimate the post-rejection sampling probabilities.</p>
</td></tr><tr><td>range_max</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>A batch<em>size * num</em>true matrix, in which each row contains the
IDs of the num<em>true target</em>classes in the corresponding original label.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>A vector of length num_sampled, in which each element is
the ID of a sampled candidate.</p>
</td></tr><tr><td><code>true_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A batch<em>size * num</em>true matrix, representing
the number of times each candidate is expected to occur in a batch
of sampled candidates. If unique=true, then this is a probability.</p>
</td></tr><tr><td><code>sampled_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of length num_sampled, for each sampled
candidate representing the number of times the candidate is expected
to occur in a batch of sampled candidates.  If unique=true, then this is a
probability.</p>
</td></tr></table><a name="LogicalAnd"></a><h2>TensorFlow <code>LogicalAnd</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>LogicalAnd</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td>DT_BOOL</td><td></td><td></td></tr><tr><td><code>y</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="LogicalNot"></a><h2>TensorFlow <code>LogicalNot</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="LogicalOr"></a><h2>TensorFlow <code>LogicalOr</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>LogicalOr</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td>DT_BOOL</td><td></td><td></td></tr><tr><td><code>y</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="LookupTableExport"></a><h2>TensorFlow <code>LookupTableExport</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tkeys</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tvalues</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to the table.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>keys</code></td><td><b>attr: </b><code>Tkeys</code></td><td></td><td><p>Vector of all keys present in the table.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>Tvalues</code></td><td></td><td><p>Tensor of all values in the table. Indexed in parallel with <code>keys</code>.</p>
</td></tr></table><a name="LookupTableFind"></a><h2>TensorFlow <code>LookupTableFind</code> Operation</h2><h3>Description</h3><p>The tensor <code>keys</code> must of the same type as the keys of the table.
The output <code>values</code> is of the type of the table values.</p>

<p>The scalar <code>default_value</code> is the value output for keys not present in the
table. It must also be of the same type as the table values.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tin</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tout</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to the table.</p>
</td></tr><tr><td><code>keys</code></td><td><b>attr: </b><code>Tin</code></td><td></td><td><p>Any shape.  Keys to look up.</p>
</td></tr><tr><td><code>default_value</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>values</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td><p>Same shape as <code>keys</code>.  Values found in the table, or <code>default_values</code>
for missing keys.</p>
</td></tr></table><a name="LookupTableInsert"></a><h2>TensorFlow <code>LookupTableInsert</code> Operation</h2><h3>Description</h3><p>The tensor <code>keys</code> must be of the same type as the keys of the table.
The tensor <code>values</code> must be of the type of the table values.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tin</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tout</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to the table.</p>
</td></tr><tr><td><code>keys</code></td><td><b>attr: </b><code>Tin</code></td><td></td><td><p>Any shape.  Keys to look up.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td><p>Same shape as <code>keys</code>.  Values to associate with keys.</p>
</td></tr></table><a name="LookupTableSize"></a><h2>TensorFlow <code>LookupTableSize</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to the table.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>size</code></td><td>DT_INT64</td><td></td><td><p>Scalar that contains number of elements in the table.</p>
</td></tr></table><a name="LoopCond"></a><h2>TensorFlow <code>LoopCond</code> Operation</h2><h3>Description</h3><p>This operator represents the loop termination condition used by the
&quot;pivot&quot; switches of a loop.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_BOOL</td><td></td><td><p>A boolean scalar, representing the branch predicate of the Switch op.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_BOOL</td><td></td><td><p>The same tensor as <code>input</code>.</p>
</td></tr></table><a name="MatMul"></a><h2>TensorFlow <code>MatMul</code> Operation</h2><h3>Description</h3><p>The inputs must be two-dimensional matrices and the inner dimension of
&quot;a&quot; (after being transposed if transpose<em>a is true) must match the
outer dimension of &quot;b&quot; (after being transposed if transposed</em>b is
true).</p>

<p><em>Note</em>: The default kernel implementation for MatMul on GPUs uses
cublas.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>transpose_a</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, &quot;a&quot; is transposed before multiplication.</p>
</td></tr><tr><td>transpose_b</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, &quot;b&quot; is transposed before multiplication.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>b</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>product</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="MatchingFiles"></a><h2>TensorFlow <code>MatchingFiles</code> Operation</h2><h3>Description</h3><p>Note that this routine only supports wildcard characters in the
basename portion of the pattern, not in the directory portion.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>pattern</code></td><td>DT_STRING</td><td></td><td><p>A (scalar) shell wildcard pattern.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filenames</code></td><td>DT_STRING</td><td></td><td><p>A vector of matching filenames.</p>
</td></tr></table><a name="MatrixDeterminant"></a><h2>TensorFlow <code>MatrixDeterminant</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor of shape <code>[M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A scalar, equal to the determinant of the input.</p>
</td></tr></table><a name="MatrixInverse"></a><h2>TensorFlow <code>MatrixInverse</code> Operation</h2><h3>Description</h3><p>transpose).</p>

<p>The op uses LU decomposition with partial pivoting to compute the inverse.</p>

<p>If the matrix is not invertible there is no guarantee what the op does. It
may detect the condition and raise an exception or it may simply return a
garbage result.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>adjoint</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>. If <code>adjoint</code> is <code>False</code> then <code>output</code> contains the
matrix inverse of <code>input</code>. If <code>adjoint</code> is <code>True</code> then <code>output</code> contains the
matrix inverse of the adjoint of <code>input</code>.</p>
</td></tr></table><a name="MatrixSolve"></a><h2>TensorFlow <code>MatrixSolve</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>adjoint</td><td>bool</td><td>b: false
</td><td></td><td><p>Boolean indicating whether to solve with <code>matrix</code> or its adjoint.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>matrix</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>.</p>
</td></tr><tr><td><code>rhs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, K]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, K]</code>. If <code>adjoint</code> is <code>False</code> then <code>output</code> that solves
<code>matrix</code> * <code>output</code> = <code>rhs</code>. If <code>adjoint</code> is <code>True</code> then <code>output</code> that solves
<code>adjoint(matrix)</code> * <code>output</code> = <code>rhs</code>.</p>
</td></tr></table><a name="MatrixSolveLs"></a><h2>TensorFlow <code>MatrixSolveLs</code> Operation</h2><h3>Description</h3><p>Below we will use the following notation
<code>matrix</code>=\(A \in \Re^{m \times n}\),
<code>rhs</code>=\(B  \in \Re^{m \times k}\),
<code>output</code>=\(X  \in \Re^{n \times k}\),
<code>l2_regularizer</code>=\(\lambda\).</p>

<p>If <code>fast</code> is <code>True</code>, then the solution is computed by solving the normal
equations using Cholesky decomposition. Specifically, if \(m \ge n\) then
\(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares
problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||A Z - B||_F^2 +
\lambda ||Z||_F^2\). If \(m \lt n\) then <code>output</code> is computed as
\(X = A^T (A A^T + \lambda I)^{-1} B\),
which (for \(\lambda = 0\)) is the minimum-norm solution to the
under-determined linear system, i.e.
\(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||Z||_F^2 \),
subject to \(A Z = B\).
Notice that the fast path is only numerically stable when \(A\) is
numerically full rank and has a condition number
\(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach}}}\)
or \(\lambda\) is sufficiently large.</p>

<p>If <code>fast</code> is <code>False</code> an algorithm based on the numerically robust complete
orthogonal decomposition is used. This computes the minimum-norm
least-squares solution, even when \(A\) is rank deficient. This path is
typically 6-7 times slower than the fast path. If <code>fast</code> is <code>False</code> then
<code>l2_regularizer</code> is ignored.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr><tr><td>fast</td><td>bool</td><td>b: true
</td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>matrix</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, N]</code>.</p>
</td></tr><tr><td><code>rhs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, K]</code>.</p>
</td></tr><tr><td><code>l2_regularizer</code></td><td>DT_DOUBLE</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[N, K]</code> containing the tensor that solves
<code>matrix * output = rhs</code> in the least-squares sense.</p>
</td></tr></table><a name="MatrixTriangularSolve"></a><h2>TensorFlow <code>MatrixTriangularSolve</code> Operation</h2><h3>Description</h3><p>backsubstitution.</p>

<p><code>matrix</code> is a matrix of shape <code>[M, M]</code>. If <code>lower</code> is <code>True</code> then the strictly
upper triangular part of <code>matrix</code> is assumed to be zero and not accessed.
If <code>lower</code> is False then the strictly lower triangular part of <code>matrix</code> is
assumed to be zero and not accessed.
<code>rhs</code> is a matrix of shape [M, K]`.</p>

<p>The output is a matrix of shape <code>[M, K]</code>. If <code>adjoint</code> is <code>False</code> the output
satisfies the matrix equation <code>matrix</code> * <code>output</code> = <code>rhs</code>.
If <code>adjoint</code> is <code>False</code> then <code>output</code> satisfies the matrix equation
<code>matrix</code> * <code>output</code> = <code>rhs</code>.
If <code>adjoint</code> is <code>True</code> then <code>output</code> satisfies the matrix equation
<code>adjoint(matrix)</code> * <code>output</code> = <code>rhs</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>lower</td><td>bool</td><td>b: true
</td><td></td><td><p>Boolean indicating whether <code>matrix</code> is lower or upper triangular</p>
</td></tr><tr><td>adjoint</td><td>bool</td><td>b: false
</td><td></td><td><p>Boolean indicating whether to solve with <code>matrix</code> or its adjoint.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>matrix</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>.</p>
</td></tr><tr><td><code>rhs</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, K]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, K]</code>.</p>
</td></tr></table><a name="Max"></a><h2>TensorFlow <code>Max</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="MaxPool"></a><h2>TensorFlow <code>MaxPool</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the window for each dimension of the input tensor.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of the
input tensor.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D input to pool over.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The max pooled output tensor.</p>
</td></tr></table><a name="MaxPool3D"></a><h2>TensorFlow <code>MaxPool3D</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The size of the window for each dimension of
the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape <code>[batch, depth, rows, cols, channels]</code> tensor to pool over.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The max pooled output tensor.</p>
</td></tr></table><a name="MaxPool3DGrad"></a><h2>TensorFlow <code>MaxPool3DGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The size of the window for each dimension of
the input tensor. Must have <code>ksize[0] = ksize[4] = 1</code>.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>5</td><td><p>1-D tensor of length 5. The stride of the sliding window for each
dimension of <code>input</code>. Must have <code>strides[0] = strides[4] = 1</code>.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>orig_input</code></td><td>DT_FLOAT</td><td></td><td><p>The original input tensor.</p>
</td></tr><tr><td><code>orig_output</code></td><td>DT_FLOAT</td><td></td><td><p>The original output tensor.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Output backprop of shape <code>[batch, depth, rows, cols, channels]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="MaxPoolGrad"></a><h2>TensorFlow <code>MaxPoolGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the window for each dimension of the input tensor.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of the
input tensor.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>data_format</td><td>string</td><td>s: &quot;NHWC&quot;
</td><td><b>One of: </b><ul><li><code>NHWC</code></li><li><code>NCHW</code></li></ul></td><td><p>Specify the data format of the input and output data. With the
default format &quot;NHWC&quot;, the data is stored in the order of:
    [batch, in<em>height, in</em>width, in<em>channels].
Alternatively, the format could be &quot;NCHW&quot;, the data storage order of:
    [batch, in</em>channels, in<em>height, in</em>width].</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>orig_input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The original input tensor.</p>
</td></tr><tr><td><code>orig_output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The original output tensor.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D.  Gradients w.r.t. the output of <code>max_pool</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Gradients w.r.t. the input to <code>max_pool</code>.</p>
</td></tr></table><a name="MaxPoolGradWithArgmax"></a><h2>TensorFlow <code>MaxPoolGradWithArgmax</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the window for each dimension of the input tensor.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of the
input tensor.</p>
</td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>Targmax</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The original input.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Gradients w.r.t. the
output of <code>max_pool</code>.</p>
</td></tr><tr><td><code>argmax</code></td><td><b>attr: </b><code>Targmax</code></td><td></td><td><p>The indices of the maximum values chosen for each output of <code>max_pool</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Gradients w.r.t. the input of <code>max_pool</code>.</p>
</td></tr></table><a name="MaxPoolWithArgmax"></a><h2>TensorFlow <code>MaxPoolWithArgmax</code> Operation</h2><h3>Description</h3><p>The indices in <code>argmax</code> are flattened, so that a maximum value at position
<code>[b, y, x, c]</code> becomes flattened index
<code>((b * height + y) * width + x) * channels + c</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>ksize</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The size of the window for each dimension of the input tensor.</p>
</td></tr><tr><td>strides</td><td>list(int)</td><td></td><td><b>Minimum: </b>4</td><td><p>The stride of the sliding window for each dimension of the
input tensor.</p>
</td></tr><tr><td>Targmax</td><td>type</td><td>type: DT_INT64
</td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>padding</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>SAME</code></li><li><code>VALID</code></li></ul></td><td><p>The type of padding algorithm to use.</p>
</td></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.  Input to pool over.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The max pooled output tensor.</p>
</td></tr><tr><td><code>argmax</code></td><td><b>attr: </b><code>Targmax</code></td><td></td><td><p>4-D.  The flattened indices of the max values chosen for each output.</p>
</td></tr></table><a name="Maximum"></a><h2>TensorFlow <code>Maximum</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Maximum</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Mean"></a><h2>TensorFlow <code>Mean</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="Merge"></a><h2>TensorFlow <code>Merge</code> Operation</h2><h3>Description</h3><p><code>Merge</code> waits for at least one of the tensors in <code>inputs</code> to become available.
It is usually combined with <code>Switch</code> to implement branching.</p>

<p><code>Merge</code> forwards the first tensor for become available to <code>output</code>, and sets
<code>value_index</code> to its index in <code>inputs</code>.</p>

<p>It is an error if more than one tensor in <code>inputs</code> is available.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>The input tensors, exactly one of which will become available.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Will be set to the available input tensor.</p>
</td></tr><tr><td><code>value_index</code></td><td>DT_INT32</td><td></td><td><p>The index of the chosen input tensor in <code>inputs</code>.</p>
</td></tr></table><a name="MergeSummary"></a><h2>TensorFlow <code>MergeSummary</code> Operation</h2><h3>Description</h3><p>This op creates a
<a href="https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto" target="_blank"><code>Summary</code></a>
protocol buffer that contains the union of all the values in the input
summaries.</p>

<p>When the Op is run, it reports an <code>InvalidArgument</code> error if multiple values
in the summaries to merge use the same tag.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td>DT_STRING</td><td><b>number: </b><code><p>N</p>
</code></td><td><p>Can be of any shape.  Each must contain serialized <code>Summary</code> protocol
buffers.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>summary</code></td><td>DT_STRING</td><td></td><td><p>Scalar. Serialized <code>Summary</code> protocol buffer.</p>
</td></tr></table><a name="Min"></a><h2>TensorFlow <code>Min</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="Minimum"></a><h2>TensorFlow <code>Minimum</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Minimum</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="MirrorPad"></a><h2>TensorFlow <code>MirrorPad</code> Operation</h2><h3>Description</h3><p>This operation pads a <code>input</code> with mirrored values according to the <code>paddings</code>
you specify. <code>paddings</code> is an integer tensor with shape <code>[n, 2]</code>, where n is
the rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates
how many values to add before the contents of <code>input</code> in that dimension, and
<code>paddings[D, 1]</code> indicates how many values to add after the contents of <code>input</code>
in that dimension. Both <code>paddings[D, 0]</code> and <code>paddings[D, 1]</code> must be no greater
than <code>input.dim_size(D)</code> (or <code>input.dim_size(D) - 1</code>) if <code>copy_border</code> is true
(if false, respectively).</p>

<p>The padded size of each dimension D of the output is:</p>

<p><code>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</code></p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is [[1, 2, 3], [4, 5, 6]].
# &#39;paddings&#39; is [[1, 1]], [2, 2]].
# &#39;mode&#39; is SYMMETRIC.
# rank of &#39;t&#39; is 2.
pad(t, paddings) ==&gt; [[2, 1, 1, 2, 3, 3, 2]
                      [2, 1, 1, 2, 3, 3, 2]
                      [5, 4, 4, 5, 6, 6, 5]
                      [5, 4, 4, 5, 6, 6, 5]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>mode</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>REFLECT</code></li><li><code>SYMMETRIC</code></li></ul></td><td><p>Either <code>REFLECT</code> or <code>SYMMETRIC</code>. In reflect mode the padded regions
do not include the borders, while in symmetric mode the padded regions
do include the borders. For example, if <code>input</code> is <code>[1, 2, 3]</code> and <code>paddings</code>
is <code>[0, 2]</code>, then the output is <code>[1, 2, 3, 2, 1]</code> in reflect mode, and
it is <code>[1, 2, 3, 3, 2]</code> in symmetric mode.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The input tensor to be padded.</p>
</td></tr><tr><td><code>paddings</code></td><td>DT_INT32</td><td></td><td><p>A two-column matrix specifying the padding sizes. The number of
rows must be the same as the rank of <code>input</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The padded tensor.</p>
</td></tr></table><a name="MirrorPadGrad"></a><h2>TensorFlow <code>MirrorPadGrad</code> Operation</h2><h3>Description</h3><p>This operation folds the padded areas of <code>input</code> by <code>MirrorPad</code> according to the
<code>paddings</code> you specify. <code>paddings</code> must be the same as <code>paddings</code> argument
given to the corresponding <code>MirrorPad</code> op.</p>

<p>The folded size of each dimension D of the output is:</p>

<p><code>input.dim_size(D) - paddings(D, 0) - paddings(D, 1)</code></p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].
# &#39;paddings&#39; is [[0, 1]], [0, 1]].
# &#39;mode&#39; is SYMMETRIC.
# rank of &#39;t&#39; is 2.
pad(t, paddings) ==&gt; [[ 1,  5]
                      [11, 28]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>mode</td><td>string</td><td></td><td><b>One of: </b><ul><li><code>REFLECT</code></li><li><code>SYMMETRIC</code></li></ul></td><td><p>The mode used in the <code>MirrorPad</code> op.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The input tensor to be folded.</p>
</td></tr><tr><td><code>paddings</code></td><td>DT_INT32</td><td></td><td><p>A two-column matrix specifying the padding sizes. The number of
rows must be the same as the rank of <code>input</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The folded tensor.</p>
</td></tr></table><a name="Mod"></a><h2>TensorFlow <code>Mod</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Mod</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Mul"></a><h2>TensorFlow <code>Mul</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Mul</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Multinomial"></a><h2>TensorFlow <code>Multinomial</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 is set to be non-zero, the internal random number
generator is seeded by the given seed.  Otherwise, a random seed is used.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>logits</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>2-D Tensor with shape <code>[batch_size, num_classes]</code>.  Each slice <code>[i, :]</code>
represents the unnormalized log probabilities for all classes.</p>
</td></tr><tr><td><code>num_samples</code></td><td>DT_INT32</td><td></td><td><p>0-D.  Number of independent samples to draw for each row slice.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td><p>2-D Tensor with shape <code>[batch_size, num_samples]</code>.  Each slice <code>[i, :]</code>
contains the drawn class labels with range <code>[0, num_classes)</code>.</p>
</td></tr></table><a name="MutableHashTable"></a><h2>TensorFlow <code>MutableHashTable</code> Operation</h2><h3>Description</h3><p>This op creates a mutable hash table, specifying the type of its keys and
values. Each value must be a scalar. Data can be inserted into the table using
the insert operations. It does not support the initialization operation.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this table is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this table is shared under the given name across
multiple sessions.</p>
</td></tr><tr><td>key_dtype</td><td>type</td><td></td><td></td><td><p>Type of the table keys.</p>
</td></tr><tr><td>value_dtype</td><td>type</td><td></td><td></td><td><p>Type of the table values.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a table.</p>
</td></tr></table><a name="MutableHashTableOfTensors"></a><h2>TensorFlow <code>MutableHashTableOfTensors</code> Operation</h2><h3>Description</h3><p>This op creates a mutable hash table, specifying the type of its keys and
values. Each value must be a vector. Data can be inserted into the table using
the insert operations. It does not support the initialization operation.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this table is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this table is shared under the given name across
multiple sessions.</p>
</td></tr><tr><td>key_dtype</td><td>type</td><td></td><td></td><td><p>Type of the table keys.</p>
</td></tr><tr><td>value_dtype</td><td>type</td><td></td><td></td><td><p>Type of the table values.</p>
</td></tr><tr><td>value_shape</td><td>shape</td><td>shape {
}
</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>table_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a table.</p>
</td></tr></table><a name="Neg"></a><h2>TensorFlow <code>Neg</code> Operation</h2><h3>Description</h3><p>I.e., \(y = -x\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="NextIteration"></a><h2>TensorFlow <code>NextIteration</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be made available to the next iteration.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as <code>data</code>.</p>
</td></tr></table><a name="NoOp"></a><h2>TensorFlow <code>NoOp</code> Operation</h2><h3>Description</h3><a name="NonMaxSuppression"></a><h2>TensorFlow <code>NonMaxSuppression</code> Operation</h2><h3>Description</h3><p>pruning away boxes that have high intersection-over-union (IOU) overlap
with previously selected boxes.  Bounding boxes are supplied as
[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any
diagonal pair of box corners and the coordinates can be provided as normalized
(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm
is agnostic to where the origin is in the coordinate system.  Note that this
algorithm is invariant to orthogonal transformations and translations
of the coordinate system; thus translating or reflections of the coordinate
system result in the same boxes being selected by the algorithm.</p>

<p>The output of this operation is a set of integers indexing into the input
collection of bounding boxes representing the selected boxes.  The bounding
box coordinates corresponding to the selected indices can then be obtained
using the tf.gather operation.  For example:</p>

<p>selected<em>indices = tf.image.non</em>max<em>suppression(
      boxes, scores, max</em>output<em>size, iou</em>threshold)
  selected<em>boxes = tf.gather(boxes, selected</em>indices)</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>iou_threshold</td><td>float</td><td>f: 0.5
</td><td></td><td><p>A float representing the threshold for deciding whether boxes
overlap too much with respect to IOU.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>boxes</code></td><td>DT_FLOAT</td><td></td><td><p>A 2-D float tensor of shape <code>[num_boxes, 4]</code>.</p>
</td></tr><tr><td><code>scores</code></td><td>DT_FLOAT</td><td></td><td><p>A 1-D float tensor of shape <code>[num_boxes]</code> representing a single
score corresponding to each box (each row of boxes).</p>
</td></tr><tr><td><code>max_output_size</code></td><td>DT_INT32</td><td></td><td><p>A scalar integer tensor representing the maximum number of
boxes to be selected by non max suppression.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>selected_indices</code></td><td>DT_INT32</td><td></td><td><p>A 1-D integer tensor of shape <code>[M]</code> representing the selected
indices from the boxes tensor, where <code>M &lt;= max_output_size</code>.</p>
</td></tr></table><a name="NotEqual"></a><h2>TensorFlow <code>NotEqual</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>NotEqual</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_STRING</code></li><li><code>DT_BOOL</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><a name="OneHot"></a><h2>TensorFlow <code>OneHot</code> Operation</h2><h3>Description</h3><p>The locations represented by indices in <code>indices</code> take value <code>on_value</code>,
while all other locations take value <code>off_value</code>.</p>

<p>If the input <code>indices</code> is rank <code>N</code>, the output will have rank <code>N+1</code>,
The new axis is created at dimension <code>axis</code> (default: the new axis is
appended at the end).</p>

<p>If <code>indices</code> is a scalar the output shape will be a vector of length <code>depth</code>.</p>

<p>If <code>indices</code> is a vector of length <code>features</code>, the output shape will be:
<code>
  features x depth if axis == -1
  depth x features if axis == 0
</code></p>

<p>If <code>indices</code> is a matrix (batch) with shape <code>[batch, features]</code>,
the output shape will be:
<code>
  batch x features x depth if axis == -1
  batch x depth x features if axis == 1
  depth x batch x features if axis == 0
</code></p>

<h1>Examples</h1>

<p>Suppose that</p>

<pre><code>  indices = [0, 2, -1, 1]
  depth = 3
  on_value = 5.0
  off_value = 0.0
  axis = -1
</code></pre>

<p>Then output is <code>[4 x 3]</code>:</p>

<pre><code>```output =
  [5.0 0.0 0.0]  // one_hot(0)
  [0.0 0.0 5.0]  // one_hot(2)
  [0.0 0.0 0.0]  // one_hot(-1)
  [0.0 5.0 0.0]  // one_hot(1)
```
</code></pre>

<p>Suppose that</p>

<pre><code>  indices = [0, 2, -1, 1]
  depth = 3
  on_value = 0.0
  off_value = 3.0
  axis = 0
</code></pre>

<p>Then output is <code>[3 x 4]</code>:</p>

<pre><code>```output =
  [0.0 3.0 3.0 3.0]
  [3.0 3.0 3.0 0.0]
  [3.0 3.0 3.0 3.0]
  [3.0 0.0 3.0 3.0]
//  ^                one_hot(0)
//      ^            one_hot(2)
//          ^        one_hot(-1)
//              ^    one_hot(1)
```
</code></pre>

<p>Suppose that</p>

<pre><code>  indices = [[0, 2], [1, -1]]
  depth = 3
  on_value = 1.0
  off_value = 0.0
  axis = -1
</code></pre>

<p>Then output is <code>[2 x 2 x 3]</code>:</p>

<pre><code>```output =
  [
    [1.0, 0.0, 0.0]  // one_hot(0)
    [0.0, 0.0, 1.0]  // one_hot(2)
  ][
    [0.0, 1.0, 0.0]  // one_hot(1)
    [0.0, 0.0, 0.0]  // one_hot(-1)
  ]```
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>axis</td><td>int</td><td>i: -1
</td><td></td><td><p>The axis to fill (default: -1, a new inner-most axis).</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>TI</td><td>type</td><td>type: DT_INT64
</td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>TI</code></td><td></td><td><p>A tensor of indices.</p>
</td></tr><tr><td><code>depth</code></td><td>DT_INT32</td><td></td><td><p>A scalar defining the depth of the one hot dimension.</p>
</td></tr><tr><td><code>on_value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A scalar defining the value to fill in output when <code>indices[j] = i</code>.</p>
</td></tr><tr><td><code>off_value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A scalar defining the value to fill in output when <code>indices[j] != i</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The one-hot tensor.</p>
</td></tr></table><a name="Pack"></a><h2>TensorFlow <code>Pack</code> Operation</h2><h3>Description</h3><p>Packs the <code>N</code> tensors in <code>values</code> into a tensor with rank one higher than each
tensor in <code>values</code>, by packing them along the <code>axis</code> dimension.
Given a list of tensors of shape <code>(A, B, C)</code>;</p>

<p>if <code>axis == 0</code> then the <code>output</code> tensor will have the shape <code>(N, A, B, C)</code>.
if <code>axis == 1</code> then the <code>output</code> tensor will have the shape <code>(A, N, B, C)</code>.
Etc.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;x&#39; is [1, 4]
# &#39;y&#39; is [2, 5]
# &#39;z&#39; is [3, 6]
pack([x, y, z]) =&gt; [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.
pack([x, y, z], axis=1) =&gt; [[1, 2, 3], [4, 5, 6]]
</code></pre>

<p>This is the opposite of <code>unpack</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>axis</td><td>int</td><td>i: 0
</td><td></td><td><p>Dimension along which to pack.  Negative values wrap around, so the
valid range is <code>[-(R+1), R+1)</code>.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>Must be of same shape and type.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The packed tensor.</p>
</td></tr></table><a name="Pad"></a><h2>TensorFlow <code>Pad</code> Operation</h2><h3>Description</h3><p>This operation pads a <code>input</code> with zeros according to the <code>paddings</code> you
specify. <code>paddings</code> is an integer tensor with shape <code>[Dn, 2]</code>, where n is the
rank of <code>input</code>. For each dimension D of <code>input</code>, <code>paddings[D, 0]</code> indicates
how many zeros to add before the contents of <code>input</code> in that dimension, and
<code>paddings[D, 1]</code> indicates how many zeros to add after the contents of <code>input</code>
in that dimension.</p>

<p>The padded size of each dimension D of the output is:</p>

<p><code>paddings(D, 0) + input.dim_size(D) + paddings(D, 1)</code></p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is [[1, 1], [2, 2]]
# &#39;paddings&#39; is [[1, 1], [2, 2]]
# rank of &#39;t&#39; is 2
pad(t, paddings) ==&gt; [[0, 0, 0, 0, 0, 0]
                      [0, 0, 1, 1, 0, 0]
                      [0, 0, 2, 2, 0, 0]
                      [0, 0, 0, 0, 0, 0]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>paddings</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="PaddingFIFOQueue"></a><h2>TensorFlow <code>PaddingFIFOQueue</code> Operation</h2><h3>Description</h3><p>Variable-size shapes are allowed by setting the corresponding shape dimensions
to 0 in the shape attr.  In this case DequeueMany will pad up to the maximum
size of any given element in the minibatch.  See below for details.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a value.</p>
</td></tr><tr><td>shapes</td><td>list(shape)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>The shape of each component in a value. The length of this attr must
be either 0 or the same as the length of component_types.
Shapes of fixed rank but variable size are allowed by setting
any shape dimension to -1.  In this case, the inputs&#39; shape may vary along
the given dimension, and DequeueMany will pad the given dimension with
zeros up to the maximum shape of all elements in the given batch.
If the length of this attr is 0, different queue elements may have
different ranks and shapes, but only one element may be dequeued at a time.</p>
</td></tr><tr><td>capacity</td><td>int</td><td>i: -1
</td><td></td><td><p>The upper bound on the number of elements in this queue.
Negative numbers mean no limit.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue will be shared under the given name
across multiple sessions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the queue.</p>
</td></tr></table><a name="ParameterizedTruncatedNormal"></a><h2>TensorFlow <code>ParameterizedTruncatedNormal</code> Operation</h2><h3>Description</h3><p>scalar which applies to the entire output, or a vector of length shape[0] which
stores the parameters for each batch.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td><p>The type of the output.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The shape of the output tensor. Batches are indexed by the 0th dimension.</p>
</td></tr><tr><td><code>means</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The mean parameter of each batch.</p>
</td></tr><tr><td><code>stdevs</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The standard deviation parameter of each batch. Must be greater than 0.</p>
</td></tr><tr><td><code>minvals</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The minimum cutoff. May be -infinity.</p>
</td></tr><tr><td><code>maxvals</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The maximum cutoff. May be +infinity, and must be more than the minval
for each batch.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A matrix of shape num<em>batches x samples</em>per_batch, filled with random
truncated normal values using the parameters for each row.</p>
</td></tr></table><a name="ParseExample"></a><h2>TensorFlow <code>ParseExample</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Nsparse</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>Ndense</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>sparse_types</td><td>list(type)</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>0</td><td><p>A list of Nsparse types; the data types of data in each Feature
given in sparse<em>keys.
Currently the ParseExample supports DT</em>FLOAT (FloatList),
DT<em>INT64 (Int64List), and DT</em>STRING (BytesList).</p>
</td></tr><tr><td>Tdense</td><td>list(type)</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>0</td><td></td></tr><tr><td>dense_shapes</td><td>list(shape)</td><td></td><td><b>Minimum: </b>0</td><td><p>A list of Ndense shapes; the shapes of data in each Feature
given in dense<em>keys.
The number of elements in the Feature corresponding to dense</em>key[j]
must always equal dense<em>shapes[j].NumEntries().
If dense</em>shapes[j] == (D0, D1, ..., DN) then the shape of output
Tensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):
The dense outputs are just the inputs row-stacked by batch.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>serialized</code></td><td>DT_STRING</td><td></td><td><p>A vector containing a batch of binary serialized Example protos.</p>
</td></tr><tr><td><code>names</code></td><td>DT_STRING</td><td></td><td><p>A vector containing the names of the serialized protos.
May contain, for example, table key (descriptive) names for the
corresponding serialized protos.  These are purely useful for debugging
purposes, and the presence of values here has no effect on the output.
May also be an empty vector if no names are available.
If non-empty, this vector must be the same length as &quot;serialized&quot;.</p>
</td></tr><tr><td><code>sparse_keys</code></td><td>DT_STRING</td><td><b>number: </b><code><p>Nsparse</p>
</code></td><td><p>A list of Nsparse string Tensors (scalars).
The keys expected in the Examples&#39; features associated with sparse values.</p>
</td></tr><tr><td><code>dense_keys</code></td><td>DT_STRING</td><td><b>number: </b><code><p>Ndense</p>
</code></td><td><p>A list of Ndense string Tensors (scalars).
The keys expected in the Examples&#39; features associated with dense values.</p>
</td></tr><tr><td><code>dense_defaults</code></td><td><b>type list: </b><code>Tdense</code></td><td></td><td><p>A list of Ndense Tensors (some may be empty).
dense<em>defaults[j] provides default values
when the example&#39;s feature</em>map lacks dense<em>key[j].  If an empty Tensor is
provided for dense</em>defaults[j], then the Feature dense<em>keys[j] is required.
The input type is inferred from dense</em>defaults[j], even when it&#39;s empty.
If dense<em>defaults[j] is not empty, its shape must match dense</em>shapes[j].</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sparse_indices</code></td><td>DT_INT64</td><td><b>number: </b><code><p>Nsparse</p>
</code></td><td></td></tr><tr><td><code>sparse_values</code></td><td><b>type list: </b><code>sparse_types</code></td><td></td><td></td></tr><tr><td><code>sparse_shapes</code></td><td>DT_INT64</td><td><b>number: </b><code><p>Nsparse</p>
</code></td><td></td></tr><tr><td><code>dense_values</code></td><td><b>type list: </b><code>Tdense</code></td><td></td><td></td></tr></table><a name="ParseSingleSequenceExample"></a><h2>TensorFlow <code>ParseSingleSequenceExample</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Ncontext_sparse</td><td>int</td><td>i: 0
</td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>Ncontext_dense</td><td>int</td><td>i: 0
</td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>Nfeature_list_sparse</td><td>int</td><td>i: 0
</td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>Nfeature_list_dense</td><td>int</td><td>i: 0
</td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>context_sparse_types</td><td>list(type)</td><td>list {
}
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>0</td><td><p>A list of Ncontext<em>sparse types; the data types of data in
each context Feature given in context</em>sparse<em>keys.
Currently the ParseSingleSequenceExample supports DT</em>FLOAT (FloatList),
DT<em>INT64 (Int64List), and DT</em>STRING (BytesList).</p>
</td></tr><tr><td>Tcontext_dense</td><td>list(type)</td><td>list {
}
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>0</td><td></td></tr><tr><td>feature_list_dense_types</td><td>list(type)</td><td>list {
}
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>0</td><td></td></tr><tr><td>context_dense_shapes</td><td>list(shape)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>A list of Ncontext<em>dense shapes; the shapes of data in
each context Feature given in context</em>dense<em>keys.
The number of elements in the Feature corresponding to context</em>dense<em>key[j]
must always equal context</em>dense<em>shapes[j].NumEntries().
The shape of context</em>dense<em>values[j] will match context</em>dense_shapes[j].</p>
</td></tr><tr><td>feature_list_sparse_types</td><td>list(type)</td><td>list {
}
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT64</code></li><li><code>DT_STRING</code></li></ul><b>Minimum: </b>0</td><td><p>A list of Nfeature<em>list</em>sparse types; the data types
of data in each FeatureList given in feature<em>list</em>sparse<em>keys.
Currently the ParseSingleSequenceExample supports DT</em>FLOAT (FloatList),
DT<em>INT64 (Int64List), and DT</em>STRING (BytesList).</p>
</td></tr><tr><td>feature_list_dense_shapes</td><td>list(shape)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>A list of Nfeature<em>list</em>dense shapes; the shapes of
data in each FeatureList given in feature<em>list</em>dense<em>keys.
The shape of each Feature in the FeatureList corresponding to
feature</em>list<em>dense</em>key[j] must always equal
feature<em>list</em>dense_shapes[j].NumEntries().</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>serialized</code></td><td>DT_STRING</td><td></td><td><p>A scalar containing a binary serialized SequenceExample proto.</p>
</td></tr><tr><td><code>feature_list_dense_missing_assumed_empty</code></td><td>DT_STRING</td><td></td><td><p>A vector listing the
FeatureList keys which may be missing from the SequenceExample.  If the
associated FeatureList is missing, it is treated as empty.  By default,
any FeatureList not listed in this vector must exist in the SequenceExample.</p>
</td></tr><tr><td><code>context_sparse_keys</code></td><td>DT_STRING</td><td><b>number: </b><code><p>Ncontext_sparse</p>
</code></td><td><p>A list of Ncontext<em>sparse string Tensors (scalars).
The keys expected in the Examples&#39; features associated with context</em>sparse
values.</p>
</td></tr><tr><td><code>context_dense_keys</code></td><td>DT_STRING</td><td><b>number: </b><code><p>Ncontext_dense</p>
</code></td><td><p>A list of Ncontext_dense string Tensors (scalars).
The keys expected in the SequenceExamples&#39; context features associated with
dense values.</p>
</td></tr><tr><td><code>feature_list_sparse_keys</code></td><td>DT_STRING</td><td><b>number: </b><code><p>Nfeature<em>list</em>sparse</p>
</code></td><td><p>A list of Nfeature<em>list</em>sparse string Tensors
(scalars).  The keys expected in the FeatureLists associated with sparse
values.</p>
</td></tr><tr><td><code>feature_list_dense_keys</code></td><td>DT_STRING</td><td><b>number: </b><code><p>Nfeature<em>list</em>dense</p>
</code></td><td><p>A list of Nfeature<em>list</em>dense string Tensors (scalars).
The keys expected in the SequenceExamples&#39; feature_lists associated
with lists of dense values.</p>
</td></tr><tr><td><code>context_dense_defaults</code></td><td><b>type list: </b><code>Tcontext_dense</code></td><td></td><td><p>A list of Ncontext<em>dense Tensors (some may be empty).
context</em>dense<em>defaults[j] provides default values
when the SequenceExample&#39;s context map lacks context</em>dense<em>key[j].
If an empty Tensor is provided for context</em>dense<em>defaults[j],
then the Feature context</em>dense<em>keys[j] is required.
The input type is inferred from context</em>dense<em>defaults[j], even when it&#39;s
empty.  If context</em>dense<em>defaults[j] is not empty, its shape must match
context</em>dense_shapes[j].</p>
</td></tr><tr><td><code>debug_name</code></td><td>DT_STRING</td><td></td><td><p>A scalar containing the name of the serialized proto.
May contain, for example, table key (descriptive) name for the
corresponding serialized proto.  This is purely useful for debugging
purposes, and the presence of values here has no effect on the output.
May also be an empty scalar if no name is available.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>context_sparse_indices</code></td><td>DT_INT64</td><td><b>number: </b><code><p>Ncontext_sparse</p>
</code></td><td></td></tr><tr><td><code>context_sparse_values</code></td><td><b>type list: </b><code>context_sparse_types</code></td><td></td><td></td></tr><tr><td><code>context_sparse_shapes</code></td><td>DT_INT64</td><td><b>number: </b><code><p>Ncontext_sparse</p>
</code></td><td></td></tr><tr><td><code>context_dense_values</code></td><td><b>type list: </b><code>Tcontext_dense</code></td><td></td><td></td></tr><tr><td><code>feature_list_sparse_indices</code></td><td>DT_INT64</td><td><b>number: </b><code><p>Nfeature<em>list</em>sparse</p>
</code></td><td></td></tr><tr><td><code>feature_list_sparse_values</code></td><td><b>type list: </b><code>feature_list_sparse_types</code></td><td></td><td></td></tr><tr><td><code>feature_list_sparse_shapes</code></td><td>DT_INT64</td><td><b>number: </b><code><p>Nfeature<em>list</em>sparse</p>
</code></td><td></td></tr><tr><td><code>feature_list_dense_values</code></td><td><b>type list: </b><code>feature_list_dense_types</code></td><td></td><td></td></tr></table><a name="Placeholder"></a><h2>TensorFlow <code>Placeholder</code> Operation</h2><h3>Description</h3><p>N.B. This operation will fail with an error if it is executed. It is
intended as a way to represent a value that will always be fed, and to
provide attrs that enable the fed value to be checked at runtime.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of elements in the tensor.</p>
</td></tr><tr><td>shape</td><td>shape</td><td>shape {
}
</td><td></td><td><p>(Optional) The shape of the tensor. If the shape has 0 dimensions, the
shape is unconstrained.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A placeholder tensor that must be replaced using the feed mechanism.</p>
</td></tr></table><a name="PlaceholderWithDefault"></a><h2>TensorFlow <code>PlaceholderWithDefault</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of elements in the tensor.</p>
</td></tr><tr><td>shape</td><td>shape</td><td></td><td></td><td><p>The (possibly partial) shape of the tensor.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The default value to produce when <code>output</code> is not fed.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A placeholder tensor that defaults to <code>input</code> if it is not fed.</p>
</td></tr></table><a name="Polygamma"></a><h2>TensorFlow <code>Polygamma</code> Operation</h2><h3>Description</h3><p>The polygamma function is defined as:</p>

<pre><code>\psi^{(n)}(x) = \frac{d^n}{dx^n} \psi(x)
</code></pre>

<p>where \(\psi(x)\) is the digamma function.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Pow"></a><h2>TensorFlow <code>Pow</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>x</code> and a tensor <code>y</code>, this operation computes \(x^y\) for
corresponding elements in <code>x</code> and <code>y</code>. For example:</p>

<pre><code># tensor &#39;x&#39; is [[2, 2]], [3, 3]]
# tensor &#39;y&#39; is [[8, 16], [2, 3]]
tf.pow(x, y) ==&gt; [[256, 65536], [9, 27]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Print"></a><h2>TensorFlow <code>Print</code> Operation</h2><h3>Description</h3><p>Passes <code>input</code> through to <code>output</code> and prints <code>data</code> when evaluating.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>U</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>message</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>A string, prefix of the error message.</p>
</td></tr><tr><td>first_n</td><td>int</td><td>i: -1
</td><td></td><td><p>Only log <code>first_n</code> number of times. -1 disables logging.</p>
</td></tr><tr><td>summarize</td><td>int</td><td>i: 3
</td><td></td><td><p>Only print this many entries of each tensor.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor passed to <code>output</code></p>
</td></tr><tr><td><code>data</code></td><td><b>type list: </b><code>U</code></td><td></td><td><p>A list of tensors to print out when op is evaluated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= The unmodified <code>input</code> tensor</p>
</td></tr></table><a name="PriorityQueue"></a><h2>TensorFlow <code>PriorityQueue</code> Operation</h2><h3>Description</h3><p>Note that the PriorityQueue requires the first component of any element
to be a scalar int64, in addition to the other elements declared by
component_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue
and DequeueMany) on a PriorityQueue will all require (resp. output) one extra
entry in their input (resp. output) lists.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>The type of each component in a value.</p>
</td></tr><tr><td>shapes</td><td>list(shape)</td><td></td><td><b>Minimum: </b>0</td><td><p>The shape of each component in a value. The length of this attr must
be either 0 or the same as the length of component_types. If the length of
this attr is 0, the shapes of queue elements are not constrained, and
only one element may be dequeued at a time.</p>
</td></tr><tr><td>capacity</td><td>int</td><td>i: -1
</td><td></td><td><p>The upper bound on the number of elements in this queue.
Negative numbers mean no limit.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue will be shared under the given name
across multiple sessions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the queue.</p>
</td></tr></table><a name="Prod"></a><h2>TensorFlow <code>Prod</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="PyFunc"></a><h2>TensorFlow <code>PyFunc</code> Operation</h2><h3>Description</h3><p>This operation is considered stateful. For a stateless version, see
PyFuncStateless.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>token</td><td>string</td><td></td><td></td><td><p>A token representing a registered python function in this address space.</p>
</td></tr><tr><td>Tin</td><td>list(type)</td><td></td><td><b>Minimum: </b>0</td><td><p>Data types of the inputs to the op.</p>
</td></tr><tr><td>Tout</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>Data types of the outputs from the op.
The length of the list specifies the number of outputs.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>type list: </b><code>Tin</code></td><td></td><td><p>List of Tensors that will provide input to the Op.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>type list: </b><code>Tout</code></td><td></td><td><p>The outputs from the Op.</p>
</td></tr></table><a name="PyFuncStateless"></a><h2>TensorFlow <code>PyFuncStateless</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>token</td><td>string</td><td></td><td></td><td></td></tr><tr><td>Tin</td><td>list(type)</td><td></td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>Tout</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>type list: </b><code>Tin</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>type list: </b><code>Tout</code></td><td></td><td></td></tr></table><a name="QuantizeAndDequantize"></a><h2>TensorFlow <code>QuantizeAndDequantize</code> Operation</h2><h3>Description</h3><p>This op simulates the precision loss from the quantized forward pass by:
1. Quantizing the tensor to fixed point numbers, which should match the target
   quantization method when it is used in inference.
2. Dequantizing it back to floating point numbers for the following ops, most
   likely matmul.</p>

<p>There are different ways to quantize. This version does not use the full range
of the output type, choosing to elide the lowest possible value for symmetry
(e.g., output range is -127 to 127, not -128 to 127 for signed 8 bit
quantization), so that 0.0 maps to 0.</p>

<p>To perform this op, we first find the range of values in our tensor. The range
we use is always centered on 0, so we find m such that</p>

<ol>
<li>m = max(abs(input<em>min), abs(input</em>max)) if range_given is true,</li>
<li>m = max(max(abs(min<em>elem(input)), abs(max</em>elem(input))) otherwise.</li>
</ol>

<p>Our input tensor range is then [-m, m].</p>

<p>Next, we choose our fixed-point quantization buckets, [min<em>fixed, max</em>fixed].
If signed_input is true, this is</p>

<p>[min<em>fixed, max</em>fixed ] =
      [-(1 &lt;&lt; (num<em>bits - 1) - 1), (1 &lt;&lt; (num</em>bits - 1)) - 1].</p>

<p>Otherwise, if signed_input is false, the fixed-point range is</p>

<p>[min<em>fixed, max</em>fixed] = [0, (1 &lt;&lt; num_bits) - 1].</p>

<p>From this we compute our scaling factor, s:</p>

<p>s = (max<em>fixed - min</em>fixed) / (2 * m).</p>

<p>Now we can quantize and dequantize the elements of our tensor.  An element e
is transformed into e&#39;:</p>

<p>e&#39; = (e * s).round<em>to</em>nearest() / s.</p>

<p>Note that we have a different number of buckets in the signed vs. unsigned
cases.  For example, if num_bits == 8, we get 254 buckets in the signed case
vs. 255 in the unsigned case.</p>

<p>For example, suppose num_bits = 8 and m = 1.  Then</p>

<p>[min<em>fixed, max</em>fixed] = [-127, 127], and
  s = (127 + 127) / 2 = 127.</p>

<p>Given the vector {-1, -0.5, 0, 0.3}, this is quantized to
{-127, -63, 0, 38}, and dequantized to {-1, -63.0/127, 0, 38.0/127}.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>signed_input</td><td>bool</td><td>b: true
</td><td></td><td><p>If the quantization is signed or unsigned.</p>
</td></tr><tr><td>num_bits</td><td>int</td><td>i: 8
</td><td></td><td><p>The bitwidth of the quantization.</p>
</td></tr><tr><td>range_given</td><td>bool</td><td>b: false
</td><td></td><td><p>If the range is given or should be computed from the tensor.</p>
</td></tr><tr><td>input_min</td><td>float</td><td>f: 0
</td><td></td><td><p>If range is given, this is the min of the range.</p>
</td></tr><tr><td>input_max</td><td>float</td><td>f: 0
</td><td></td><td><p>If range is given, this is the max of the range.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Tensor to quantize and then dequantize.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="QueueClose"></a><h2>TensorFlow <code>QueueClose</code> Operation</h2><h3>Description</h3><p>This operation signals that no more elements will be enqueued in the
given queue. Subsequent Enqueue(Many) operations will fail.
Subsequent Dequeue(Many) operations will continue to succeed if
sufficient elements remain in the queue. Subsequent Dequeue(Many)
operations that would block will fail immediately.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>cancel_pending_enqueues</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, all pending enqueue requests that are
blocked on the given queue will be cancelled.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr></table><a name="QueueDequeue"></a><h2>TensorFlow <code>QueueDequeue</code> Operation</h2><h3>Description</h3><p>This operation has k outputs, where k is the number of components
in the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.</p>

<p>N.B. If the queue is empty, this operation will block until an element
has been dequeued (or &#39;timeout_ms&#39; elapses, if specified).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a tuple.</p>
</td></tr><tr><td>timeout_ms</td><td>int</td><td>i: -1
</td><td></td><td><p>If the queue is empty, this operation will block for up to
timeout_ms milliseconds.
Note: This option is not supported yet.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>components</code></td><td><b>type list: </b><code>component_types</code></td><td></td><td><p>One or more tensors that were dequeued as a tuple.</p>
</td></tr></table><a name="QueueDequeueMany"></a><h2>TensorFlow <code>QueueDequeueMany</code> Operation</h2><h3>Description</h3><p>If the queue is closed and there are fewer than n elements, then an
OutOfRange error is returned.</p>

<p>This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor.  All of the components
in the dequeued tuple will have size n in the 0th dimension.</p>

<p>This operation has k outputs, where k is the number of components in
the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.</p>

<p>N.B. If the queue is empty, this operation will block until n elements
have been dequeued (or &#39;timeout_ms&#39; elapses, if specified).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a tuple.</p>
</td></tr><tr><td>timeout_ms</td><td>int</td><td>i: -1
</td><td></td><td><p>If the queue has fewer than n elements, this operation
will block for up to timeout_ms milliseconds.
Note: This option is not supported yet.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr><tr><td><code>n</code></td><td>DT_INT32</td><td></td><td><p>The number of tuples to dequeue.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>components</code></td><td><b>type list: </b><code>component_types</code></td><td></td><td><p>One or more tensors that were dequeued as a tuple.</p>
</td></tr></table><a name="QueueDequeueUpTo"></a><h2>TensorFlow <code>QueueDequeueUpTo</code> Operation</h2><h3>Description</h3><p>This operation is not supported by all queues.  If a queue does not support
DequeueUpTo, then an Unimplemented error is returned.</p>

<p>If the queue is closed and there are more than 0 but less than n elements
remaining, then instead of returning an OutOfRange error like
QueueDequeueMany, less than <code>n</code> elements are returned immediately.  If the queue
is closed and there are 0 elements left in the queue, then an OutOfRange
error is returned just like in QueueDequeueMany.  Otherwise the behavior
is identical to QueueDequeueMany:</p>

<p>This operation concatenates queue-element component tensors along the
0th dimension to make a single component tensor.  All of the components
in the dequeued tuple will have size n in the 0th dimension.</p>

<p>This operation has k outputs, where k is the number of components in
the tuples stored in the given queue, and output i is the ith
component of the dequeued tuple.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a tuple.</p>
</td></tr><tr><td>timeout_ms</td><td>int</td><td>i: -1
</td><td></td><td><p>If the queue has fewer than n elements, this operation
will block for up to timeout_ms milliseconds.
Note: This option is not supported yet.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr><tr><td><code>n</code></td><td>DT_INT32</td><td></td><td><p>The number of tuples to dequeue.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>components</code></td><td><b>type list: </b><code>component_types</code></td><td></td><td><p>One or more tensors that were dequeued as a tuple.</p>
</td></tr></table><a name="QueueEnqueue"></a><h2>TensorFlow <code>QueueEnqueue</code> Operation</h2><h3>Description</h3><p>The components input has k elements, which correspond to the components of
tuples stored in the given queue.</p>

<p>N.B. If the queue is full, this operation will block until the given
element has been enqueued (or &#39;timeout_ms&#39; elapses, if specified).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tcomponents</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>timeout_ms</td><td>int</td><td>i: -1
</td><td></td><td><p>If the queue is full, this operation will block for up to
timeout_ms milliseconds.
Note: This option is not supported yet.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr><tr><td><code>components</code></td><td><b>type list: </b><code>Tcomponents</code></td><td></td><td><p>One or more tensors from which the enqueued tensors should be taken.</p>
</td></tr></table><a name="QueueEnqueueMany"></a><h2>TensorFlow <code>QueueEnqueueMany</code> Operation</h2><h3>Description</h3><p>This operation slices each component tensor along the 0th dimension to
make multiple queue elements. All of the tuple components must have the
same size in the 0th dimension.</p>

<p>The components input has k elements, which correspond to the components of
tuples stored in the given queue.</p>

<p>N.B. If the queue is full, this operation will block until the given
elements have been enqueued (or &#39;timeout_ms&#39; elapses, if specified).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tcomponents</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>timeout_ms</td><td>int</td><td>i: -1
</td><td></td><td><p>If the queue is too full, this operation will block for up
to timeout_ms milliseconds.
Note: This option is not supported yet.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr><tr><td><code>components</code></td><td><b>type list: </b><code>Tcomponents</code></td><td></td><td><p>One or more tensors from which the enqueued tensors should
be taken.</p>
</td></tr></table><a name="QueueSize"></a><h2>TensorFlow <code>QueueSize</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a queue.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>The number of elements in the given queue.</p>
</td></tr></table><a name="RGBToHSV"></a><h2>TensorFlow <code>RGBToHSV</code> Operation</h2><h3>Description</h3><p>Outputs a tensor of the same shape as the <code>images</code> tensor, containing the HSV
value of the pixels. The output is only well defined if the value in <code>images</code>
are in <code>[0,1]</code>.</p>

<p><code>output[..., 0]</code> contains hue, <code>output[..., 1]</code> contains saturation, and
<code>output[..., 2]</code> contains value. All HSV values are in <code>[0,1]</code>. A hue of 0
corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D or higher rank. RGB data to convert. Last dimension must be size 3.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>images</code> converted to HSV.</p>
</td></tr></table><a name="RandomCrop"></a><h2>TensorFlow <code>RandomCrop</code> Operation</h2><h3>Description</h3><p><code>size</code> is a 1-D int64 tensor with 2 elements representing the crop height and
width.  The values must be non negative.</p>

<p>This Op picks a random location in <code>image</code> and crops a <code>height</code> by <code>width</code>
rectangle from that location.  The random location is picked so the cropped
area will fit inside the original image.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D of shape <code>[height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT64</td><td></td><td><p>1-D of length 2 containing: <code>crop_height</code>, <code>crop_width</code>..</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>3-D of shape <code>[crop_height, crop_width, channels].</code></p>
</td></tr></table><a name="RandomGamma"></a><h2>TensorFlow <code>RandomGamma</code> Operation</h2><h3>Description</h3><p>This op uses the algorithm by Marsaglia et al. to acquire samples via
transformation-rejection from pairs of uniform and normal random variables.
See http://dl.acm.org/citation.cfm?id=358414</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>S</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>S</code></td><td></td><td><p>1-D integer tensor. Shape of independent samples to draw from each
distribution described by the shape parameters given in alpha.</p>
</td></tr><tr><td><code>alpha</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor in which each scalar is a &quot;shape&quot; parameter describing the
associated gamma distribution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor with shape <code>shape + shape(alpha)</code>. Each slice
<code>[:, ..., :, i0, i1, ...iN]</code> contains the samples drawn for
<code>alpha[i0, i1, ...iN]</code>. The dtype of the output matches the dtype of alpha.</p>
</td></tr></table><a name="RandomShuffle"></a><h2>TensorFlow <code>RandomShuffle</code> Operation</h2><h3>Description</h3><p>The tensor is shuffled along dimension 0, such that each <code>value[j]</code> is mapped
  to one and only one <code>output[i]</code>. For example, a mapping that might occur for a
  3x2 tensor is:</p>

<pre><code class="language-prettyprint">[[1, 2],       [[5, 6],
 [3, 4],  ==&gt;   [1, 2],
 [5, 6]]        [3, 4]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be shuffled.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor of same shape and type as <code>value</code>, shuffled along its first
dimension.</p>
</td></tr></table><a name="RandomShuffleQueue"></a><h2>TensorFlow <code>RandomShuffleQueue</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>component_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>The type of each component in a value.</p>
</td></tr><tr><td>shapes</td><td>list(shape)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>The shape of each component in a value. The length of this attr must
be either 0 or the same as the length of component_types. If the length of
this attr is 0, the shapes of queue elements are not constrained, and
only one element may be dequeued at a time.</p>
</td></tr><tr><td>capacity</td><td>int</td><td>i: -1
</td><td></td><td><p>The upper bound on the number of elements in this queue.
Negative numbers mean no limit.</p>
</td></tr><tr><td>min_after_dequeue</td><td>int</td><td>i: 0
</td><td></td><td><p>Dequeue will block unless there would be this
many elements after the dequeue or the queue is closed. This
ensures a minimum level of mixing of elements.</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 is set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, a random seed is used.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this queue will be shared under the given name
across multiple sessions.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the queue.</p>
</td></tr></table><a name="RandomStandardNormal"></a><h2>TensorFlow <code>RandomStandardNormal</code> Operation</h2><h3>Description</h3><p>The generated values will have mean 0 and standard deviation 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td><p>The type of the output.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The shape of the output tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A tensor of the specified shape filled with random normal values.</p>
</td></tr></table><a name="RandomUniform"></a><h2>TensorFlow <code>RandomUniform</code> Operation</h2><h3>Description</h3><p>The generated values follow a uniform distribution in the range <code>[0, 1)</code>. The
lower bound 0 is included in the range, while the upper bound 1 is excluded.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td><p>The type of the output.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The shape of the output tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A tensor of the specified shape filled with uniform random values.</p>
</td></tr></table><a name="RandomUniformInt"></a><h2>TensorFlow <code>RandomUniformInt</code> Operation</h2><h3>Description</h3><p>The generated values are uniform integers in the range <code>[minval, maxval)</code>.
The lower bound <code>minval</code> is included in the range, while the upper bound
<code>maxval</code> is excluded.</p>

<p>The random integers are slightly biased unless <code>maxval - minval</code> is an exact
power of two.  The bias is small for values of <code>maxval - minval</code> significantly
smaller than the range of the output (either <code>2^32</code> or <code>2^64</code>).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>Tout</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The shape of the output tensor.</p>
</td></tr><tr><td><code>minval</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td><p>0-D.  Inclusive lower bound on the generated integers.</p>
</td></tr><tr><td><code>maxval</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td><p>0-D.  Exclusive upper bound on the generated integers.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td><p>A tensor of the specified shape filled with uniform random integers.</p>
</td></tr></table><a name="Range"></a><h2>TensorFlow <code>Range</code> Operation</h2><h3>Description</h3><p>This operation creates a sequence of integers that begins at <code>start</code> and
extends by increments of <code>delta</code> up to but not including <code>limit</code>.</p>

<p>For example:</p>

<pre><code># &#39;start&#39; is 3
# &#39;limit&#39; is 18
# &#39;delta&#39; is 3
tf.range(start, limit, delta) ==&gt; [3, 6, 9, 12, 15]
</code></pre>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>start</code></td><td>DT_INT32</td><td></td><td><p>0-D (scalar). First entry in the sequence.</p>
</td></tr><tr><td><code>limit</code></td><td>DT_INT32</td><td></td><td><p>0-D (scalar). Upper limit of sequence, exclusive.</p>
</td></tr><tr><td><code>delta</code></td><td>DT_INT32</td><td></td><td><p>0-D (scalar). Optional. Default is 1. Number that increments <code>start</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT32</td><td></td><td><p>1-D.</p>
</td></tr></table><a name="Rank"></a><h2>TensorFlow <code>Rank</code> Operation</h2><h3>Description</h3><p>This operation returns an integer representing the rank of <code>input</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
# shape of tensor &#39;t&#39; is [2, 2, 3]
rank(t) ==&gt; 3
</code></pre>

<p><strong>Note</strong>: The rank of a tensor is not the same as the rank of a matrix. The rank
of a tensor is the number of indices required to uniquely select each element
of the tensor. Rank is also known as &quot;order&quot;, &quot;degree&quot;, or &quot;ndims.&quot;</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="ReadFile"></a><h2>TensorFlow <code>ReadFile</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filename</code></td><td>DT_STRING</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>contents</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="ReaderNumRecordsProduced"></a><h2>TensorFlow <code>ReaderNumRecordsProduced</code> Operation</h2><h3>Description</h3><p>This is the same as the number of ReaderRead executions that have
succeeded.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Reader.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>records_produced</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="ReaderNumWorkUnitsCompleted"></a><h2>TensorFlow <code>ReaderNumWorkUnitsCompleted</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Reader.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>units_completed</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="ReaderRead"></a><h2>TensorFlow <code>ReaderRead</code> Operation</h2><h3>Description</h3><p>Will dequeue from the input queue if necessary (e.g. when the
Reader needs to start reading from a new file since it has finished
with the previous file).</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Reader.</p>
</td></tr><tr><td><code>queue_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Queue, with string work items.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>key</code></td><td>DT_STRING</td><td></td><td><p>A scalar.</p>
</td></tr><tr><td><code>value</code></td><td>DT_STRING</td><td></td><td><p>A scalar.</p>
</td></tr></table><a name="ReaderReadUpTo"></a><h2>TensorFlow <code>ReaderReadUpTo</code> Operation</h2><h3>Description</h3><p>Will dequeue from the input queue if necessary (e.g. when the
Reader needs to start reading from a new file since it has finished
with the previous file).
It may return less than <code>num_records</code> even before the last batch.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a <code>Reader</code>.</p>
</td></tr><tr><td><code>queue_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a <code>Queue</code>, with string work items.</p>
</td></tr><tr><td><code>num_records</code></td><td>DT_INT64</td><td></td><td><p>number of records to read from <code>Reader</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>keys</code></td><td>DT_STRING</td><td></td><td><p>A 1-D tensor.</p>
</td></tr><tr><td><code>values</code></td><td>DT_STRING</td><td></td><td><p>A 1-D tensor.</p>
</td></tr></table><a name="ReaderReset"></a><h2>TensorFlow <code>ReaderReset</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Reader.</p>
</td></tr></table><a name="ReaderRestoreState"></a><h2>TensorFlow <code>ReaderRestoreState</code> Operation</h2><h3>Description</h3><p>Not all Readers support being restored, so this can produce an
Unimplemented error.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Reader.</p>
</td></tr><tr><td><code>state</code></td><td>DT_STRING</td><td></td><td><p>Result of a ReaderSerializeState of a Reader with type
matching reader_handle.</p>
</td></tr></table><a name="ReaderSerializeState"></a><h2>TensorFlow <code>ReaderSerializeState</code> Operation</h2><h3>Description</h3><p>Not all Readers support being serialized, so this can produce an
Unimplemented error.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>Handle to a Reader.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>state</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="Real"></a><h2>TensorFlow <code>Real</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>input</code> of complex numbers, this operation returns a tensor of
type <code>float</code> that is the real part of each element in <code>input</code>. All elements in
<code>input</code> must be complex numbers of the form \(a + bj\), where <em>a</em> is the real
 part returned by this operation and <em>b</em> is the imaginary part.</p>

<p>For example:</p>

<pre><code># tensor &#39;input&#39; is [-2.25 + 4.75j, 3.25 + 5.75j]
tf.real(input) ==&gt; [-2.25, 3.25]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td>type: DT_COMPLEX64
</td><td><b>One of: </b><ul><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr><tr><td>Tout</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>Tout</code></td><td></td><td></td></tr></table><a name="ReduceJoin"></a><h2>TensorFlow <code>ReduceJoin</code> Operation</h2><h3>Description</h3><p>Computes the string join across dimensions in the given string Tensor of shape
<code>[d_0, d_1, ..., d_n-1]</code>.  Returns a new Tensor created by joining the input
strings with the given separator (default: empty string).  Negative indices are
counted backwards from the end, with <code>-1</code> being equivalent to <code>n - 1</code>.  Passing
an empty <code>reduction_indices</code> joins all strings in linear index order and outputs
a scalar string.</p>

<p>For example:
```</p>

<h1>tensor <code>a</code> is [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]</h1>

<p>tf.reduce<em>join(a, 0) ==&gt; [&quot;ac&quot;, &quot;bd&quot;]
tf.reduce</em>join(a, 1) ==&gt; [&quot;ab&quot;, &quot;cd&quot;]
tf.reduce<em>join(a, -2) = tf.reduce</em>join(a, 0) ==&gt; [&quot;ac&quot;, &quot;bd&quot;]
tf.reduce<em>join(a, -1) = tf.reduce</em>join(a, 1) ==&gt; [&quot;ab&quot;, &quot;cd&quot;]
tf.reduce<em>join(a, 0, keep</em>dims=True) ==&gt; [[&quot;ac&quot;, &quot;bd&quot;]]
tf.reduce<em>join(a, 1, keep</em>dims=True) ==&gt; [[&quot;ab&quot;], [&quot;cd&quot;]]
tf.reduce<em>join(a, 0, separator=&quot;.&quot;) ==&gt; [&quot;a.c&quot;, &quot;b.d&quot;]
tf.reduce</em>join(a, [0, 1]) ==&gt; [&quot;acbd&quot;]
tf.reduce<em>join(a, [1, 0]) ==&gt; [&quot;abcd&quot;]
tf.reduce</em>join(a, []) ==&gt; [&quot;abcd&quot;]
```</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, retain reduced dimensions with length <code>1</code>.</p>
</td></tr><tr><td>separator</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>The separator to use when joining.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td>DT_STRING</td><td></td><td><p>The input to be joined.  All reduced indices must have non-zero size.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce over.  Dimensions are reduced in the
order specified.  If <code>reduction_indices</code> has higher rank than <code>1</code>, it is
flattened.  Omitting <code>reduction_indices</code> is equivalent to passing
<code>[n-1, n-2, ..., 0]</code>.  Negative indices from <code>-n</code> to <code>-1</code> are supported.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_STRING</td><td></td><td><p>Has shape equal to that of the input with reduced dimensions removed or
set to <code>1</code> depending on <code>keep_dims</code>.</p>
</td></tr></table><a name="RefEnter"></a><h2>TensorFlow <code>RefEnter</code> Operation</h2><h3>Description</h3><p>The unique <code>frame_name</code> is used by the <code>Executor</code> to identify frames. If
<code>is_constant</code> is true, <code>output</code> is a constant in the child frame; otherwise
it may be changed in the child frame. At most <code>parallel_iterations</code> iterations
are run in parallel in the child frame.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>frame_name</td><td>string</td><td></td><td></td><td><p>The name of the child frame.</p>
</td></tr><tr><td>is_constant</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, the output is constant within the child frame.</p>
</td></tr><tr><td>parallel_iterations</td><td>int</td><td>i: 10
</td><td></td><td><p>The number of iterations allowed to run in parallel.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be made available to the child frame.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as <code>data</code>.</p>
</td></tr></table><a name="RefExit"></a><h2>TensorFlow <code>RefExit</code> Operation</h2><h3>Description</h3><p>Exit makes its input <code>data</code> available to the parent frame.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be made available to the parent frame.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as <code>data</code>.</p>
</td></tr></table><a name="RefIdentity"></a><h2>TensorFlow <code>RefIdentity</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="RefMerge"></a><h2>TensorFlow <code>RefMerge</code> Operation</h2><h3>Description</h3><p><code>Merge</code> waits for at least one of the tensors in <code>inputs</code> to become available.
It is usually combined with <code>Switch</code> to implement branching.</p>

<p><code>Merge</code> forwards the first tensor for become available to <code>output</code>, and sets
<code>value_index</code> to its index in <code>inputs</code>.</p>

<p>It is an error if more than one tensor in <code>inputs</code> is available.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>The input tensors, exactly one of which will become available.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Will be set to the available input tensor.</p>
</td></tr><tr><td><code>value_index</code></td><td>DT_INT32</td><td></td><td><p>The index of the chosen input tensor in <code>inputs</code>.</p>
</td></tr></table><a name="RefNextIteration"></a><h2>TensorFlow <code>RefNextIteration</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be made available to the next iteration.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as <code>data</code>.</p>
</td></tr></table><a name="RefSelect"></a><h2>TensorFlow <code>RefSelect</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>index</code></td><td>DT_INT32</td><td></td><td><p>A scalar that determines the input that gets selected.</p>
</td></tr><tr><td><code>inputs</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>A list of ref tensors, one of which will be forwarded to <code>output</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The forwarded tensor.</p>
</td></tr></table><a name="RefSwitch"></a><h2>TensorFlow <code>RefSwitch</code> Operation</h2><h3>Description</h3><p>If <code>pred</code> is true, the <code>data</code> input is forwarded to <code>output_true</code>. Otherwise,
the data goes to <code>output_false</code>.</p>

<p>See also <code>Switch</code> and <code>Merge</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The ref tensor to be forwarded to the appropriate output.</p>
</td></tr><tr><td><code>pred</code></td><td>DT_BOOL</td><td></td><td><p>A scalar that specifies which output port will receive data.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_false</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>If <code>pred</code> is false, data will be forwarded to this output.</p>
</td></tr><tr><td><code>output_true</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>If <code>pred</code> is true, data will be forwarded to this output.</p>
</td></tr></table><a name="Relu"></a><h2>TensorFlow <code>Relu</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>activations</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Relu6"></a><h2>TensorFlow <code>Relu6</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>activations</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Relu6Grad"></a><h2>TensorFlow <code>Relu6Grad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>gradients</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The backpropagated gradients to the corresponding Relu6 operation.</p>
</td></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The features passed as input to the corresponding Relu6 operation.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>backprops</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradients:
<code>gradients * features * (features &gt; 0) * (features &lt; 6)</code>.</p>
</td></tr></table><a name="ReluGrad"></a><h2>TensorFlow <code>ReluGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>gradients</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The backpropagated gradients to the corresponding Relu operation.</p>
</td></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The features passed as input to the corresponding Relu operation, OR
the outputs of that operation (both work equivalently).</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>backprops</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>gradients * (features &gt; 0)</code>.</p>
</td></tr></table><a name="Reshape"></a><h2>TensorFlow <code>Reshape</code> Operation</h2><h3>Description</h3><p>Given <code>tensor</code>, this operation returns a tensor that has the same values
as <code>tensor</code> with shape <code>shape</code>.</p>

<p>If one component of <code>shape</code> is the special value -1, the size of that dimension
is computed so that the total size remains constant.  In particular, a <code>shape</code>
of <code>[-1]</code> flattens into 1-D.  At most one component of <code>shape</code> can be -1.</p>

<p>If <code>shape</code> is 1-D or higher, then the operation returns a tensor with shape
<code>shape</code> filled with the values of <code>tensor</code>. In this case, the number of elements
implied by <code>shape</code> must be the same as the number of elements in <code>tensor</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># tensor &#39;t&#39; is [1, 2, 3, 4, 5, 6, 7, 8, 9]
# tensor &#39;t&#39; has shape [9]
reshape(t, [3, 3]) ==&gt; [[1, 2, 3],
                        [4, 5, 6],
                        [7, 8, 9]]

# tensor &#39;t&#39; is [[[1, 1], [2, 2]],
#                [[3, 3], [4, 4]]]
# tensor &#39;t&#39; has shape [2, 2, 2]
reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2],
                        [3, 3, 4, 4]]

# tensor &#39;t&#39; is [[[1, 1, 1],
#                 [2, 2, 2]],
#                [[3, 3, 3],
#                 [4, 4, 4]],
#                [[5, 5, 5],
#                 [6, 6, 6]]]
# tensor &#39;t&#39; has shape [3, 2, 3]
# pass &#39;[-1]&#39; to flatten &#39;t&#39;
reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]

# -1 can also be used to infer the shape

# -1 is inferred to be 9:
reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]
# -1 is inferred to be 2:
reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3],
                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]
# -1 is inferred to be 3:
reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1],
                              [2, 2, 2],
                              [3, 3, 3]],
                             [[4, 4, 4],
                              [5, 5, 5],
                              [6, 6, 6]]]

# tensor &#39;t&#39; is [7]
# shape `[]` reshapes to a scalar
reshape(t, []) ==&gt; 7
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>shape</code></td><td>DT_INT32</td><td></td><td><p>Defines the shape of the output tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="ResizeArea"></a><h2>TensorFlow <code>ResizeArea</code> Operation</h2><h3>Description</h3><p>Input images can be of different types but output images are always float.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>align_corners</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, rescale input by (new<em>height - 1) / (height - 1), which
exactly aligns the 4 corners of images and resized images. If false, rescale
by new</em>height / height. Treat similarly the width dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
new size for the images.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>resized_images</code></td><td>DT_FLOAT</td><td></td><td><p>4-D with shape
<code>[batch, new_height, new_width, channels]</code>.</p>
</td></tr></table><a name="ResizeBicubic"></a><h2>TensorFlow <code>ResizeBicubic</code> Operation</h2><h3>Description</h3><p>Input images can be of different types but output images are always float.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>align_corners</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, rescale input by (new<em>height - 1) / (height - 1), which
exactly aligns the 4 corners of images and resized images. If false, rescale
by new</em>height / height. Treat similarly the width dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
new size for the images.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>resized_images</code></td><td>DT_FLOAT</td><td></td><td><p>4-D with shape
<code>[batch, new_height, new_width, channels]</code>.</p>
</td></tr></table><a name="ResizeBilinear"></a><h2>TensorFlow <code>ResizeBilinear</code> Operation</h2><h3>Description</h3><p>Input images can be of different types but output images are always float.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>align_corners</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, rescale input by (new<em>height - 1) / (height - 1), which
exactly aligns the 4 corners of images and resized images. If false, rescale
by new</em>height / height. Treat similarly the width dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
new size for the images.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>resized_images</code></td><td>DT_FLOAT</td><td></td><td><p>4-D with shape
<code>[batch, new_height, new_width, channels]</code>.</p>
</td></tr></table><a name="ResizeBilinearGrad"></a><h2>TensorFlow <code>ResizeBilinearGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_HALF</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>align_corners</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, rescale grads by (orig<em>height - 1) / (height - 1), which
exactly aligns the 4 corners of grads and original</em>image. If false, rescale by
orig_height / height. Treat similarly the width dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grads</code></td><td>DT_FLOAT</td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>original_image</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>,
The image tensor that was resized.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>.
Gradients with respect to the input image. Input image must have been
float or double.</p>
</td></tr></table><a name="ResizeNearestNeighbor"></a><h2>TensorFlow <code>ResizeNearestNeighbor</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>align_corners</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, rescale input by (new<em>height - 1) / (height - 1), which
exactly aligns the 4 corners of images and resized images. If false, rescale
by new</em>height / height. Treat similarly the width dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>= A 1-D int32 Tensor of 2 elements: <code>new_height, new_width</code>.  The
new size for the images.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>resized_images</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape
<code>[batch, new_height, new_width, channels]</code>.</p>
</td></tr></table><a name="ResizeNearestNeighborGrad"></a><h2>TensorFlow <code>ResizeNearestNeighborGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT32</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>align_corners</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, rescale grads by (orig<em>height - 1) / (height - 1), which
exactly aligns the 4 corners of grads and original</em>image. If false, rescale by
orig_height / height. Treat similarly the width dimension.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grads</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, channels]</code>.</p>
</td></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>= A 1-D int32 Tensor of 2 elements: <code>orig_height, orig_width</code>. The
original input size.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, orig_height, orig_width, channels]</code>. Gradients
with respect to the input image.</p>
</td></tr></table><a name="Restore"></a><h2>TensorFlow <code>Restore</code> Operation</h2><h3>Description</h3><p>Reads a tensor stored in one or several files. If there are several files (for
instance because a tensor was saved as slices), <code>file_pattern</code> may contain
wildcard symbols (<code>*</code> and <code>?</code>) in the filename portion only, not in the
directory portion.</p>

<p>If a <code>file_pattern</code> matches several files, <code>preferred_shard</code> can be used to hint
in which file the requested tensor is likely to be found. This op will first
open the file at index <code>preferred_shard</code> in the list of matching files and try
to restore tensors from that file.  Only if some tensors or tensor slices are
not found in that first file, then the Op opens all the files. Setting
<code>preferred_shard</code> to match the value passed as the <code>shard</code> input
of a matching <code>Save</code> Op may speed up Restore.  This attribute only affects
performance, not correctness.  The default value -1 means files are processed in
order.</p>

<p>See also <code>RestoreSlice</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dt</td><td>type</td><td></td><td></td><td><p>The type of the tensor to be restored.</p>
</td></tr><tr><td>preferred_shard</td><td>int</td><td>i: -1
</td><td></td><td><p>Index of file to open first if multiple files match
<code>file_pattern</code>.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>file_pattern</code></td><td>DT_STRING</td><td></td><td><p>Must have a single element. The pattern of the files from
which we read the tensor.</p>
</td></tr><tr><td><code>tensor_name</code></td><td>DT_STRING</td><td></td><td><p>Must have a single element. The name of the tensor to be
restored.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>dt</code></td><td></td><td><p>The restored tensor.</p>
</td></tr></table><a name="RestoreSlice"></a><h2>TensorFlow <code>RestoreSlice</code> Operation</h2><h3>Description</h3><p>This is like <code>Restore</code> except that restored tensor can be listed as filling
only a slice of a larger tensor.  <code>shape_and_slice</code> specifies the shape of the
larger tensor and the slice that the restored tensor covers.</p>

<p>The <code>shape_and_slice</code> input has the same format as the
elements of the <code>shapes_and_slices</code> input of the <code>SaveSlices</code> op.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dt</td><td>type</td><td></td><td></td><td><p>The type of the tensor to be restored.</p>
</td></tr><tr><td>preferred_shard</td><td>int</td><td>i: -1
</td><td></td><td><p>Index of file to open first if multiple files match
<code>file_pattern</code>. See the documentation for <code>Restore</code>.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>file_pattern</code></td><td>DT_STRING</td><td></td><td><p>Must have a single element. The pattern of the files from
which we read the tensor.</p>
</td></tr><tr><td><code>tensor_name</code></td><td>DT_STRING</td><td></td><td><p>Must have a single element. The name of the tensor to be
restored.</p>
</td></tr><tr><td><code>shape_and_slice</code></td><td>DT_STRING</td><td></td><td><p>Scalar. The shapes and slice specifications to use when
restoring a tensors.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>dt</code></td><td></td><td><p>The restored tensor.</p>
</td></tr></table><a name="Reverse"></a><h2>TensorFlow <code>Reverse</code> Operation</h2><h3>Description</h3><p>Given a <code>tensor</code>, and a <code>bool</code> tensor <code>dims</code> representing the dimensions
of <code>tensor</code>, this operation reverses each dimension i of <code>tensor</code> where
<code>dims[i]</code> is <code>True</code>.</p>

<p><code>tensor</code> can have up to 8 dimensions. The number of dimensions
of <code>tensor</code> must equal the number of elements in <code>dims</code>. In other words:</p>

<p><code>rank(tensor) = size(dims)</code></p>

<p>For example:</p>

<pre><code class="language-prettyprint"># tensor &#39;t&#39; is [[[[ 0,  1,  2,  3],
#                  [ 4,  5,  6,  7],
#                  [ 8,  9, 10, 11]],
#                 [[12, 13, 14, 15],
#                  [16, 17, 18, 19],
#                  [20, 21, 22, 23]]]]
# tensor &#39;t&#39; shape is [1, 2, 3, 4]

# &#39;dims&#39; is [False, False, False, True]
reverse(t, dims) ==&gt; [[[[ 3,  2,  1,  0],
                        [ 7,  6,  5,  4],
                        [ 11, 10, 9, 8]],
                       [[15, 14, 13, 12],
                        [19, 18, 17, 16],
                        [23, 22, 21, 20]]]]

# &#39;dims&#39; is [False, True, False, False]
reverse(t, dims) ==&gt; [[[[12, 13, 14, 15],
                        [16, 17, 18, 19],
                        [20, 21, 22, 23]
                       [[ 0,  1,  2,  3],
                        [ 4,  5,  6,  7],
                        [ 8,  9, 10, 11]]]]

# &#39;dims&#39; is [False, False, True, False]
reverse(t, dims) ==&gt; [[[[8, 9, 10, 11],
                        [4, 5, 6, 7],
                        [0, 1, 2, 3]]
                       [[20, 21, 22, 23],
                        [16, 17, 18, 19],
                        [12, 13, 14, 15]]]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT32</code></li><li><code>DT_BOOL</code></li><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Up to 8-D.</p>
</td></tr><tr><td><code>dims</code></td><td>DT_BOOL</td><td></td><td><p>1-D. The dimensions to reverse.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same shape as <code>tensor</code>.</p>
</td></tr></table><a name="ReverseSequence"></a><h2>TensorFlow <code>ReverseSequence</code> Operation</h2><h3>Description</h3><p>This op first slices <code>input</code> along the dimension <code>batch_dim</code>, and for each
slice <code>i</code>, reverses the first <code>seq_lengths[i]</code> elements along
the dimension <code>seq_dim</code>.</p>

<p>The elements of <code>seq_lengths</code> must obey <code>seq_lengths[i] &lt; input.dims[seq_dim]</code>,
and <code>seq_lengths</code> must be a vector of length <code>input.dims[batch_dim]</code>.</p>

<p>The output slice <code>i</code> along dimension <code>batch_dim</code> is then given by input
slice <code>i</code>, with the first <code>seq_lengths[i]</code> slices along dimension
<code>seq_dim</code> reversed.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># Given this:
batch_dim = 0
seq_dim = 1
input.dims = (4, 8, ...)
seq_lengths = [7, 2, 3, 5]

# then slices of input are reversed on seq_dim, but only up to seq_lengths:
output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]
output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]
output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]
output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]

# while entries past seq_lens are copied through:
output[0, 7:, :, ...] = input[0, 7:, :, ...]
output[1, 2:, :, ...] = input[1, 2:, :, ...]
output[2, 3:, :, ...] = input[2, 3:, :, ...]
output[3, 2:, :, ...] = input[3, 2:, :, ...]
</code></pre>

<p>In contrast, if:</p>

<pre><code class="language-prettyprint"># Given this:
batch_dim = 2
seq_dim = 0
input.dims = (8, ?, 4, ...)
seq_lengths = [7, 2, 3, 5]

# then slices of input are reversed on seq_dim, but only up to seq_lengths:
output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]
output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]
output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]
output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]

# while entries past seq_lens are copied through:
output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]
output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]
output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]
output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seq_dim</td><td>int</td><td></td><td></td><td><p>The dimension which is partially reversed.</p>
</td></tr><tr><td>batch_dim</td><td>int</td><td>i: 0
</td><td></td><td><p>The dimension along which reversal is performed.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The input to reverse.</p>
</td></tr><tr><td><code>seq_lengths</code></td><td>DT_INT64</td><td></td><td><p>1-D with length <code>input.dims(batch_dim)</code> and
<code>max(seq_lengths) &lt; input.dims(seq_dim)</code></p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The partially reversed input. It has the same shape as <code>input</code>.</p>
</td></tr></table><a name="Rsqrt"></a><h2>TensorFlow <code>Rsqrt</code> Operation</h2><h3>Description</h3><p>I.e., \(y = 1 / \sqrt{x}\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SampleDistortedBoundingBox"></a><h2>TensorFlow <code>SampleDistortedBoundingBox</code> Operation</h2><h3>Description</h3><p>Bounding box annotations are often supplied in addition to ground-truth labels
in image recognition or object localization tasks. A common technique for
training such a system is to randomly distort an image while preserving
its content, i.e. <em>data augmentation</em>. This Op outputs a randomly distorted
localization of an object, i.e. bounding box, given an <code>image_size</code>,
<code>bounding_boxes</code> and a series of constraints.</p>

<p>The output of this Op is a single bounding box that may be used to crop the
original image. The output is returned as 3 tensors: <code>begin</code>, <code>size</code> and
<code>bboxes</code>. The first 2 tensors can be fed directly into <code>tf.slice</code> to crop the
image. The latter may be supplied to <code>tf.image.draw_bounding_box</code> to visualize
what the bounding box looks like.</p>

<p>Bounding boxes are supplied and returned as <code>[y_min, x_min, y_max, x_max]</code>. The
bounding box coordinates are floats in <code>[0.0, 1.0]</code> relative to the width and
height of the underlying image.</p>

<p>For example,</p>

<pre><code># Generate a single distorted bounding box.
begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(
    tf.shape(image),
    bounding_boxes=bounding_boxes)

# Draw the bounding box in an image summary.
image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),
                                              bbox_for_draw)
tf.image_summary(&#39;images_with_box&#39;, image_with_box)

# Employ the bounding box to distort the image.
distorted_image = tf.slice(image, begin, size)
</code></pre>

<p>Note that if no bounding box information is available, setting
<code>use_image_if_no_bounding_boxes = true</code> will assume there is a single implicit
bounding box covering the whole image. If <code>use_image_if_no_bounding_boxes</code> is
false and no bounding boxes are supplied, an error is raised.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_UINT8</code></li><li><code>DT_INT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to non-zero, the random number
generator is seeded by the given <code>seed</code>.  Otherwise, it is seeded by a random
seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>min_object_covered</td><td>float</td><td>f: 0.1
</td><td></td><td><p>The cropped area of the image must contain at least this
fraction of any bounding box supplied.</p>
</td></tr><tr><td>aspect_ratio_range</td><td>list(float)</td><td>list {
  f: 0.75
  f: 1.33
}
</td><td></td><td><p>The cropped area of the image must have an aspect ratio =
width / height within this range.</p>
</td></tr><tr><td>area_range</td><td>list(float)</td><td>list {
  f: 0.05
  f: 1
}
</td><td></td><td><p>The cropped area of the image must contain a fraction of the
supplied image within in this range.</p>
</td></tr><tr><td>max_attempts</td><td>int</td><td>i: 100
</td><td></td><td><p>Number of attempts at generating a cropped region of the image
of the specified constraints. After <code>max_attempts</code> failures, return the entire
image.</p>
</td></tr><tr><td>use_image_if_no_bounding_boxes</td><td>bool</td><td>b: false
</td><td></td><td><p>Controls behavior if no bounding boxes supplied.
If true, assume an implicit bounding box covering the whole input. If false,
raise an error.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>image_size</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D, containing <code>[height, width, channels]</code>.</p>
</td></tr><tr><td><code>bounding_boxes</code></td><td>DT_FLOAT</td><td></td><td><p>3-D with shape <code>[batch, N, 4]</code> describing the N bounding boxes
associated with the image.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>begin</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D, containing <code>[offset_height, offset_width, 0]</code>. Provide as input to
<code>tf.slice</code>.</p>
</td></tr><tr><td><code>size</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D, containing <code>[target_height, target_width, -1]</code>. Provide as input to
<code>tf.slice</code>.</p>
</td></tr><tr><td><code>bboxes</code></td><td>DT_FLOAT</td><td></td><td><p>3-D with shape <code>[1, 1, 4]</code> containing the distorted bounding box.
Provide as input to <code>tf.image.draw_bounding_boxes</code>.</p>
</td></tr></table><a name="Save"></a><h2>TensorFlow <code>Save</code> Operation</h2><h3>Description</h3><p>The size of <code>tensor_names</code> must match the number of tensors in <code>data</code>. <code>data[i]</code>
is written to <code>filename</code> with name <code>tensor_names[i]</code>.</p>

<p>See also <code>SaveSlices</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filename</code></td><td>DT_STRING</td><td></td><td><p>Must have a single element. The name of the file to which we write
the tensor.</p>
</td></tr><tr><td><code>tensor_names</code></td><td>DT_STRING</td><td></td><td><p>Shape <code>[N]</code>. The names of the tensors to be saved.</p>
</td></tr><tr><td><code>data</code></td><td><b>type list: </b><code>T</code></td><td></td><td><p><code>N</code> tensors to save.</p>
</td></tr></table><a name="SaveSlices"></a><h2>TensorFlow <code>SaveSlices</code> Operation</h2><h3>Description</h3><p>This is like <code>Save</code> except that tensors can be listed in the saved file as being
a slice of a larger tensor.  <code>shapes_and_slices</code> specifies the shape of the
larger tensor and the slice that this tensor covers. <code>shapes_and_slices</code> must
have as many elements as <code>tensor_names</code>.</p>

<p>Elements of the <code>shapes_and_slices</code> input must either be:</p>

<ul>
<li> The empty string, in which case the corresponding tensor is
saved normally.</li>
<li> A string of the form <code>dim0 dim1 ... dimN-1 slice-spec</code> where the
<code>dimI</code> are the dimensions of the larger tensor and <code>slice-spec</code>
specifies what part is covered by the tensor to save.</li>
</ul>

<p><code>slice-spec</code> itself is a <code>:</code>-separated list: <code>slice0:slice1:...:sliceN-1</code>
where each <code>sliceI</code> is either:</p>

<ul>
<li> The string <code>-</code> meaning that the slice covers all indices of this dimension</li>
<li> <code>start,length</code> where <code>start</code> and <code>length</code> are integers.  In that
case the slice covers <code>length</code> indices starting at <code>start</code>.</li>
</ul>

<p>See also <code>Save</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filename</code></td><td>DT_STRING</td><td></td><td><p>Must have a single element. The name of the file to which we write the
tensor.</p>
</td></tr><tr><td><code>tensor_names</code></td><td>DT_STRING</td><td></td><td><p>Shape <code>[N]</code>. The names of the tensors to be saved.</p>
</td></tr><tr><td><code>shapes_and_slices</code></td><td>DT_STRING</td><td></td><td><p>Shape <code>[N]</code>.  The shapes and slice specifications to use when
saving the tensors.</p>
</td></tr><tr><td><code>data</code></td><td><b>type list: </b><code>T</code></td><td></td><td><p><code>N</code> tensors to save.</p>
</td></tr></table><a name="ScalarSummary"></a><h2>TensorFlow <code>ScalarSummary</code> Operation</h2><h3>Description</h3><p>The input <code>tags</code> and <code>values</code> must have the same shape.  The generated summary
has a summary value for each tag-value pair in <code>tags</code> and <code>values</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tags</code></td><td>DT_STRING</td><td></td><td><p>Tags for the summary.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same shape as `tags.  Values for the summary.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>summary</code></td><td>DT_STRING</td><td></td><td><p>Scalar.  Serialized <code>Summary</code> protocol buffer.</p>
</td></tr></table><a name="ScatterAdd"></a><h2>TensorFlow <code>ScatterAdd</code> Operation</h2><h3>Description</h3><p>This operation computes</p>

<pre><code># Scalar indices
ref[indices, ...] += updates[...]

# Vector indices (for each i)
ref[indices[i], ...] += updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]
</code></pre>

<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>

<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their contributions add.</p>

<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterAdd.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, the addition will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a <code>Variable</code> node.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td></tr><tr><td><code>updates</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor of updated values to add to <code>ref</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
to use the updated values after the update is done.</p>
</td></tr></table><a name="ScatterSub"></a><h2>TensorFlow <code>ScatterSub</code> Operation</h2><h3>Description</h3><pre><code># Scalar indices
ref[indices, ...] -= updates[...]

# Vector indices (for each i)
ref[indices[i], ...] -= updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]
</code></pre>

<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>

<p>Duplicate entries are handled correctly: if multiple <code>indices</code> reference
the same location, their (negated) contributions add.</p>

<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterSub.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, the subtraction will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a <code>Variable</code> node.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td></tr><tr><td><code>updates</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor of updated values to subtract from <code>ref</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
to use the updated values after the update is done.</p>
</td></tr></table><a name="ScatterUpdate"></a><h2>TensorFlow <code>ScatterUpdate</code> Operation</h2><h3>Description</h3><p>This operation computes</p>

<pre><code># Scalar indices
ref[indices, ...] = updates[...]

# Vector indices (for each i)
ref[indices[i], ...] = updates[i, ...]

# High rank indices (for each i, ..., j)
ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]
</code></pre>

<p>This operation outputs <code>ref</code> after the update is done.
This makes it easier to chain operations that need to use the reset value.</p>

<p>If values in <code>ref</code> is to be updated more than once, because there are
duplicate entires in <code>indices</code>, the order at which the updates happen
for each value is undefined.</p>

<p>Requires <code>updates.shape = indices.shape + ref.shape[1:]</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/ScatterUpdate.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: true
</td><td></td><td><p>If True, the assignment will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a <code>Variable</code> node.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A tensor of indices into the first dimension of <code>ref</code>.</p>
</td></tr><tr><td><code>updates</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor of updated values to store in <code>ref</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_ref</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= Same as <code>ref</code>.  Returned as a convenience for operations that want
to use the updated values after the update is done.</p>
</td></tr></table><a name="SegmentMax"></a><h2>TensorFlow <code>SegmentMax</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on Segmentation</a>
for an explanation of segments.</p>

<p>Computes a tensor such that
\(output_i = \max_j(data_j)\) where <code>max</code> is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMax.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>segment_ids</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A 1-D tensor whose rank is equal to the rank of <code>data</code>&#39;s
first dimension.  Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SegmentMean"></a><h2>TensorFlow <code>SegmentMean</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>

<p>Computes a tensor such that
\(output_i = \frac{\sum_j data_j}{N}\) where <code>mean</code> is
over <code>j</code> such that <code>segment_ids[j] == i</code> and <code>N</code> is the total number of
values summed.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMean.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>segment_ids</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A 1-D tensor whose rank is equal to the rank of <code>data</code>&#39;s
first dimension.  Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SegmentMin"></a><h2>TensorFlow <code>SegmentMin</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>

<p>Computes a tensor such that
\(output_i = \min_j(data_j)\) where <code>min</code> is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentMin.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>segment_ids</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A 1-D tensor whose rank is equal to the rank of <code>data</code>&#39;s
first dimension.  Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SegmentProd"></a><h2>TensorFlow <code>SegmentProd</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>

<p>Computes a tensor such that
\(output_i = \prod_j data_j\) where the product is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentProd.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>segment_ids</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A 1-D tensor whose rank is equal to the rank of <code>data</code>&#39;s
first dimension.  Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SegmentSum"></a><h2>TensorFlow <code>SegmentSum</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on Segmentation</a>
for an explanation of segments.</p>

<p>Computes a tensor such that
\(output_i = \sum_j data_j\) where sum is over <code>j</code> such
that <code>segment_ids[j] == i</code>.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/SegmentSum.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>segment_ids</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A 1-D tensor whose rank is equal to the rank of <code>data</code>&#39;s
first dimension.  Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="Select"></a><h2>TensorFlow <code>Select</code> Operation</h2><h3>Description</h3><p>The <code>t</code>, and <code>e</code> tensors must all have the same shape,
and the output will also have that shape.  The <code>condition</code> tensor
must be a scalar if <code>t</code> and <code>e</code> are scalars.  If <code>t</code> and <code>e</code> are vectors
or higher rank, then <code>condition</code> must be either a vector with size
matching the first dimension of <code>t</code>, or must have the same shape as <code>t</code>.</p>

<p>The <code>condition</code> tensor acts as a mask that chooses, based on the value at each
element, whether the corresponding element / row in the output should be
taken from <code>t</code> (if true) or <code>e</code> (if false).</p>

<p>If <code>condition</code> is a vector and <code>t</code> and <code>e</code> are higher rank matrices, then
it chooses which row (outer dimension) to copy from <code>t</code> and <code>e</code>.
If <code>condition</code> has the same shape as <code>t</code> and <code>e</code>, then it chooses which
element to copy from <code>t</code> and <code>e</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;condition&#39; tensor is [[True,  False]
#                        [False, True]]
# &#39;t&#39; is [[1, 2],
#         [3, 4]]
# &#39;e&#39; is [[5, 6],
#         [7, 8]]
select(condition, t, e) ==&gt; [[1, 6],
                             [7, 4]]


# &#39;condition&#39; tensor is [True, False]
# &#39;t&#39; is [[1, 2],
#         [3, 4]]
# &#39;e&#39; is [[5, 6],
#         [7, 8]]
select(condition, t, e) ==&gt; [[1, 2],
                             [7, 8]]

</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>condition</code></td><td>DT_BOOL</td><td></td><td></td></tr><tr><td><code>t</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= A <code>Tensor</code> which may have the same shape as <code>condition</code>.
If <code>condition</code> is rank 1, <code>t</code> may have higher rank,
but its first dimension must match the size of <code>condition</code>.</p>
</td></tr><tr><td><code>e</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= A <code>Tensor</code> with the same type and shape as <code>t</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>= A <code>Tensor</code> with the same type and shape as <code>t</code> and <code>e</code>.</p>
</td></tr></table><a name="SelfAdjointEig"></a><h2>TensorFlow <code>SelfAdjointEig</code> Operation</h2><h3>Description</h3><p>Only the lower-triangular part of the input will be used in this case. The
upper-triangular part will not be read.</p>

<p>The result is a M+1 x M matrix whose first row is the eigenvalues, and
subsequent rows are eigenvectors.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, M]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M+1, M]</code>.</p>
</td></tr></table><a name="SelfAdjointEigV2"></a><h2>TensorFlow <code>SelfAdjointEigV2</code> Operation</h2><h3>Description</h3><p>Computes the eigenvalues and (optionally) eigenvectors such that
<code>input = v * diag(e)</code>.</p>

<pre><code class="language-prettyprint"># a is a self-adjoint matrix.
# e is a vector of eigenvalues.
# v is a matrix of eigenvectors.
e, v = self_adjoint_eig(a)
e = self_adjoint_eig(a, compute_v=False)
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>compute_v</td><td>bool</td><td>b: true
</td><td></td><td><p>If <code>True</code> then eigenvectors will be computed and returned in <code>v</code>.
Otherwise, only the eigenvalues will be computed.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>Tensor</code> input of shape <code>[N, N]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>e</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Eigenvalues. Shape is <code>[N]</code>.</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Eigenvectors. Shape is <code>[N, N]</code>.</p>
</td></tr></table><a name="SerializeManySparse"></a><h2>TensorFlow <code>SerializeManySparse</code> Operation</h2><h3>Description</h3><p>The <code>SparseTensor</code> must have rank <code>R</code> greater than 1, and the first dimension
is treated as the minibatch dimension.  Elements of the <code>SparseTensor</code>
must be sorted in increasing order of this first dimension.  The serialized
<code>SparseTensor</code> objects going into each row of <code>serialized_sparse</code> will have
rank <code>R-1</code>.</p>

<p>The minibatch size <code>N</code> is extracted from <code>sparse_shape[0]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sparse_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the minibatch <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>sparse_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>values</code> of the minibatch <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>sparse_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  The <code>shape</code> of the minibatch <code>SparseTensor</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>serialized_sparse</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="SerializeSparse"></a><h2>TensorFlow <code>SerializeSparse</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sparse_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>sparse_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>sparse_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>serialized_sparse</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="Shape"></a><h2>TensorFlow <code>Shape</code> Operation</h2><h3>Description</h3><p>This operation returns a 1-D integer tensor representing the shape of <code>input</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]
shape(t) ==&gt; [2, 2, 3]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="ShapeN"></a><h2>TensorFlow <code>ShapeN</code> Operation</h2><h3>Description</h3><p>This operation returns N 1-D integer tensors representing shape of <code>input[i]s</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT32</td><td><b>number: </b><code><p>N</p>
</code></td><td></td></tr></table><a name="ShardedFilename"></a><h2>TensorFlow <code>ShardedFilename</code> Operation</h2><h3>Description</h3><p>%s-%05d-of-%05d, basename, shard, num_shards.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>basename</code></td><td>DT_STRING</td><td></td><td></td></tr><tr><td><code>shard</code></td><td>DT_INT32</td><td></td><td></td></tr><tr><td><code>num_shards</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filename</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="ShardedFilespec"></a><h2>TensorFlow <code>ShardedFilespec</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>basename</code></td><td>DT_STRING</td><td></td><td></td></tr><tr><td><code>num_shards</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>filename</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="Sigmoid"></a><h2>TensorFlow <code>Sigmoid</code> Operation</h2><h3>Description</h3><p>Specifically, <code>y = 1 / (1 + exp(-x))</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SigmoidGrad"></a><h2>TensorFlow <code>SigmoidGrad</code> Operation</h2><h3>Description</h3><p>Specifically, <code>grad = dy * y * (1 - y)</code>, where <code>y = sigmoid(x)</code>, and
<code>dy</code> is the corresponding input gradient.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Sign"></a><h2>TensorFlow <code>Sign</code> Operation</h2><h3>Description</h3><p><code>y = sign(x) = -1</code> if <code>x &lt; 0</code>; 0 if <code>x == 0</code>; 1 if <code>x &gt; 0</code>.</p>

<p>For complex numbers, <code>y = sign(x) = x / |x|</code> if <code>x != 0</code>, otherwise <code>y = 0</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Sin"></a><h2>TensorFlow <code>Sin</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Size"></a><h2>TensorFlow <code>Size</code> Operation</h2><h3>Description</h3><p>This operation returns an integer representing the number of elements in
<code>input</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]
size(t) ==&gt; 12
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="Slice"></a><h2>TensorFlow <code>Slice</code> Operation</h2><h3>Description</h3><p>The output tensor is a tensor with dimensions described by &#39;size&#39;
whose values are extracted from &#39;input&#39; starting at the offsets in
&#39;begin&#39;.</p>

<p><em>Requirements</em>:
  0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n)</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Index</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>begin</code></td><td><b>attr: </b><code>Index</code></td><td></td><td><p>begin[i] specifies the offset into the &#39;i&#39;th dimension of
&#39;input&#39; to slice from.</p>
</td></tr><tr><td><code>size</code></td><td><b>attr: </b><code>Index</code></td><td></td><td><p>size[i] specifies the number of elements of the &#39;i&#39;th dimension
of &#39;input&#39; to slice. If size[i] is -1, all remaining elements in dimension
i are included in the slice (i.e. this is equivalent to setting
size[i] = input.dim_size(i) - begin[i]).</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Softmax"></a><h2>TensorFlow <code>Softmax</code> Operation</h2><h3>Description</h3><p>For each batch <code>i</code> and class <code>j</code> we have</p>

<pre><code>softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>logits</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>2-D with shape <code>[batch_size, num_classes]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>softmax</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same shape as <code>logits</code>.</p>
</td></tr></table><a name="SoftmaxCrossEntropyWithLogits"></a><h2>TensorFlow <code>SoftmaxCrossEntropyWithLogits</code> Operation</h2><h3>Description</h3><p>Inputs are the logits, not probabilities.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>batch<em>size x num</em>classes matrix</p>
</td></tr><tr><td><code>labels</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>batch<em>size x num</em>classes matrix
The caller must ensure that each batch of labels represents a valid
probability distribution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>loss</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Per example loss (batch_size vector).</p>
</td></tr><tr><td><code>backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>backpropagated gradients (batch<em>size x num</em>classes matrix).</p>
</td></tr></table><a name="Softplus"></a><h2>TensorFlow <code>Softplus</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>activations</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SoftplusGrad"></a><h2>TensorFlow <code>SoftplusGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>gradients</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The backpropagated gradients to the corresponding softplus operation.</p>
</td></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The features passed as input to the corresponding softplus operation.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>backprops</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradients: <code>gradients / (1 + exp(-features))</code>.</p>
</td></tr></table><a name="Softsign"></a><h2>TensorFlow <code>Softsign</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>activations</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SoftsignGrad"></a><h2>TensorFlow <code>SoftsignGrad</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>gradients</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The backpropagated gradients to the corresponding softsign operation.</p>
</td></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The features passed as input to the corresponding softsign operation.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>backprops</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradients: <code>gradients / (1 + abs(-features)) ** 2</code>.</p>
</td></tr></table><a name="SpaceToBatch"></a><h2>TensorFlow <code>SpaceToBatch</code> Operation</h2><h3>Description</h3><p>Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
More specifically, this op outputs a copy of the input tensor where values from
the <code>height</code> and <code>width</code> dimensions are moved to the <code>batch</code> dimension. After
the zero-padding, both <code>height</code> and <code>width</code> of the input must be divisible by the
block size.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>block_size</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>4-D with shape <code>[batch, height, width, depth]</code>.</p>
</td></tr><tr><td><code>paddings</code></td><td>DT_INT32</td><td></td><td><p>2-D tensor of non-negative integers with shape <code>[2, 2]</code>. It specifies
  the padding of the input with zeros across the spatial dimensions as follows:</p>

<pre><code>  paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]
</code></pre>

<p>The effective spatial dimensions of the zero-padded input tensor will be:</p>

<pre><code>  height_pad = pad_top + height + pad_bottom
  width_pad = pad_left + width + pad_right
</code></pre>

<p>The attr <code>block_size</code> must be greater than one. It indicates the block size.</p>

<ul>
<li>Non-overlapping blocks of size <code>block_size x block size</code> in the height and
width dimensions are rearranged into the batch dimension at each location.</li>
<li>The batch of the output tensor is <code>batch * block_size * block_size</code>.</li>
<li>Both height<em>pad and width</em>pad must be divisible by block_size.</li>
</ul>

<p>The shape of the output will be:</p>

<pre><code>[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
 depth]
</code></pre>

<p>Some examples:</p>

<p>(1) For the following input of shape <code>[1, 2, 2, 1]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1], [2]], [[3], [4]]]]
</code></pre>

<p>The output tensor has shape <code>[4, 1, 1, 1]</code> and value:</p>

<pre><code class="language-prettyprint">[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]
</code></pre>

<p>(2) For the following input of shape <code>[1, 2, 2, 3]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
</code></pre>

<p>The output tensor has shape <code>[4, 1, 1, 3]</code> and value:</p>

<pre><code class="language-prettyprint">[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]
</code></pre>

<p>(3) For the following input of shape <code>[1, 4, 4, 1]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]],
      [[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
</code></pre>

<p>The output tensor has shape <code>[4, 2, 2, 1]</code> and value:</p>

<pre><code class="language-prettyprint">x = [[[[1], [3]], [[5], [7]]],
     [[[2], [4]], [[10], [12]]],
     [[[5], [7]], [[13], [15]]],
     [[[6], [8]], [[14], [16]]]]
</code></pre>

<p>(4) For the following input of shape <code>[2, 2, 4, 1]</code> and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1],   [2],  [3],  [4]],
      [[5],   [6],  [7],  [8]]],
     [[[9],  [10], [11],  [12]],
      [[13], [14], [15],  [16]]]]
</code></pre>

<p>The output tensor has shape <code>[8, 1, 2, 1]</code> and value:</p>

<pre><code class="language-prettyprint">x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],
     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]
</code></pre>

<p>Among others, this operation is useful for reducing atrous convolution into
regular convolution.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SpaceToDepth"></a><h2>TensorFlow <code>SpaceToDepth</code> Operation</h2><h3>Description</h3><p>Rearranges blocks of spatial data, into depth. More specifically,
this op outputs a copy of the input tensor where values from the <code>height</code>
and <code>width</code> dimensions are moved to the <code>depth</code> dimension.
The attr <code>block_size</code> indicates the input block size and how the data is moved.</p>

<ul>
<li>Non-overlapping blocks of size <code>block_size x block size</code> are rearranged
into depth at each location.</li>
<li>The depth of the output tensor is <code>input_depth * block_size * block_size</code>.</li>
<li>The input tensor&#39;s height and width must be divisible by block_size.</li>
</ul>

<p>That is, assuming the input is in the shape:
<code>[batch, height, width, depth]</code>,
the shape of the output will be:
<code>[batch, height/block_size, width/block_size, depth*block_size*block_size]</code></p>

<p>This operation requires that the input tensor be of rank 4, and that
<code>block_size</code> be &gt;=1 and a divisor of both the input <code>height</code> and <code>width</code>.</p>

<p>This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</p>

<p>For example, given this input of shape <code>[1, 2, 2, 1]</code>, and block_size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1], [2]],
      [[3], [4]]]]
</code></pre>

<p>This operation will output a tensor of shape <code>[1, 1, 1, 4]</code>:</p>

<pre><code class="language-prettyprint">[[[[1, 2, 3, 4]]]]
</code></pre>

<p>Here, the input has a batch of 1 and each batch element has shape <code>[2, 2, 1]</code>,
the corresponding output will have a single element (i.e. width and height are
both 1) and will have a depth of 4 channels (1 * block<em>size * block</em>size).
The output element shape is <code>[1, 1, 4]</code>.</p>

<p>For an input tensor with larger depth, here of shape <code>[1, 2, 2, 3]</code>, e.g.</p>

<pre><code class="language-prettyprint">x = [[[[1, 2, 3], [4, 5, 6]],
      [[7, 8, 9], [10, 11, 12]]]]
</code></pre>

<p>This operation, for block_size of 2, will return the following tensor of shape
<code>[1, 1, 1, 12]</code></p>

<pre><code class="language-prettyprint">[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]
</code></pre>

<p>Similarly, for the following input of shape <code>[1 4 4 1]</code>, and a block size of 2:</p>

<pre><code class="language-prettyprint">x = [[[[1],   [2],  [5],  [6]],
      [[3],   [4],  [7],  [8]],
      [[9],  [10], [13],  [14]],
      [[11], [12], [15],  [16]]]]
</code></pre>

<p>the operator will return the following tensor of shape <code>[1 2 2 4]</code>:</p>

<pre><code class="language-prettyprint">x = [[[[1, 2, 3, 4],
       [5, 6, 7, 8]],
      [[9, 10, 11, 12],
       [13, 14, 15, 16]]]]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>block_size</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td><p>The size of the spatial block.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SparseAdd"></a><h2>TensorFlow <code>SparseAdd</code> Operation</h2><h3>Description</h3><p>The input <code>SparseTensor</code> objects&#39; indices are assumed ordered in standard
lexicographic order.  If this is not the case, before this step run
<code>SparseReorder</code> to restore index ordering.</p>

<p>By default, if two values sum to zero at some index, the output <code>SparseTensor</code>
would still include that particular location in its index, storing a zero in the
corresponding value slot.  To override this, callers can specify <code>thresh</code>,
indicating that if the sum has a magnitude strictly smaller than <code>thresh</code>, its
corresponding value and index would then not be included.  In particular,
<code>thresh == 0</code> (default) means everything is kept and actual thresholding happens
only for a positive value.</p>

<p>In the following shapes, <code>nnz</code> is the count after taking <code>thresh</code> into account.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Treal</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the first <code>SparseTensor</code>, size <code>[nnz, ndims]</code> Matrix.</p>
</td></tr><tr><td><code>a_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>values</code> of the first <code>SparseTensor</code>, size <code>[nnz]</code> Vector.</p>
</td></tr><tr><td><code>a_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  The <code>shape</code> of the first <code>SparseTensor</code>, size <code>[ndims]</code> Vector.</p>
</td></tr><tr><td><code>b_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the second <code>SparseTensor</code>, size <code>[nnz, ndims]</code> Matrix.</p>
</td></tr><tr><td><code>b_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>values</code> of the second <code>SparseTensor</code>, size <code>[nnz]</code> Vector.</p>
</td></tr><tr><td><code>b_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  The <code>shape</code> of the second <code>SparseTensor</code>, size <code>[ndims]</code> Vector.</p>
</td></tr><tr><td><code>thresh</code></td><td><b>attr: </b><code>Treal</code></td><td></td><td><p>0-D.  The magnitude threshold that determines if an output value/index
pair takes space.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sum_indices</code></td><td>DT_INT64</td><td></td><td></td></tr><tr><td><code>sum_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>sum_shape</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="SparseAddGrad"></a><h2>TensorFlow <code>SparseAddGrad</code> Operation</h2><h3>Description</h3><p>The SparseAdd op calculates A + B, where A, B, and the sum are all represented
as <code>SparseTensor</code> objects.  This op takes in the upstream gradient w.r.t.
non-empty values of the sum, and outputs the gradients w.r.t. the non-empty
values of A and B.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>backprop_val_grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D with shape <code>[nnz(sum)]</code>.  The gradient with respect to
the non-empty values of the sum.</p>
</td></tr><tr><td><code>a_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code> A, size <code>[nnz(A), ndims]</code>.</p>
</td></tr><tr><td><code>b_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code> B, size <code>[nnz(B), ndims]</code>.</p>
</td></tr><tr><td><code>sum_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the sum <code>SparseTensor</code>, size
<code>[nnz(sum), ndims]</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a_val_grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D with shape <code>[nnz(A)]</code>. The gradient with respect to the
non-empty values of A.</p>
</td></tr><tr><td><code>b_val_grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D with shape <code>[nnz(B)]</code>. The gradient with respect to the
non-empty values of B.</p>
</td></tr></table><a name="SparseApplyAdadelta"></a><h2>TensorFlow <code>SparseApplyAdadelta</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, updating of the var and accum tensors will be protected by
a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum_update</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>: Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Learning rate. Must be a scalar.</p>
</td></tr><tr><td><code>rho</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Decay factor. Must be a scalar.</p>
</td></tr><tr><td><code>epsilon</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Constant factor. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var and accum.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseApplyAdagrad"></a><h2>TensorFlow <code>SparseApplyAdagrad</code> Operation</h2><h3>Description</h3><p>That is for rows we have grad for, we update var and accum as follows:
accum += grad * grad
var -= lr * grad * (1 / sqrt(accum))</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var and accum tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Learning rate. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var and accum.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseApplyFtrl"></a><h2>TensorFlow <code>SparseApplyFtrl</code> Operation</h2><h3>Description</h3><p>That is for rows we have grad for, we update var, accum and linear as follows:
accum<em>new = accum + grad * grad
linear += grad + (accum</em>new^(-lr<em>power) - accum^(-lr</em>power)) / lr * var
quadratic = 1.0 / (accum<em>new^(lr</em>power) * lr) + 2 * l2
var = (sign(linear) * l1 - linear) / quadratic if |linear| &gt; l1 else 0.0
accum = accum_new</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var and accum tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>linear</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var and accum.</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>l1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L1 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>l2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L2 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>lr_power</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseApplyMomentum"></a><h2>TensorFlow <code>SparseApplyMomentum</code> Operation</h2><h3>Description</h3><p>Set use_nesterov = True if you want to use Nesterov momentum.</p>

<p>That is for rows we have grad for, we update var and accum as follows:</p>

<p>accum = accum * momentum + grad
var -= lr * accum</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var and accum tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr><tr><td>use_nesterov</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, the tensor passed to compute grad will be
var - lr * momentum * accum, so in the end, the var you get is actually
var - lr * momentum * accum.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Learning rate. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var and accum.</p>
</td></tr><tr><td><code>momentum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Momentum. Must be a scalar.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseApplyProximalAdagrad"></a><h2>TensorFlow <code>SparseApplyProximalAdagrad</code> Operation</h2><h3>Description</h3><p>That is for rows we have grad for, we update var and accum as follows:
accum += grad * grad
prox<em>v = var
prox</em>v -= lr * grad * (1 / sqrt(accum))
var = sign(prox<em>v)/(1+lr*l2) * max{|prox</em>v|-lr*l1,0}</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, updating of the var and accum tensors will be protected by
a lock; otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>accum</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Learning rate. Must be a scalar.</p>
</td></tr><tr><td><code>l1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L1 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>l2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L2 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var and accum.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseApplyProximalGradientDescent"></a><h2>TensorFlow <code>SparseApplyProximalGradientDescent</code> Operation</h2><h3>Description</h3><p>That is for rows we have grad for, we update var as follows:
prox<em>v = var - alpha * grad
var = sign(prox</em>v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If True, the subtraction will be protected by a lock;
otherwise the behavior is undefined, but may exhibit less contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>alpha</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>l1</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L1 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>l2</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>L2 regularization. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var and accum.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseApplyRMSProp"></a><h2>TensorFlow <code>SparseApplyRMSProp</code> Operation</h2><h3>Description</h3><p>Note that in dense implement of this algorithm, ms and mom will
update even if the grad is zero, but in this sparse implement, ms
and mom will not update in iterations the grad is zero.</p>

<p>mean<em>square = decay * mean</em>square + (1-decay) * gradient ** 2
Delta = learning<em>rate * gradient / sqrt(mean</em>square + epsilon)</p>

<p>ms &lt;- rho * ms<em>{t-1} + (1-rho) * grad * grad
mom &lt;- momentum * mom</em>{t-1} + lr * grad / sqrt(ms + epsilon)
var &lt;- var - mom</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>use_locking</td><td>bool</td><td>b: false
</td><td></td><td><p>If <code>True</code>, updating of the var, m, and v tensors will be protected
by a lock; otherwise the behavior is undefined, but may exhibit less
contention.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>var</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>ms</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>mom</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Should be from a Variable().</p>
</td></tr><tr><td><code>lr</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scaling factor. Must be a scalar.</p>
</td></tr><tr><td><code>rho</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Decay rate. Must be a scalar.</p>
</td></tr><tr><td><code>momentum</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>epsilon</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Ridge term. Must be a scalar.</p>
</td></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The gradient.</p>
</td></tr><tr><td><code>indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A vector of indices into the first dimension of var, ms and mom.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>out</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Same as &quot;var&quot;.</p>
</td></tr></table><a name="SparseConcat"></a><h2>TensorFlow <code>SparseConcat</code> Operation</h2><h3>Description</h3><p>Concatenation is with respect to the dense versions of these sparse tensors.
It is assumed that each input is a <code>SparseTensor</code> whose elements are ordered
along increasing dimension number.</p>

<p>All inputs&#39; shapes must match, except for the concat dimension.  The
<code>indices</code>, <code>values</code>, and <code>shapes</code> lists must have the same length.</p>

<p>The output shape is identical to the inputs&#39;, except along the concat
dimension, where it is the sum of the inputs&#39; sizes along that dimension.</p>

<p>The output elements will be resorted to preserve the sort order along
increasing dimension number.</p>

<p>This op runs in <code>O(M log M)</code> time, where <code>M</code> is the total number of non-empty
values across all inputs. This is due to the need for an internal sort in
order to concatenate efficiently across an arbitrary dimension.</p>

<p>For example, if <code>concat_dim = 1</code> and the inputs are</p>

<pre><code>sp_inputs[0]: shape = [2, 3]
[0, 2]: &quot;a&quot;
[1, 0]: &quot;b&quot;
[1, 1]: &quot;c&quot;

sp_inputs[1]: shape = [2, 4]
[0, 1]: &quot;d&quot;
[0, 2]: &quot;e&quot;
</code></pre>

<p>then the output will be</p>

<pre><code>shape = [2, 7]
[0, 2]: &quot;a&quot;
[0, 4]: &quot;d&quot;
[0, 5]: &quot;e&quot;
[1, 0]: &quot;b&quot;
[1, 1]: &quot;c&quot;
</code></pre>

<p>Graphically this is equivalent to doing</p>

<pre><code>[    a] concat [  d e  ] = [    a   d e  ]
[b c  ]        [       ]   [b c          ]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>concat_dim</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td><p>Dimension to concatenate along.</p>
</td></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>2</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>indices</code></td><td>DT_INT64</td><td><b>number: </b><code><p>N</p>
</code></td><td><p>2-D.  Indices of each input <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td><p>1-D.  Non-empty values of each <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>shapes</code></td><td>DT_INT64</td><td><b>number: </b><code><p>N</p>
</code></td><td><p>1-D.  Shapes of each <code>SparseTensor</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  Indices of the concatenated <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>output_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  Non-empty values of the concatenated <code>SparseTensor</code>.</p>
</td></tr><tr><td><code>output_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the concatenated <code>SparseTensor</code>.</p>
</td></tr></table><a name="SparseDenseCwiseAdd"></a><h2>TensorFlow <code>SparseDenseCwiseAdd</code> Operation</h2><h3>Description</h3><p>(1) Broadcasts the dense side to have the same shape as the sparse side, if
    eligible;
(2) Then, only the dense values pointed to by the indices of the SparseTensor
    participate in the cwise addition.</p>

<p>By these rules, the result is a logical SparseTensor with exactly the same
indices and shape, but possibly with different non-zero values.  The output of
this Op is the resultant non-zero values.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sp_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, possibly not in canonical ordering.</p>
</td></tr><tr><td><code>sp_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td></tr><tr><td><code>sp_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr><tr><td><code>dense</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>R</code>-D.  The dense Tensor operand.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>N</code> values that are operated on.</p>
</td></tr></table><a name="SparseDenseCwiseDiv"></a><h2>TensorFlow <code>SparseDenseCwiseDiv</code> Operation</h2><h3>Description</h3><p><em>Limitation</em>: this Op only broadcasts the dense side to the sparse side, but not
the other direction.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sp_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, possibly not in canonical ordering.</p>
</td></tr><tr><td><code>sp_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td></tr><tr><td><code>sp_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr><tr><td><code>dense</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>R</code>-D.  The dense Tensor operand.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>N</code> values that are operated on.</p>
</td></tr></table><a name="SparseDenseCwiseMul"></a><h2>TensorFlow <code>SparseDenseCwiseMul</code> Operation</h2><h3>Description</h3><p>The output locations corresponding to the implicitly zero elements in the sparse
tensor will be zero (i.e., will not take up storage space), regardless of the
contents of the dense tensor (even if it&#39;s +/-INF and that INF*0 == NaN).</p>

<p><em>Limitation</em>: this Op only broadcasts the dense side to the sparse side, but not
the other direction.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sp_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, possibly not in canonical ordering.</p>
</td></tr><tr><td><code>sp_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td></tr><tr><td><code>sp_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr><tr><td><code>dense</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>R</code>-D.  The dense Tensor operand.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>N</code> values that are operated on.</p>
</td></tr></table><a name="SparseMatMul"></a><h2>TensorFlow <code>SparseMatMul</code> Operation</h2><h3>Description</h3><p>The inputs must be two-dimensional matrices and the inner dimension of &quot;a&quot; must
match the outer dimension of &quot;b&quot;. This op is optimized for the case where at
least one of &quot;a&quot; or &quot;b&quot; is sparse. The breakeven for using this versus a dense
matrix multiply on one platform was 30% zero values in the sparse matrix.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>transpose_a</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>transpose_b</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>a_is_sparse</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>b_is_sparse</td><td>bool</td><td>b: false
</td><td></td><td></td></tr><tr><td>Ta</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_BFLOAT16</code></li></ul></td><td></td></tr><tr><td>Tb</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_BFLOAT16</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a</code></td><td><b>attr: </b><code>Ta</code></td><td></td><td></td></tr><tr><td><code>b</code></td><td><b>attr: </b><code>Tb</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>product</code></td><td>DT_FLOAT</td><td></td><td></td></tr></table><a name="SparseReduceSum"></a><h2>TensorFlow <code>SparseReduceSum</code> Operation</h2><h3>Description</h3><p>This Op takes a SparseTensor and is the sparse counterpart to
<code>tf.reduce_sum()</code>.  In particular, this Op also returns a dense <code>Tensor</code>
instead of a sparse one.</p>

<p>Reduces <code>sp_input</code> along the dimensions given in <code>reduction_axes</code>.  Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_axes</code>. If <code>keep_dims</code> is true, the reduced dimensions are retained
with length 1.</p>

<p>If <code>reduction_axes</code> has no entries, all dimensions are reduced, and a tensor
with a single element is returned.  Additionally, the axes can be negative,
which are interpreted according to the indexing rules in Python.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, possibly not in canonical ordering.</p>
</td></tr><tr><td><code>input_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td></tr><tr><td><code>input_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr><tr><td><code>reduction_axes</code></td><td>DT_INT32</td><td></td><td><p>1-D.  Length-<code>K</code> vector containing the reduction axes.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>R-K</code>-D.  The reduced Tensor.</p>
</td></tr></table><a name="SparseReorder"></a><h2>TensorFlow <code>SparseReorder</code> Operation</h2><h3>Description</h3><p>Note that by convention, all sparse ops preserve the canonical ordering along
increasing dimension number. The only time ordering can be violated is during
manual manipulation of the indices and values vectors to add entries.</p>

<p>Reordering does not affect the shape of the SparseTensor.</p>

<p>If the tensor has rank <code>R</code> and <code>N</code> non-empty values, <code>input_indices</code> has
shape <code>[N, R]</code>, input<em>values has length <code>N</code>, and input</em>shape has length <code>R</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, possibly not in canonical ordering.</p>
</td></tr><tr><td><code>input_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>input_indices</code>.</p>
</td></tr><tr><td><code>input_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the same indices as input_indices, but
in canonical row-major ordering.</p>
</td></tr><tr><td><code>output_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>output_indices</code>.</p>
</td></tr></table><a name="SparseReshape"></a><h2>TensorFlow <code>SparseReshape</code> Operation</h2><h3>Description</h3><p>This operation has the same semantics as reshape on the represented dense
tensor.  The <code>input_indices</code> are recomputed based on the requested <code>new_shape</code>.</p>

<p>If one component of <code>new_shape</code> is the special value -1, the size of that
dimension is computed so that the total dense size remains constant.  At
most one component of <code>new_shape</code> can be -1.  The number of dense elements
implied by <code>new_shape</code> must be the same as the number of dense elements
originally implied by <code>input_shape</code>.</p>

<p>Reshaping does not affect the order of values in the SparseTensor.</p>

<p>If the input tensor has rank <code>R_in</code> and <code>N</code> non-empty values, and <code>new_shape</code>
has length <code>R_out</code>, then <code>input_indices</code> has shape <code>[N, R_in]</code>,
<code>input_shape</code> has length <code>R_in</code>, <code>output_indices</code> has shape <code>[N, R_out]</code>, and
<code>output_shape</code> has length <code>R_out</code>.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R_in</code> matrix with the indices of non-empty values in a
SparseTensor.</p>
</td></tr><tr><td><code>input_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  <code>R_in</code> vector with the input SparseTensor&#39;s dense shape.</p>
</td></tr><tr><td><code>new_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  <code>R_out</code> vector with the requested new dense shape.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R_out</code> matrix with the updated indices of non-empty
values in the output SparseTensor.</p>
</td></tr><tr><td><code>output_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  <code>R_out</code> vector with the full dense shape of the output
SparseTensor.  This is the same as <code>new_shape</code> but with any -1 dimensions
filled in.</p>
</td></tr></table><a name="SparseSegmentMean"></a><h2>TensorFlow <code>SparseSegmentMean</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>

<p>Like <code>SegmentMean</code>, but <code>segment_ids</code> can have rank less than <code>data</code>&#39;s first
dimension, selecting a subset of dimension 0, specified by <code>indices</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td></tr><tr><td><code>segment_ids</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SparseSegmentMeanGrad"></a><h2>TensorFlow <code>SparseSegmentMeanGrad</code> Operation</h2><h3>Description</h3><p>Returns tensor &quot;output&quot; with same shape as grad, except for dimension 0 whose
value is output_dim0.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>gradient propagated to the SparseSegmentMean op.</p>
</td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>indices passed to the corresponding SparseSegmentMean op.</p>
</td></tr><tr><td><code>segment_ids</code></td><td>DT_INT32</td><td></td><td><p>segment_ids passed to the corresponding SparseSegmentMean op.</p>
</td></tr><tr><td><code>output_dim0</code></td><td>DT_INT32</td><td></td><td><p>dimension 0 of &quot;data&quot; passed to SparseSegmentMean op.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SparseSegmentSqrtN"></a><h2>TensorFlow <code>SparseSegmentSqrtN</code> Operation</h2><h3>Description</h3><p>N is the size of the segment being reduced.</p>

<p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td></tr><tr><td><code>segment_ids</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SparseSegmentSqrtNGrad"></a><h2>TensorFlow <code>SparseSegmentSqrtNGrad</code> Operation</h2><h3>Description</h3><p>Returns tensor &quot;output&quot; with same shape as grad, except for dimension 0 whose
value is output_dim0.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grad</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>gradient propagated to the SparseSegmentSqrtN op.</p>
</td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>indices passed to the corresponding SparseSegmentSqrtN op.</p>
</td></tr><tr><td><code>segment_ids</code></td><td>DT_INT32</td><td></td><td><p>segment_ids passed to the corresponding SparseSegmentSqrtN op.</p>
</td></tr><tr><td><code>output_dim0</code></td><td>DT_INT32</td><td></td><td><p>dimension 0 of &quot;data&quot; passed to SparseSegmentSqrtN op.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SparseSegmentSum"></a><h2>TensorFlow <code>SparseSegmentSum</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>

<p>Like <code>SegmentSum</code>, but <code>segment_ids</code> can have rank less than <code>data</code>&#39;s first
dimension, selecting a subset of dimension 0, specified by <code>indices</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint">c = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])

# Select two rows, one segment.
tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))
  ==&gt; [[0 0 0 0]]

# Select two rows, two segment.
tf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))
  ==&gt; [[ 1  2  3  4]
       [-1 -2 -3 -4]]

# Select all rows, two segments.
tf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))
  ==&gt; [[0 0 0 0]
       [5 6 7 8]]

# Which is equivalent to:
tf.segment_sum(c, tf.constant([0, 0, 1]))
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor. Has same rank as <code>segment_ids</code>.</p>
</td></tr><tr><td><code>segment_ids</code></td><td>DT_INT32</td><td></td><td><p>A 1-D tensor. Values should be sorted and can be repeated.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for dimension 0 which
has size <code>k</code>, the number of segments.</p>
</td></tr></table><a name="SparseSoftmax"></a><h2>TensorFlow <code>SparseSoftmax</code> Operation</h2><h3>Description</h3><p>The inputs represent an N-D SparseTensor  with logical shape <code>[..., B, C]</code>
(where <code>N &gt;= 2</code>), and with indices sorted in the canonical lexicographic order.</p>

<p>This op is equivalent to applying the normal <code>tf.nn.softmax()</code> to each innermost
logical submatrix with shape <code>[B, C]</code>, but with the catch that <em>the implicitly
zero elements do not participate</em>.  Specifically, the algorithm is equivalent
to the following:</p>

<p>(1) Applies <code>tf.nn.softmax()</code> to a densified view of each innermost submatrix
      with shape <code>[B, C]</code>, along the size-C dimension;
  (2) Masks out the original implicitly-zero locations;
  (3) Renormalizes the remaining elements.</p>

<p>Hence, the <code>SparseTensor</code> result has exactly the same non-zero indices and
shape.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sp_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>NNZ x R</code> matrix with the indices of non-empty values in a
SparseTensor, in canonical ordering.</p>
</td></tr><tr><td><code>sp_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>NNZ</code> non-empty values corresponding to <code>sp_indices</code>.</p>
</td></tr><tr><td><code>sp_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>NNZ</code> values for the result <code>SparseTensor</code>.</p>
</td></tr></table><a name="SparseSoftmaxCrossEntropyWithLogits"></a><h2>TensorFlow <code>SparseSoftmaxCrossEntropyWithLogits</code> Operation</h2><h3>Description</h3><p>Unlike <code>SoftmaxCrossEntropyWithLogits</code>, this operation does not accept
a matrix of label probabilities, but rather a single label per row
of features.  This label is considered to have probability 1.0 for the
given row.</p>

<p>Inputs are the logits, not probabilities.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr><tr><td>Tlabels</td><td>type</td><td>type: DT_INT64
</td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>features</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>batch<em>size x num</em>classes matrix</p>
</td></tr><tr><td><code>labels</code></td><td><b>attr: </b><code>Tlabels</code></td><td></td><td><p>batch<em>size vector with values in [0, num</em>classes).
This is the label for the given minibatch entry.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>loss</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Per example loss (batch_size vector).</p>
</td></tr><tr><td><code>backprop</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>backpropagated gradients (batch<em>size x num</em>classes matrix).</p>
</td></tr></table><a name="SparseSparseMaximum"></a><h2>TensorFlow <code>SparseSparseMaximum</code> Operation</h2><h3>Description</h3><p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, in the canonical lexicographic ordering.</p>
</td></tr><tr><td><code>a_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>a_indices</code>.</p>
</td></tr><tr><td><code>a_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr><tr><td><code>b_indices</code></td><td>DT_INT64</td><td></td><td><p>counterpart to <code>a_indices</code> for the other operand.</p>
</td></tr><tr><td><code>b_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>counterpart to <code>a_values</code> for the other operand; must be of the same dtype.</p>
</td></tr><tr><td><code>b_shape</code></td><td>DT_INT64</td><td></td><td><p>counterpart to <code>a_shape</code> for the other operand; the two shapes must be equal.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The indices of the output SparseTensor.</p>
</td></tr><tr><td><code>output_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The values of the output SparseTensor.</p>
</td></tr></table><a name="SparseSparseMinimum"></a><h2>TensorFlow <code>SparseSparseMinimum</code> Operation</h2><h3>Description</h3><p>Assumes the two SparseTensors have the same shape, i.e., no broadcasting.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  <code>N x R</code> matrix with the indices of non-empty values in a
SparseTensor, in the canonical lexicographic ordering.</p>
</td></tr><tr><td><code>a_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  <code>N</code> non-empty values corresponding to <code>a_indices</code>.</p>
</td></tr><tr><td><code>a_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  Shape of the input SparseTensor.</p>
</td></tr><tr><td><code>b_indices</code></td><td>DT_INT64</td><td></td><td><p>counterpart to <code>a_indices</code> for the other operand.</p>
</td></tr><tr><td><code>b_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>counterpart to <code>a_values</code> for the other operand; must be of the same dtype.</p>
</td></tr><tr><td><code>b_shape</code></td><td>DT_INT64</td><td></td><td><p>counterpart to <code>a_shape</code> for the other operand; the two shapes must be equal.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The indices of the output SparseTensor.</p>
</td></tr><tr><td><code>output_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The values of the output SparseTensor.</p>
</td></tr></table><a name="SparseSplit"></a><h2>TensorFlow <code>SparseSplit</code> Operation</h2><h3>Description</h3><p>If the <code>shape[split_dim]</code> is not an integer multiple of <code>num_split</code>. Slices
<code>[0 : shape[split_dim] % num_split]</code> gets one extra dimension.
For example, if <code>split_dim = 1</code> and <code>num_split = 2</code> and the input is</p>

<pre><code>input_tensor = shape = [2, 7]
[    a   d e  ]
[b c          ]
</code></pre>

<p>Graphically the output tensors are:</p>

<pre><code>output_tensor[0] = shape = [2, 4]
[    a  ]
[b c    ]

output_tensor[1] = shape = [2, 3]
[ d e  ]
[      ]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_split</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The number of ways to split.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>split_dim</code></td><td>DT_INT64</td><td></td><td><p>0-D.  The dimension along which to split.  Must be in the range
<code>[0, rank(shape))</code>.</p>
</td></tr><tr><td><code>indices</code></td><td>DT_INT64</td><td></td><td><p>2-D tensor represents the indices of the sparse tensor.</p>
</td></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D tensor represents the values of the sparse tensor.</p>
</td></tr><tr><td><code>shape</code></td><td>DT_INT64</td><td></td><td><p>1-D. tensor represents the shape of the sparse tensor.
output indices: A list of 1-D tensors represents the indices of the output
sparse tensors.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_indices</code></td><td>DT_INT64</td><td><b>number: </b><code><p>num_split</p>
</code></td><td></td></tr><tr><td><code>output_values</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>num_split</p>
</code></td><td><p>A list of 1-D tensors represents the values of the output sparse
tensors.</p>
</td></tr><tr><td><code>output_shape</code></td><td>DT_INT64</td><td><b>number: </b><code><p>num_split</p>
</code></td><td><p>A list of 1-D tensors represents the shape of the output sparse
tensors.</p>
</td></tr></table><a name="SparseTensorDenseAdd"></a><h2>TensorFlow <code>SparseTensorDenseAdd</code> Operation</h2><h3>Description</h3><p>This Op does not require <code>a_indices</code> be sorted in standard lexicographic order.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a_indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>, with shape <code>[nnz, ndims]</code>.</p>
</td></tr><tr><td><code>a_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>, with shape <code>[nnz]</code>.</p>
</td></tr><tr><td><code>a_shape</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>, with shape <code>[ndims]</code>.</p>
</td></tr><tr><td><code>b</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p><code>ndims</code>-D Tensor.  With shape <code>a_shape</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SparseTensorDenseMatMul"></a><h2>TensorFlow <code>SparseTensorDenseMatMul</code> Operation</h2><h3>Description</h3><p>No validity checking is performed on the indices of A.  However, the following
input format is recommended for optimal behavior:</p>

<p>if adjoint<em>a == false:
  A should be sorted in lexicographically increasing order.  Use SparseReorder
  if you&#39;re not sure.
if adjoint</em>a == true:
  A should be sorted in order of increasing dimension 1 (i.e., &quot;column major&quot;
  order instead of &quot;row major&quot; order).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>adjoint_a</td><td>bool</td><td>b: false
</td><td></td><td><p>Use the adjoint of A in the matrix multiply.  If A is complex, this
is transpose(conj(A)).  Otherwise it&#39;s transpose(A).</p>
</td></tr><tr><td>adjoint_b</td><td>bool</td><td>b: false
</td><td></td><td><p>Use the adjoint of B in the matrix multiply.  If B is complex, this
is transpose(conj(B)).  Otherwise it&#39;s transpose(B).</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>a_indices</code></td><td>DT_INT64</td><td></td><td><p>2-D.  The <code>indices</code> of the <code>SparseTensor</code>, size <code>[nnz, 2]</code> Matrix.</p>
</td></tr><tr><td><code>a_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  The <code>values</code> of the <code>SparseTensor</code>, size <code>[nnz]</code> Vector.</p>
</td></tr><tr><td><code>a_shape</code></td><td>DT_INT64</td><td></td><td><p>1-D.  The <code>shape</code> of the <code>SparseTensor</code>, size <code>[2]</code> Vector.</p>
</td></tr><tr><td><code>b</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>2-D.  A dense Matrix.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>product</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SparseToDense"></a><h2>TensorFlow <code>SparseToDense</code> Operation</h2><h3>Description</h3><p>Builds an array <code>dense</code> with shape <code>output_shape</code> such that</p>

<pre><code class="language-prettyprint"># If sparse_indices is scalar
dense[i] = (i == sparse_indices ? sparse_values : default_value)

# If sparse_indices is a vector, then for each i
dense[sparse_indices[i]] = sparse_values[i]

# If sparse_indices is an n by d matrix, then for each i in [0, n)
dense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]
</code></pre>

<p>All other values in <code>dense</code> are set to <code>default_value</code>.  If <code>sparse_values</code> is a
scalar, all sparse indices are set to this single value.</p>

<p>Indices should be sorted in lexicographic order, and indices must not
contain any repeats. If <code>validate_indices</code> is true, these properties
are checked during execution.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>validate_indices</td><td>bool</td><td>b: true
</td><td></td><td><p>If true, indices are checked to make sure they are sorted in
lexicographic order and that there are no repeats.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sparse_indices</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>0-D, 1-D, or 2-D.  <code>sparse_indices[i]</code> contains the complete
index where <code>sparse_values[i]</code> will be placed.</p>
</td></tr><tr><td><code>output_shape</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>1-D.  Shape of the dense output tensor.</p>
</td></tr><tr><td><code>sparse_values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.  Values corresponding to each row of <code>sparse_indices</code>,
or a scalar value to be used for all sparse indices.</p>
</td></tr><tr><td><code>default_value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Scalar value to set for indices not specified in
<code>sparse_indices</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>dense</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Dense output tensor of shape <code>output_shape</code>.</p>
</td></tr></table><a name="Split"></a><h2>TensorFlow <code>Split</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_split</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The number of ways to split.  Must evenly divide
<code>value.shape[split_dim]</code>.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>split_dim</code></td><td>DT_INT32</td><td></td><td><p>0-D.  The dimension along which to split.  Must be in the range
<code>[0, rank(value))</code>.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to split.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>num_split</p>
</code></td><td><p>They are identically shaped tensors, whose shape matches that of <code>value</code>
except along <code>split_dim</code>, where their sizes are
<code>values.shape[split_dim] / num_split</code>.</p>
</td></tr></table><a name="Sqrt"></a><h2>TensorFlow <code>Sqrt</code> Operation</h2><h3>Description</h3><p>I.e., \(y = \sqrt{x} = x^{1/2}\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Square"></a><h2>TensorFlow <code>Square</code> Operation</h2><h3>Description</h3><p>I.e., \(y = x * x = x^2\).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="SquaredDifference"></a><h2>TensorFlow <code>SquaredDifference</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>SquaredDifference</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Squeeze"></a><h2>TensorFlow <code>Squeeze</code> Operation</h2><h3>Description</h3><p>Given a tensor <code>input</code>, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don&#39;t want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
<code>squeeze_dims</code>.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t)) ==&gt; [2, 3]
</code></pre>

<p>Or, to remove specific size 1 dimensions:</p>

<pre><code class="language-prettyprint"># &#39;t&#39; is a tensor of shape [1, 2, 1, 3, 1, 1]
shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>squeeze_dims</td><td>list(int)</td><td>list {
}
</td><td><b>Minimum: </b>0</td><td><p>If specified, only squeezes the dimensions listed. The dimension
index starts at 0. It is an error to squeeze a dimension that is not 1.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The <code>input</code> to squeeze.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Contains the same data as <code>input</code>, but has one or more dimensions of
size 1 removed.</p>
</td></tr></table><a name="Stack"></a><h2>TensorFlow <code>Stack</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>elem_type</td><td>type</td><td></td><td></td><td><p>The type of the elements on the stack.</p>
</td></tr><tr><td>stack_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>Overrides the name used for the temporary stack resource. Default
value is the name of the &#39;Stack&#39; op (which is guaranteed unique).</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the stack.</p>
</td></tr></table><a name="StackClose"></a><h2>TensorFlow <code>StackClose</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a stack.</p>
</td></tr></table><a name="StackPop"></a><h2>TensorFlow <code>StackPop</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>elem_type</td><td>type</td><td></td><td></td><td><p>The type of the elem that is popped.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a stack.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>elem</code></td><td><b>attr: </b><code>elem_type</code></td><td></td><td><p>The tensor that is popped from the top of the stack.</p>
</td></tr></table><a name="StackPush"></a><h2>TensorFlow <code>StackPush</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>swap_memory</td><td>bool</td><td>b: false
</td><td></td><td><p>Swap <code>elem</code> to CPU. Default to false.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a stack.</p>
</td></tr><tr><td><code>elem</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be pushed onto the stack.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The same tensor as the input &#39;elem&#39;.</p>
</td></tr></table><a name="StopGradient"></a><h2>TensorFlow <code>StopGradient</code> Operation</h2><h3>Description</h3><p>When executed in a graph, this op outputs its input tensor as-is.</p>

<p>When building ops to compute gradients, this op prevents the contribution of
its inputs to be taken into account.  Normally, the gradient generator adds ops
to a graph to compute the derivatives of a specified &#39;loss&#39; by recursively
finding out inputs that contributed to its computation.  If you insert this op
in the graph it inputs are masked from the gradient generator.  They are not
taken into account for computing gradients.</p>

<p>This is useful any time you want to compute a value with TensorFlow but need
to pretend that the value was a constant. Some examples include:</p>

<ul>
<li> The <em>EM</em> algorithm where the <em>M-step</em> should not involve backpropagation
through the output of the <em>E-step</em>.</li>
<li> Contrastive divergence training of Boltzmann machines where, when
differentiating the energy function, the training must not backpropagate
through the graph that generated the samples from the model.</li>
<li> Adversarial training, where no backprop should happen through the adversarial
example generation process.</li>
</ul>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="StridedSlice"></a><h2>TensorFlow <code>StridedSlice</code> Operation</h2><h3>Description</h3><p>The output tensor is a tensor with dimensions implied by <code>begin</code>,
<code>end</code>, and <code>strides</code>, whose values are extracted from <code>begin</code>.</p>

<p>Specifically, the result tensor at index <code>(i[0], i[1], ..., i[n-1])</code>
will obtain the value <code>input[begin[0] + i[0] * stride[0], ...,</code>
                            <code>begin[n-1] + i[n-1] * stride[n-1])]</code>.</p>

<p><em>Requirements</em>:
  <code>0 != strides[i] for i in [0, n)</code></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Index</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>begin_mask</td><td>int</td><td>i: 0
</td><td></td><td><p>a bitmask where a bit i being 1 means to ignore the begin
value and instead use the largest interval possible. At runtime
begin[i] will be replaced with <code>[0, n-1) if</code>stride[i] &gt; 0<code>or
</code>[-1, n-1]<code>if</code>stride[i] &lt; 0`</p>
</td></tr><tr><td>end_mask</td><td>int</td><td>i: 0
</td><td></td><td><p>analogous to <code>begin_mask</code></p>
</td></tr><tr><td>ellipsis_mask</td><td>int</td><td>i: 0
</td><td></td><td><p>a bitmask where bit <code>i</code> being 1 means the <code>i</code>th
position is actually an ellipsis. One bit at most can be 1.</p>
</td></tr><tr><td>new_axis_mask</td><td>int</td><td>i: 0
</td><td></td><td><p>a bitmask where bit <code>i</code> being 1 means the <code>i</code>th
position creates a dimension in the tensor of length 1. Thus
the total number of elements remain unchanged but the shape
gets a 1 in the appropriate position.</p>
</td></tr><tr><td>shrink_axis_mask</td><td>int</td><td>i: 0
</td><td></td><td><p>a bitmask where bit <code>i</code> implies that the <code>i</code>th
position should shrink the dimensionality. begin and end
must imply a slice of size 1 in the dimension. For example in
python one might do <code>foo[:,3,:]</code> which would result in
<code>shrink_axis_mask</code> being 2.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>begin</code></td><td><b>attr: </b><code>Index</code></td><td></td><td><p><code>begin[i]</code> specifies the offset into the <code>i</code>th dimension of
<code>input</code> to slice from.</p>
</td></tr><tr><td><code>end</code></td><td><b>attr: </b><code>Index</code></td><td></td><td><p><code>end[i]</code> specifies the first offset into the <code>i</code>th dimension of
<code>input</code> that will not be extracted. Out or range values are
clamped to <code>[0,dim[i]) if slice[i] &gt; 0</code> or <code>[-1,dim[i]-1]</code>
<code>if slice[i] &lt; 0</code></p>
</td></tr><tr><td><code>strides</code></td><td><b>attr: </b><code>Index</code></td><td></td><td><p><code>strides[i]</code> specifies the increment in the <code>i</code>th dimension
after extracting a given element. Negative indices will reverse
the original order. Out or range values are
clamped to <code>[0,dim[i]) if slice[i]&gt;0</code> or <code>[-1,dim[i]-1] if slice[i] &lt; 0</code></p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="StridedSliceGrad"></a><h2>TensorFlow <code>StridedSliceGrad</code> Operation</h2><h3>Description</h3><p>Since <code>StridedSlice</code> cuts out pieces of its <code>input</code> which is size
<code>shape</code>, its gradient will have the same shape (which is passed here
as <code>shape</code>). The gradient will be zero in any element that the slice
does not select.</p>

<p>Arguments are the same as StridedSliceGrad with the exception that
<code>dy</code> is the input gradient to be propagated and <code>shape</code> is the
shape of <code>StridedSlice</code>&#39;s <code>input</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>Index</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr><tr><td>begin_mask</td><td>int</td><td>i: 0
</td><td></td><td></td></tr><tr><td>end_mask</td><td>int</td><td>i: 0
</td><td></td><td></td></tr><tr><td>ellipsis_mask</td><td>int</td><td>i: 0
</td><td></td><td></td></tr><tr><td>new_axis_mask</td><td>int</td><td>i: 0
</td><td></td><td></td></tr><tr><td>shrink_axis_mask</td><td>int</td><td>i: 0
</td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>Index</code></td><td></td><td></td></tr><tr><td><code>begin</code></td><td><b>attr: </b><code>Index</code></td><td></td><td></td></tr><tr><td><code>end</code></td><td><b>attr: </b><code>Index</code></td><td></td><td></td></tr><tr><td><code>strides</code></td><td><b>attr: </b><code>Index</code></td><td></td><td></td></tr><tr><td><code>dy</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="StringJoin"></a><h2>TensorFlow <code>StringJoin</code> Operation</h2><h3>Description</h3><p>with the given separator (default is an empty separator).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>separator</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>string, an optional join separator.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>inputs</code></td><td>DT_STRING</td><td><b>number: </b><code><p>N</p>
</code></td><td><p>A list of string tensors.  The tensors must all have the same shape,
or be scalars.  Scalars may be mixed in; these will be broadcast to the shape
of non-scalar inputs.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="StringToHashBucket"></a><h2>TensorFlow <code>StringToHashBucket</code> Operation</h2><h3>Description</h3><p>The hash function is deterministic on the content of the string within the
process.</p>

<p>Note that the hash function may change from time to time.
This functionality will be deprecated and it&#39;s recommended to use
<code>tf.string_to_hash_bucket_fast()</code> or <code>tf.string_to_hash_bucket_strong()</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_buckets</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The number of buckets.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>string_tensor</code></td><td>DT_STRING</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td><p>A Tensor of the same shape as the input <code>string_tensor</code>.</p>
</td></tr></table><a name="StringToHashBucketFast"></a><h2>TensorFlow <code>StringToHashBucketFast</code> Operation</h2><h3>Description</h3><p>The hash function is deterministic on the content of the string within the
process and will never change. However, it is not suitable for cryptography.
This function may be used when CPU time is scarce and inputs are trusted or
unimportant. There is a risk of adversaries constructing inputs that all hash
to the same bucket. To prevent this problem, use a strong hash function with
<code>tf.string_to_hash_bucket_strong</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_buckets</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The number of buckets.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_STRING</td><td></td><td><p>The strings to assign a hash bucket.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td><p>A Tensor of the same shape as the input <code>string_tensor</code>.</p>
</td></tr></table><a name="StringToHashBucketStrong"></a><h2>TensorFlow <code>StringToHashBucketStrong</code> Operation</h2><h3>Description</h3><p>The hash function is deterministic on the content of the string within the
process. The hash function is a keyed hash function, where attribute <code>key</code>
defines the key of the hash function. <code>key</code> is an array of 2 elements.</p>

<p>A strong hash is important when inputs may be malicious, e.g. URLs with
additional components. Adversaries could try to make their inputs hash to the
same bucket for a denial-of-service attack or to skew the results. A strong
hash prevents this by making it dificult, if not infeasible, to compute inputs
that hash to the same bucket. This comes at a cost of roughly 4x higher compute
time than tf.string<em>to</em>hash<em>bucket</em>fast.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_buckets</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The number of buckets.</p>
</td></tr><tr><td>key</td><td>list(int)</td><td></td><td></td><td><p>The key for the keyed hash function passed as a list of two uint64
elements.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_STRING</td><td></td><td><p>The strings to assign a hash bucket.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td>DT_INT64</td><td></td><td><p>A Tensor of the same shape as the input <code>string_tensor</code>.</p>
</td></tr></table><a name="StringToNumber"></a><h2>TensorFlow <code>StringToNumber</code> Operation</h2><h3>Description</h3><p>(Note that int32 overflow results in an error while float overflow
results in a rounded value.)</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>out_type</td><td>type</td><td>type: DT_FLOAT
</td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_INT32</code></li></ul></td><td><p>The numeric type to interpret each string in string_tensor as.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>string_tensor</code></td><td>DT_STRING</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>out_type</code></td><td></td><td><p>A Tensor of the same shape as the input <code>string_tensor</code>.</p>
</td></tr></table><a name="Sub"></a><h2>TensorFlow <code>Sub</code> Operation</h2><h3>Description</h3><p><em>NOTE</em>: <code>Sub</code> supports broadcasting. More about broadcasting
<a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html" target="_blank">here</a></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Sum"></a><h2>TensorFlow <code>Sum</code> Operation</h2><h3>Description</h3><p>Reduces <code>input</code> along the dimensions given in <code>reduction_indices</code>. Unless
<code>keep_dims</code> is true, the rank of the tensor is reduced by 1 for each entry in
<code>reduction_indices</code>. If <code>keep_dims</code> is true, the reduced dimensions are
retained with length 1.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>keep_dims</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, retain reduced dimensions with length 1.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to reduce.</p>
</td></tr><tr><td><code>reduction_indices</code></td><td>DT_INT32</td><td></td><td><p>The dimensions to reduce.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The reduced tensor.</p>
</td></tr></table><a name="Svd"></a><h2>TensorFlow <code>Svd</code> Operation</h2><h3>Description</h3><p>Computes the SVD of if <code>input</code> such that <code>input = u * diag(s) * transpose(v)</code></p>

<pre><code class="language-prettyprint"># a is a matrix.
# s is a vector of singular values.
# u is the matrix of left singular vectors.
# v is a matrix of right singular vectors.
s, u, v = svd(a)
s, _, _ = svd(a, compute_uv=False)
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>compute_uv</td><td>bool</td><td>b: true
</td><td></td><td><p>If true, left and right singular vectors will be
computed and returned in <code>u</code> and <code>v</code>, respectively.
If false, <code>u</code> and <code>v</code> are not set and should never referenced.</p>
</td></tr><tr><td>full_matrices</td><td>bool</td><td>b: false
</td><td></td><td><p>If true, compute full-sized <code>u</code> and <code>v</code>. If false
(the default), compute only the leading <code>P</code> singular vectors.
Ignored if <code>compute_uv</code> is <code>False</code>.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_DOUBLE</code></li><li><code>DT_FLOAT</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Shape is <code>[M, N]</code>. Let <code>P</code> be the minimum of <code>M</code> and <code>N</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>s</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Singular values. Shape is <code>[P]</code>.</p>
</td></tr><tr><td><code>u</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Left singular vectors; if <code>full_matrices</code> is <code>False</code> then shape is <code>[M, M]</code>.
If <code>full_matrices</code> is <code>True</code> then shape is <code>[M, P]</code>.
Undefined if <code>compute_uv</code> is <code>False</code>.</p>
</td></tr><tr><td><code>v</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Left singular vectors. If <code>full_matrices</code> is <code>False</code> then shape is <code>[N, N]</code>.
If <code>full_matrices</code> is <code>True</code> then shape is <code>[N, P]</code>.
Undefined if <code>compute_uv</code> is false.</p>
</td></tr></table><a name="Switch"></a><h2>TensorFlow <code>Switch</code> Operation</h2><h3>Description</h3><p>If <code>pred</code> is true, the <code>data</code> input is forwarded to <code>output_true</code>. Otherwise,
the data goes to <code>output_false</code>.</p>

<p>See also <code>RefSwitch</code> and <code>Merge</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to be forwarded to the appropriate output.</p>
</td></tr><tr><td><code>pred</code></td><td>DT_BOOL</td><td></td><td><p>A scalar that specifies which output port will receive data.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output_false</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>If <code>pred</code> is false, data will be forwarded to this output.</p>
</td></tr><tr><td><code>output_true</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>If <code>pred</code> is true, data will be forwarded to this output.</p>
</td></tr></table><a name="SymbolicGradient"></a><h2>TensorFlow <code>SymbolicGradient</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tin</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>the type list for the input list.</p>
</td></tr><tr><td>Tout</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td><p>the type list for the input list.</p>
</td></tr><tr><td>f</td><td>func</td><td></td><td></td><td><p>The function we want to compute the gradient for.</p>

<p>The function &#39;f&#39; must be a numerical function which takes N inputs and
produces M outputs. Its gradient function &#39;g&#39;, which is computed by
this SymbolicGradient op is a function taking N + M inputs and
produces N outputs.</p>

<p>I.e. if we have
   (y1, y2, ..., y<em>M) = f(x1, x2, ..., x</em>N),
then, g is
   (dL/dx1, dL/dx2, ..., dL/dx<em>N) = g(x1, x2, ..., x</em>N,
                                     dL/dy1, dL/dy2, ..., dL/dy_M),</p>

<p>where L is a scalar-value function of (x1, x2, ..., xN) (e.g., the
loss function). dL/dx<em>i is the partial derivative of L with respect
to x</em>i.</p>

<p>(Needs some math expert to say the comment above better.)</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>type list: </b><code>Tin</code></td><td></td><td><p>a list of input tensors of size N + M;</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>type list: </b><code>Tout</code></td><td></td><td><p>a list of output tensors of size N;</p>
</td></tr></table><a name="TFRecordReader"></a><h2>TensorFlow <code>TFRecordReader</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is named in the given bucket
with this shared_name. Otherwise, the node name is used instead.</p>
</td></tr><tr><td>compression_type</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to reference the Reader.</p>
</td></tr></table><a name="Tan"></a><h2>TensorFlow <code>Tan</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="Tanh"></a><h2>TensorFlow <code>Tanh</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="TanhGrad"></a><h2>TensorFlow <code>TanhGrad</code> Operation</h2><h3>Description</h3><p>Specifically, <code>grad = dy * (1 - y*y)</code>, where <code>y = tanh(x)</code>, and <code>dy</code>
is the corresponding input gradient.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="TemporaryVariable"></a><h2>TensorFlow <code>TemporaryVariable</code> Operation</h2><h3>Description</h3><p>This is an experimental op for internal use only and it is possible to use this
op in unsafe ways.  DO NOT USE unless you fully understand the risks.</p>

<p>It is the caller&#39;s responsibility to ensure that &#39;ref&#39; is eventually passed to a
matching &#39;DestroyTemporaryVariable&#39; op after all other uses have completed.</p>

<p>Outputs a ref to the tensor state so it may be read or modified.</p>

<p>E.g.
      var = state<em>ops.</em>temporary<em>variable([1, 2], types.float</em>)
      var<em>name = var.op.name
      var = state</em>ops.assign(var, [[4.0, 5.0]])
      var = state<em>ops.assign</em>add(var, [[6.0, 7.0]])
      final = state<em>ops.</em>destroy<em>temporary</em>variable(var, var<em>name=var</em>name)</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>shape</td><td>shape</td><td></td><td></td><td><p>The shape of the variable tensor.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of elements in the variable tensor.</p>
</td></tr><tr><td>var_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>Overrides the name used for the temporary variable resource. Default
value is the name of the &#39;TemporaryVariable&#39; op (which is guaranteed unique).</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A reference to the variable tensor.</p>
</td></tr></table><a name="TensorArray"></a><h2>TensorFlow <code>TensorArray</code> Operation</h2><h3>Description</h3><p>via Read or Pack.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of the elements on the tensor_array.</p>
</td></tr><tr><td>dynamic_size</td><td>bool</td><td>b: false
</td><td></td><td><p>A boolean that determines whether writes to the TensorArray
are allowed to grow the size.  By default, this is not allowed.</p>
</td></tr><tr><td>clear_after_read</td><td>bool</td><td>b: true
</td><td></td><td><p>If true (default), Tensors in the TensorArray are cleared
after being read.  This disables multiple read semantics but allows early
release of memory.</p>
</td></tr><tr><td>tensor_array_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>Overrides the name used for the temporary tensor_array
resource. Default value is the name of the &#39;TensorArray&#39; op (which
is guaranteed unique).</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>The size of the array.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the TensorArray.</p>
</td></tr></table><a name="TensorArrayClose"></a><h2>TensorFlow <code>TensorArrayClose</code> Operation</h2><h3>Description</h3><p>the user to close and release the resource in the middle of a step/run.</p>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray (output of TensorArray or TensorArrayGrad).</p>
</td></tr></table><a name="TensorArrayConcat"></a><h2>TensorFlow <code>TensorArrayConcat</code> Operation</h2><h3>Description</h3><p>Takes <code>T</code> elements of shapes</p>

<pre><code>  (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)
</code></pre>

<p>and concatenates them into a Tensor of shape:</p>

<p><code>(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)</code></p>

<p>All elements must have the same shape (excepting the first dimension).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of the elem that is returned.</p>
</td></tr><tr><td>element_shape_except0</td><td>shape</td><td>shape {
  unknown_rank: true
}
</td><td></td><td><p>The expected shape of an element, if known,
excluding the first dimension. Used to validate the shapes of
TensorArray elements. If this shape is not fully specified, concatenating
zero-size TensorArrays is an error.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray.</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>All of the elements in the TensorArray, concatenated along the first
axis.</p>
</td></tr><tr><td><code>lengths</code></td><td>DT_INT64</td><td></td><td><p>A vector of the row sizes of the original T elements in the
value output.  In the example above, this would be the values:
<code>(n1, n2, ..., n(T-1))</code>.</p>
</td></tr></table><a name="TensorArrayGrad"></a><h2>TensorFlow <code>TensorArrayGrad</code> Operation</h2><h3>Description</h3><p>If the given TensorArray gradient already exists, returns a reference to it.</p>

<p>Locks the size of the original TensorArray by disabling its dynamic size flag.</p>

<p><strong>A note about the input flow_in:</strong></p>

<p>The handle flow_in forces the execution of the gradient lookup to occur
only after certain other operations have occurred.  For example, when
the forward TensorArray is dynamically sized, writes to this TensorArray
may resize the object.  The gradient TensorArray is statically sized based
on the size of the forward TensorArray when this operation executes.
Furthermore, the size of the forward TensorArray is frozen by this call.
As a result, the flow is used to ensure that the call to generate the gradient
TensorArray only happens after all writes are executed.</p>

<p>In the case of dynamically sized TensorArrays, gradient computation should
only be performed on read operations that have themselves been chained via
flow to occur only after all writes have executed. That way the final size
of the forward TensorArray is known when this operation is called.</p>

<p><strong>A note about the source attribute:</strong></p>

<p>TensorArray gradient calls use an accumulator TensorArray object.  If
multiple gradients are calculated and run in the same session, the multiple
gradient nodes may accidentally flow throuth the same accumulator TensorArray.
This double counts and generally breaks the TensorArray gradient flow.</p>

<p>The solution is to identify which gradient call this particular
TensorArray gradient is being called in.  This is performed by identifying
a unique string (e.g. &quot;gradients&quot;, &quot;gradients_1&quot;, ...) from the input
gradient Tensor&#39;s name.  This string is used as a suffix when creating
the TensorArray gradient object here (the attribute <code>source</code>).</p>

<p>The attribute <code>source</code> is added as a suffix to the forward TensorArray&#39;s
name when performing the creation / lookup, so that each separate gradient
calculation gets its own TensorArray accumulator.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>source</td><td>string</td><td></td><td></td><td><p>The gradient source string, used to decide which gradient TensorArray
to return.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to the forward TensorArray.</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>grad_handle</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="TensorArrayPack"></a><h2>TensorFlow <code>TensorArrayPack</code> Operation</h2><h3>Description</h3><p>All elements must have the same shape.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of the elem that is returned.</p>
</td></tr><tr><td>element_shape</td><td>shape</td><td>shape {
  unknown_rank: true
}
</td><td></td><td><p>The expected shape of an element, if known. Used to
validate the shapes of TensorArray elements. If this shape is not
fully specified, packing zero-size TensorArrays is an error.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray.</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>All of the elements in the TensorArray, concatenated along a new
axis (the new dimension 0).</p>
</td></tr></table><a name="TensorArrayRead"></a><h2>TensorFlow <code>TensorArrayRead</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of the elem that is returned.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray.</p>
</td></tr><tr><td><code>index</code></td><td>DT_INT32</td><td></td><td></td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>The tensor that is read from the TensorArray.</p>
</td></tr></table><a name="TensorArraySize"></a><h2>TensorFlow <code>TensorArraySize</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray (output of TensorArray or TensorArrayGrad).</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>size</code></td><td>DT_INT32</td><td></td><td><p>The current size of the TensorArray.</p>
</td></tr></table><a name="TensorArraySplit"></a><h2>TensorFlow <code>TensorArraySplit</code> Operation</h2><h3>Description</h3><p>Assuming that <code>lengths</code> takes on values</p>

<p><code>(n0, n1, ..., n(T-1))</code></p>

<p>and that <code>value</code> has shape</p>

<p><code>(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)</code>,</p>

<p>this splits values into a TensorArray with T tensors.</p>

<p>TensorArray index t will be the subtensor of values with starting position</p>

<p><code>(n0 + n1 + ... + n(t-1), 0, 0, ...)</code></p>

<p>and having size</p>

<p><code>nt x d0 x d1 x ...</code></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The concatenated tensor to write to the TensorArray.</p>
</td></tr><tr><td><code>lengths</code></td><td>DT_INT64</td><td></td><td><p>The vector of lengths, how to split the rows of value into the
TensorArray.</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>flow_out</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><a name="TensorArrayUnpack"></a><h2>TensorFlow <code>TensorArrayUnpack</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The concatenated tensor to write to the TensorArray.</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>flow_out</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><a name="TensorArrayWrite"></a><h2>TensorFlow <code>TensorArrayWrite</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to a TensorArray.</p>
</td></tr><tr><td><code>index</code></td><td>DT_INT32</td><td></td><td><p>The position to write to inside the TensorArray.</p>
</td></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to write to the TensorArray.</p>
</td></tr><tr><td><code>flow_in</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>flow_out</code></td><td>DT_FLOAT</td><td></td><td><p>A float scalar that enforces proper chaining of operations.</p>
</td></tr></table><a name="TensorSummary"></a><h2>TensorFlow <code>TensorSummary</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>display_name</td><td>string</td><td></td><td></td><td><p>A name to associate with the data series.</p>
</td></tr><tr><td>description</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>An optional long description of the data being output.</p>
</td></tr><tr><td>labels</td><td>list(string)</td><td>list {
}
</td><td></td><td><p>a list of strings used to specify how the data can be interpreted, e.g.
a string tensor containing jpg images should have &#39;encoding:image/jpg&#39;; a
string tensor with foo protos should have &#39;encoding:proto/X/Y/foo.proto&#39;;
a numeric tensor containing bounding boxes may have
&#39;bounding_box:x1,y1,x2,y2,&#39;. If the tensor is a part of a group of related
outputs, that can be encoded through a &#39;group:$groupName/$roleInGroup&#39; label.
Labels may be formatted as &#39;prefix:value&#39;. The prefix may be re-used.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>A tensor to serialize.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>summary</code></td><td>DT_STRING</td><td></td><td></td></tr></table><a name="TextLineReader"></a><h2>TensorFlow <code>TextLineReader</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>skip_header_lines</td><td>int</td><td>i: 0
</td><td></td><td><p>Number of lines to skip from the beginning of every file.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is named in the given bucket
with this shared_name. Otherwise, the node name is used instead.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to reference the Reader.</p>
</td></tr></table><a name="ThreadUnsafeUnigramCandidateSampler"></a><h2>TensorFlow <code>ThreadUnsafeUnigramCandidateSampler</code> Operation</h2><h3>Description</h3><p>See explanations of candidate sampling and the data formats at
go/candidate-sampling.</p>

<p>For each batch, this op picks a single set of sampled candidate labels.</p>

<p>The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>num_sampled</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of candidates to randomly sample per batch.</p>
</td></tr><tr><td>unique</td><td>bool</td><td></td><td></td><td><p>If unique is true, we sample with rejection, so that all sampled
candidates in a batch are unique. This requires some approximation to
estimate the post-rejection sampling probabilities.</p>
</td></tr><tr><td>range_max</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>A batch<em>size * num</em>true matrix, in which each row contains the
IDs of the num<em>true target</em>classes in the corresponding original label.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>A vector of length num_sampled, in which each element is
the ID of a sampled candidate.</p>
</td></tr><tr><td><code>true_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A batch<em>size * num</em>true matrix, representing
the number of times each candidate is expected to occur in a batch
of sampled candidates. If unique=true, then this is a probability.</p>
</td></tr><tr><td><code>sampled_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of length num_sampled, for each sampled
candidate representing the number of times the candidate is expected
to occur in a batch of sampled candidates.  If unique=true, then this is a
probability.</p>
</td></tr></table><a name="ThrowAway1"></a><h2>TensorFlow <code>ThrowAway1</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>scope</td><td>int</td><td></td><td></td><td></td></tr><tr><td>builder</td><td>int</td><td>i: 1
</td><td></td><td></td></tr><tr><td>while</td><td>int</td><td></td><td></td><td><p>Keyword as name for attr.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ret</code></td><td>DT_INT32</td><td></td><td><p>Return value.</p>
</td></tr><tr><td><code>unique_name</code></td><td>DT_FLOAT</td><td></td><td></td></tr><tr><td><code>for</code></td><td>DT_INT32</td><td></td><td><p>Keyword as name for input.</p>
</td></tr></table><a name="ThrowAway2"></a><h2>TensorFlow <code>ThrowAway2</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>scope</td><td>int</td><td>i: 2
</td><td></td><td></td></tr><tr><td>throw_away2</td><td>int</td><td>i: 2
</td><td></td><td></td></tr><tr><td>attrs</td><td>int</td><td>i: 4
</td><td></td><td></td></tr><tr><td>node</td><td>int</td><td>i: 4
</td><td></td><td></td></tr></table><a name="ThrowAway3"></a><h2>TensorFlow <code>ThrowAway3</code> Operation</h2><h3>Description</h3><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>node</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="ThrowAway4"></a><h2>TensorFlow <code>ThrowAway4</code> Operation</h2><h3>Description</h3><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>node</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="ThrowAway5"></a><h2>TensorFlow <code>ThrowAway5</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>node</td><td>int</td><td>i: 4
</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>foo</code></td><td>DT_INT32</td><td></td><td></td></tr></table><a name="Tile"></a><h2>TensorFlow <code>Tile</code> Operation</h2><h3>Description</h3><p>This operation creates a new tensor by replicating <code>input</code> <code>multiples</code> times.
The output tensor&#39;s i&#39;th dimension has <code>input.dims(i) * multiples[i]</code> elements,
and the values of <code>input</code> are replicated <code>multiples[i]</code> times along the &#39;i&#39;th
dimension. For example, tiling <code>[a b c d]</code> by <code>[2]</code> produces
<code>[a b c d a b c d]</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D or higher.</p>
</td></tr><tr><td><code>multiples</code></td><td>DT_INT32</td><td></td><td><p>1-D. Length must be the same as the number of dimensions in <code>input</code></p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="TileGrad"></a><h2>TensorFlow <code>TileGrad</code> Operation</h2><h3>Description</h3><p>Since <code>Tile</code> takes an input and repeats the input <code>multiples</code> times
along each dimension, <code>TileGrad</code> takes in <code>multiples</code> and aggregates
each repeated tile of <code>input</code> into <code>output</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>multiples</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="TopK"></a><h2>TensorFlow <code>TopK</code> Operation</h2><h3>Description</h3><p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
<code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>

<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each
row (resp. vector along the last dimension).  Thus,</p>

<pre><code>values.shape = indices.shape = input.shape[:-1] + [k]
</code></pre>

<p>If two elements are equal, the lower-index element appears first.</p>

<p>If <code>k</code> varies dynamically, use <code>TopKV2</code> below.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>k</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td><p>Number of top elements to look for along the last dimension (along each
row for matrices).</p>
</td></tr><tr><td>sorted</td><td>bool</td><td>b: true
</td><td></td><td><p>If true the resulting <code>k</code> elements will be sorted by the values in
descending order.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D or higher with last dimension at least <code>k</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The <code>k</code> largest elements along each last dimensional slice.</p>
</td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>The indices of <code>values</code> within the last dimension of <code>input</code>.</p>
</td></tr></table><a name="TopKV2"></a><h2>TensorFlow <code>TopKV2</code> Operation</h2><h3>Description</h3><p>If the input is a vector (rank-1), finds the <code>k</code> largest entries in the vector
and outputs their values and indices as vectors.  Thus <code>values[j]</code> is the
<code>j</code>-th largest entry in <code>input</code>, and its index is <code>indices[j]</code>.</p>

<p>For matrices (resp. higher rank input), computes the top <code>k</code> entries in each
row (resp. vector along the last dimension).  Thus,</p>

<pre><code>values.shape = indices.shape = input.shape[:-1] + [k]
</code></pre>

<p>If two elements are equal, the lower-index element appears first.</p>

<p>This is the same as <code>TopK</code>, but takes <code>k</code> as in input rather than an attr.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>sorted</td><td>bool</td><td>b: true
</td><td></td><td><p>If true the resulting <code>k</code> elements will be sorted by the values in
descending order.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li><li><code>DT_UINT8</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D or higher with last dimension at least <code>k</code>.</p>
</td></tr><tr><td><code>k</code></td><td>DT_INT32</td><td></td><td><p>0-D.  Number of top elements to look for along the last dimension (along each
row for matrices).</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>values</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The <code>k</code> largest elements along each last dimensional slice.</p>
</td></tr><tr><td><code>indices</code></td><td>DT_INT32</td><td></td><td><p>The indices of <code>values</code> within the last dimension of <code>input</code>.</p>
</td></tr></table><a name="Transpose"></a><h2>TensorFlow <code>Transpose</code> Operation</h2><h3>Description</h3><p>The output <code>y</code> has the same rank as <code>x</code>. The shapes of <code>x</code> and <code>y</code> satisfy:
  <code>y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]</code></p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>perm</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="TruncatedNormal"></a><h2>TensorFlow <code>TruncatedNormal</code> Operation</h2><h3>Description</h3><p>The generated values follow a normal distribution with mean 0 and standard
deviation 1, except that values whose magnitude is more than 2 standard
deviations from the mean are dropped and re-picked.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either <code>seed</code> or <code>seed2</code> are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>A second seed to avoid seed collision.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_HALF</code></li><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td><p>The type of the output.</p>
</td></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>shape</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The shape of the output tensor.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A tensor of the specified shape filled with random truncated normal
values.</p>
</td></tr></table><a name="UniformCandidateSampler"></a><h2>TensorFlow <code>UniformCandidateSampler</code> Operation</h2><h3>Description</h3><p>See explanations of candidate sampling and the data formats at
go/candidate-sampling.</p>

<p>For each batch, this op picks a single set of sampled candidate labels.</p>

<p>The advantages of sampling candidates per-batch are simplicity and the
possibility of efficient dense matrix multiplication. The disadvantage is that
the sampled candidates must be chosen independently of the context and of the
true labels.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num_true</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of true labels per context.</p>
</td></tr><tr><td>num_sampled</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>Number of candidates to randomly sample per batch.</p>
</td></tr><tr><td>unique</td><td>bool</td><td></td><td></td><td><p>If unique is true, we sample with rejection, so that all sampled
candidates in a batch are unique. This requires some approximation to
estimate the post-rejection sampling probabilities.</p>
</td></tr><tr><td>range_max</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td><p>The sampler will sample integers from the interval [0, range_max).</p>
</td></tr><tr><td>seed</td><td>int</td><td>i: 0
</td><td></td><td><p>If either seed or seed2 are set to be non-zero, the random number
generator is seeded by the given seed.  Otherwise, it is seeded by a
random seed.</p>
</td></tr><tr><td>seed2</td><td>int</td><td>i: 0
</td><td></td><td><p>An second seed to avoid seed collision.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>true_classes</code></td><td>DT_INT64</td><td></td><td><p>A batch<em>size * num</em>true matrix, in which each row contains the
IDs of the num<em>true target</em>classes in the corresponding original label.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>sampled_candidates</code></td><td>DT_INT64</td><td></td><td><p>A vector of length num_sampled, in which each element is
the ID of a sampled candidate.</p>
</td></tr><tr><td><code>true_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A batch<em>size * num</em>true matrix, representing
the number of times each candidate is expected to occur in a batch
of sampled candidates. If unique=true, then this is a probability.</p>
</td></tr><tr><td><code>sampled_expected_count</code></td><td>DT_FLOAT</td><td></td><td><p>A vector of length num_sampled, for each sampled
candidate representing the number of times the candidate is expected
to occur in a batch of sampled candidates.  If unique=true, then this is a
probability.</p>
</td></tr></table><a name="Unique"></a><h2>TensorFlow <code>Unique</code> Operation</h2><h3>Description</h3><p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
sorted in the same order that they occur in <code>x</code>. This operation also returns a
tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
in the unique output <code>y</code>. In other words:</p>

<p><code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code></p>

<p>For example:</p>

<pre><code class="language-prettyprint"># tensor &#39;x&#39; is [1, 1, 2, 4, 4, 4, 7, 8, 8]
y, idx = unique(x)
y ==&gt; [1, 2, 4, 7, 8]
idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.</p>
</td></tr><tr><td><code>idx</code></td><td>DT_INT32</td><td></td><td><p>1-D.</p>
</td></tr></table><a name="UniqueWithCounts"></a><h2>TensorFlow <code>UniqueWithCounts</code> Operation</h2><h3>Description</h3><p>This operation returns a tensor <code>y</code> containing all of the unique elements of <code>x</code>
sorted in the same order that they occur in <code>x</code>. This operation also returns a
tensor <code>idx</code> the same size as <code>x</code> that contains the index of each value of <code>x</code>
in the unique output <code>y</code>. Finally, it returns a third tensor <code>count</code> that
contains the count of each element of <code>y</code> in <code>x</code>. In other words:</p>

<p><code>y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]</code></p>

<p>For example:</p>

<pre><code class="language-prettyprint"># tensor &#39;x&#39; is [1, 1, 2, 4, 4, 4, 7, 8, 8]
y, idx, count = unique_with_counts(x)
y ==&gt; [1, 2, 4, 7, 8]
idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4]
count ==&gt; [2, 1, 3, 1, 2]
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D.</p>
</td></tr><tr><td><code>idx</code></td><td>DT_INT32</td><td></td><td><p>1-D.</p>
</td></tr><tr><td><code>count</code></td><td>DT_INT32</td><td></td><td><p>1-D.</p>
</td></tr></table><a name="Unpack"></a><h2>TensorFlow <code>Unpack</code> Operation</h2><h3>Description</h3><p>Unpacks <code>num</code> tensors from <code>value</code> by chipping it along the <code>axis</code> dimension.
For example, given a tensor of shape <code>(A, B, C, D)</code>;</p>

<p>If <code>axis == 0</code> then the i&#39;th tensor in <code>output</code> is the slice <code>value[i, :, :, :]</code>
  and each tensor in <code>output</code> will have shape <code>(B, C, D)</code>. (Note that the
  dimension unpacked along is gone, unlike <code>split</code>).</p>

<p>If <code>axis == 1</code> then the i&#39;th tensor in <code>output</code> is the slice <code>value[:, i, :, :]</code>
  and each tensor in <code>output</code> will have shape <code>(A, C, D)</code>.
Etc.</p>

<p>This is the opposite of <code>pack</code>.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>num</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>axis</td><td>int</td><td>i: 0
</td><td></td><td><p>Dimension along which to unpack.  Negative values wrap around, so the
valid range is <code>[-R, R)</code>.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>value</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>1-D or higher, with <code>axis</code> dimension size equal to <code>num</code>.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>num</p>
</code></td><td><p>The list of tensors unpacked from <code>value</code>.</p>
</td></tr></table><a name="UnsortedSegmentSum"></a><h2>TensorFlow <code>UnsortedSegmentSum</code> Operation</h2><h3>Description</h3><p>Read <a href="../../api_docs/python/math_ops.md#segmentation">the section on
Segmentation</a> for an explanation
of segments.</p>

<p>Computes a tensor such that
<code>(output[i] = sum_{j...} data[j...]</code> where the sum is over tuples <code>j...</code> such
that <code>segment_ids[j...] == i</code>.  Unlike <code>SegmentSum</code>, <code>segment_ids</code>
need not be sorted and need not cover all values in the full
range of valid values.</p>

<p>If the sum is empty for a given segment ID <code>i</code>, <code>output[i] = 0</code>.</p>

<p><code>num_segments</code> should equal the number of distinct segment IDs.</p>

<div style="width:70%; margin:auto; margin-bottom:10px; margin-top:20px;">
<img style="width:100%" src="../../images/UnsortedSegmentSum.png" alt>
</div>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li><li><code>DT_INT64</code></li><li><code>DT_INT32</code></li><li><code>DT_UINT8</code></li><li><code>DT_UINT16</code></li><li><code>DT_INT16</code></li><li><code>DT_INT8</code></li><li><code>DT_COMPLEX64</code></li><li><code>DT_COMPLEX128</code></li><li><code>DT_QINT8</code></li><li><code>DT_QUINT8</code></li><li><code>DT_QINT32</code></li><li><code>DT_HALF</code></li></ul></td><td></td></tr><tr><td>Tindices</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_INT32</code></li><li><code>DT_INT64</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>data</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>segment_ids</code></td><td><b>attr: </b><code>Tindices</code></td><td></td><td><p>A tensor whose shape is a prefix of <code>data.shape</code>.</p>
</td></tr><tr><td><code>num_segments</code></td><td>DT_INT32</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>Has same shape as data, except for the first <code>segment_ids.rank</code>
dimensions, which are replaced with a single dimension which has size
<code>num_segments</code>.</p>
</td></tr></table><a name="Variable"></a><h2>TensorFlow <code>Variable</code> Operation</h2><h3>Description</h3><p>Outputs a ref to the tensor state so it may be read or modified.
TODO(zhifengc/mrry): Adds a pointer to a more detail document
about sharing states in tensorflow.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>shape</td><td>shape</td><td></td><td></td><td><p>The shape of the variable tensor.</p>
</td></tr><tr><td>dtype</td><td>type</td><td></td><td></td><td><p>The type of elements in the variable tensor.</p>
</td></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this variable is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this variable is named in the given bucket
with this shared_name. Otherwise, the node name is used instead.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>ref</code></td><td><b>attr: </b><code>dtype</code></td><td></td><td><p>A reference to the variable tensor.</p>
</td></tr></table><a name="Where"></a><h2>TensorFlow <code>Where</code> Operation</h2><h3>Description</h3><p>This operation returns the coordinates of true elements in <code>input</code>. The
coordinates are returned in a 2-D tensor where the first dimension (rows)
represents the number of true elements, and the second dimension (columns)
represents the coordinates of the true elements. Keep in mind, the shape of
the output tensor can vary depending on how many true values there are in
<code>input</code>. Indices are output in row-major order.</p>

<p>For example:</p>

<pre><code class="language-prettyprint"># &#39;input&#39; tensor is [[True, False]
#                    [True, False]]
# &#39;input&#39; has two true values, so output has two coordinates.
# &#39;input&#39; has rank of 2, so coordinates have two indices.
where(input) ==&gt; [[0, 0],
                  [1, 0]]

# `input` tensor is [[[True, False]
#                     [True, False]]
#                    [[False, True]
#                     [False, True]]
#                    [[False, False]
#                     [False, True]]]
# &#39;input&#39; has 5 true values, so output has 5 coordinates.
# &#39;input&#39; has rank of 3, so coordinates have three indices.
where(input) ==&gt; [[0, 0, 0],
                  [0, 1, 0],
                  [1, 0, 1],
                  [1, 1, 1],
                  [2, 1, 1]]
</code></pre>
<h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td>DT_BOOL</td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>index</code></td><td>DT_INT64</td><td></td><td></td></tr></table><a name="WholeFileReader"></a><h2>TensorFlow <code>WholeFileReader</code> Operation</h2><h3>Description</h3><p>To use, enqueue filenames in a Queue.  The output of ReaderRead will
be a filename (key) and the contents of that file (value).</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>container</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is placed in the given container.
Otherwise, a default container is used.</p>
</td></tr><tr><td>shared_name</td><td>string</td><td>s: &quot;&quot;
</td><td></td><td><p>If non-empty, this reader is named in the given bucket
with this shared_name. Otherwise, the node name is used instead.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>reader_handle</code></td><td>DT_STRING</td><td></td><td><p>The handle to reference the Reader.</p>
</td></tr></table><a name="ZerosLike"></a><h2>TensorFlow <code>ZerosLike</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>a tensor of type T.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>a tensor of the same shape and type as x but filled with zeros.</p>
</td></tr></table><a name="Zeta"></a><h2>TensorFlow <code>Zeta</code> Operation</h2><h3>Description</h3><p>The Hurwitz zeta function is defined as:</p>

<pre><code>\zeta(x, q) = \sum_{n=0}^{\infty} (q + n)^{-x}
</code></pre>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td><b>One of: </b><ul><li><code>DT_FLOAT</code></li><li><code>DT_DOUBLE</code></li></ul></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr><tr><td><code>q</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>z</code></td><td><b>attr: </b><code>T</code></td><td></td><td></td></tr></table><a name="_Arg"></a><h2>TensorFlow <code>_Arg</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>index</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td><p>This argument is the index-th argument of the function.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The argument.</p>
</td></tr></table><a name="_ArrayToList"></a><h2>TensorFlow <code>_ArrayToList</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>out_types</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>type list: </b><code>out_types</code></td><td></td><td></td></tr></table><a name="_HostCast"></a><h2>TensorFlow <code>_HostCast</code> Operation</h2><h3>Description</h3><p>_HostCast requires its input and produces its output in host memory.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>SrcT</td><td>type</td><td></td><td></td><td></td></tr><tr><td>DstT</td><td>type</td><td></td><td></td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>x</code></td><td><b>attr: </b><code>SrcT</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>y</code></td><td><b>attr: </b><code>DstT</code></td><td></td><td></td></tr></table><a name="_HostRecv"></a><h2>TensorFlow <code>_HostRecv</code> Operation</h2><h3>Description</h3><p>_HostRecv requires its input on host memory whereas _Recv requires its
input on device memory.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>tensor_type</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td></td><td></td><td><p>The name of the tensor to receive.</p>
</td></tr><tr><td>send_device</td><td>string</td><td></td><td></td><td><p>The name of the device sending the tensor.</p>
</td></tr><tr><td>send_device_incarnation</td><td>int</td><td></td><td></td><td><p>The current incarnation of send_device.</p>
</td></tr><tr><td>recv_device</td><td>string</td><td></td><td></td><td><p>The name of the device receiving the tensor.</p>
</td></tr><tr><td>client_terminated</td><td>bool</td><td>b: false
</td><td></td><td><p>If set to true, this indicates that the node was added
to the graph as a result of a client-side feed or fetch of Tensor data,
in which case the corresponding send or recv is expected to be managed
locally by the caller.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>tensor_type</code></td><td></td><td><p>The tensor to receive.</p>
</td></tr></table><a name="_HostSend"></a><h2>TensorFlow <code>_HostSend</code> Operation</h2><h3>Description</h3><p>_HostSend requires its input on host memory whereas _Send requires its
input on device memory.</p>
<h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td></td><td></td><td><p>The name of the tensor to send.</p>
</td></tr><tr><td>send_device</td><td>string</td><td></td><td></td><td><p>The name of the device sending the tensor.</p>
</td></tr><tr><td>send_device_incarnation</td><td>int</td><td></td><td></td><td><p>The current incarnation of send_device.</p>
</td></tr><tr><td>recv_device</td><td>string</td><td></td><td></td><td><p>The name of the device receiving the tensor.</p>
</td></tr><tr><td>client_terminated</td><td>bool</td><td>b: false
</td><td></td><td><p>If set to true, this indicates that the node was added
to the graph as a result of a client-side feed or fetch of Tensor data,
in which case the corresponding send or recv is expected to be managed
locally by the caller.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to send.</p>
</td></tr></table><a name="_ListToArray"></a><h2>TensorFlow <code>_ListToArray</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>Tin</td><td>list(type)</td><td></td><td><b>Minimum: </b>1</td><td></td></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>N</td><td>int</td><td></td><td><b>Minimum: </b>1</td><td></td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>type list: </b><code>Tin</code></td><td></td><td></td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>output</code></td><td><b>attr: </b><code>T</code></td><td><b>number: </b><code><p>N</p>
</code></td><td></td></tr></table><a name="_Recv"></a><h2>TensorFlow <code>_Recv</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>tensor_type</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td></td><td></td><td><p>The name of the tensor to receive.</p>
</td></tr><tr><td>send_device</td><td>string</td><td></td><td></td><td><p>The name of the device sending the tensor.</p>
</td></tr><tr><td>send_device_incarnation</td><td>int</td><td></td><td></td><td><p>The current incarnation of send_device.</p>
</td></tr><tr><td>recv_device</td><td>string</td><td></td><td></td><td><p>The name of the device receiving the tensor.</p>
</td></tr><tr><td>client_terminated</td><td>bool</td><td>b: false
</td><td></td><td><p>If set to true, this indicates that the node was added
to the graph as a result of a client-side feed or fetch of Tensor data,
in which case the corresponding send or recv is expected to be managed
locally by the caller.</p>
</td></tr></table><h3>Output Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>tensor_type</code></td><td></td><td><p>The tensor to receive.</p>
</td></tr></table><a name="_Retval"></a><h2>TensorFlow <code>_Retval</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>index</td><td>int</td><td></td><td><b>Minimum: </b>0</td><td><p>This return value is the index-th return value of the function.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>input</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The return value.</p>
</td></tr></table><a name="_Send"></a><h2>TensorFlow <code>_Send</code> Operation</h2><h3>Description</h3><h3>Attributes</h3><table><tr><th>Attribute</th><th>Type</th><th>Default</th><th>Constraints</th><th>Description</th></tr><tr><td>T</td><td>type</td><td></td><td></td><td></td></tr><tr><td>tensor_name</td><td>string</td><td></td><td></td><td><p>The name of the tensor to send.</p>
</td></tr><tr><td>send_device</td><td>string</td><td></td><td></td><td><p>The name of the device sending the tensor.</p>
</td></tr><tr><td>send_device_incarnation</td><td>int</td><td></td><td></td><td><p>The current incarnation of send_device.</p>
</td></tr><tr><td>recv_device</td><td>string</td><td></td><td></td><td><p>The name of the device receiving the tensor.</p>
</td></tr><tr><td>client_terminated</td><td>bool</td><td>b: false
</td><td></td><td><p>If set to true, this indicates that the node was added
to the graph as a result of a client-side feed or fetch of Tensor data,
in which case the corresponding send or recv is expected to be managed
locally by the caller.</p>
</td></tr></table><h3>Input Arguments</h3><table><tr><th>Name</th><th>Type</th><th>Constraints</th><th>Description</th></tr><tr><td><code>tensor</code></td><td><b>attr: </b><code>T</code></td><td></td><td><p>The tensor to send.</p>
</td></tr></table></p>
</body>
</html>
